; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_timer.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_timer.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||i.TIMER_BRGInit||, CODE, READONLY, ALIGN=2

                  TIMER_BRGInit PROC
;;;1935     */
;;;1936   void TIMER_BRGInit ( MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG ) {
000000  4602              MOV      r2,r0
;;;1937   	uint32_t tmpreg;
;;;1938   
;;;1939   	/* Check the parameters */
;;;1940   	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1941   	assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1942   
;;;1943   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1944   	if(TIMERx == MDR_TIMER4)
;;;1945   		tmpreg = MDR_RST_CLK->UART_CLOCK;
;;;1946   	else
;;;1947   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1948   		tmpreg = MDR_RST_CLK->TIM_CLOCK;
000002  4b10              LDR      r3,|L1.68|
000004  6a58              LDR      r0,[r3,#0x24]
;;;1949   
;;;1950   	if (TIMERx == MDR_TIMER1) {
000006  4b10              LDR      r3,|L1.72|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;1951   		tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
00000c  f02000ff          BIC      r0,r0,#0xff
;;;1952   		tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
000010  4308              ORRS     r0,r0,r1
;;;1953   		tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
000012  f0407080          ORR      r0,r0,#0x1000000
000016  e012              B        |L1.62|
                  |L1.24|
;;;1954   	}
;;;1955   	else
;;;1956   		if (TIMERx == MDR_TIMER2) {
000018  4b0c              LDR      r3,|L1.76|
00001a  429a              CMP      r2,r3
00001c  d106              BNE      |L1.44|
;;;1957   			tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
00001e  f420407f          BIC      r0,r0,#0xff00
;;;1958   			tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
000022  ea402001          ORR      r0,r0,r1,LSL #8
;;;1959   			tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
000026  f0407000          ORR      r0,r0,#0x2000000
00002a  e008              B        |L1.62|
                  |L1.44|
;;;1960   		}
;;;1961   		else
;;;1962   			if (TIMERx == MDR_TIMER3) {
00002c  4b08              LDR      r3,|L1.80|
00002e  429a              CMP      r2,r3
000030  d105              BNE      |L1.62|
;;;1963   				tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
000032  f420007f          BIC      r0,r0,#0xff0000
;;;1964   				tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
000036  ea404001          ORR      r0,r0,r1,LSL #16
;;;1965   				tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
00003a  f0406080          ORR      r0,r0,#0x4000000
                  |L1.62|
;;;1966   			}
;;;1967   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1968   			else
;;;1969   				if(TIMERx == MDR_TIMER4) {
;;;1970   					tmpreg &= ~RST_CLK_UART_CLOCK_TIM4_BRG_Msk;
;;;1971   					tmpreg |= TIMER_BRG << RST_CLK_UART_CLOCK_TIM4_BRG_Pos;
;;;1972   					tmpreg |= RST_CLK_UART_CLOCK_TIM4_CLK_EN;
;;;1973   				} // if(TIMERx == MDR_TIMER4) {
;;;1974   #endif // #if ( (defined (USE_MDR1986VE3) ) || (defined (MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1975   
;;;1976   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1977   	if(TIMERx == MDR_TIMER4)
;;;1978   		MDR_RST_CLK->UART_CLOCK = tmpreg;
;;;1979   	else
;;;1980   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1981   		MDR_RST_CLK->TIM_CLOCK = tmpreg;
00003e  4b01              LDR      r3,|L1.68|
000040  6258              STR      r0,[r3,#0x24]
;;;1982   
;;;1983   }
000042  4770              BX       lr
;;;1984   
                          ENDP

                  |L1.68|
                          DCD      0x40020000
                  |L1.72|
                          DCD      0x40070000
                  |L1.76|
                          DCD      0x40078000
                  |L1.80|
                          DCD      0x40080000

                          AREA ||i.TIMER_BRKPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_BRKPolarityConfig PROC
;;;518      */
;;;519    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000000  460a              MOV      r2,r1
;;;520    {
;;;521      uint32_t tmpreg_BRKETR_CNTRL;
;;;522    
;;;523      /* Check the parameters */
;;;524      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;525      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;526    
;;;527      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;528      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
000004  f0210101          BIC      r1,r1,#1
;;;529      tmpreg_BRKETR_CNTRL += Polarity;
000008  4411              ADD      r1,r1,r2
;;;530      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;531    }
00000c  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.TIMER_ChnBRKResetConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnBRKResetConfig PROC
;;;953      */
;;;954    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;955    {
000002  4603              MOV      r3,r0
;;;956      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;957      uint32_t tmpreg_CH_CNTRL;
;;;958    
;;;959      /* Check the parameters */
;;;960      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;961      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;962      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;963    
;;;964      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;965    
;;;966      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;967      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
00000e  f4205080          BIC      r0,r0,#0x1000
;;;968      tmpreg_CH_CNTRL += NewState;
000012  4410              ADD      r0,r0,r2
;;;969      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;970    }
000016  bd30              POP      {r4,r5,pc}
;;;971    
                          ENDP


                          AREA ||i.TIMER_ChnCCR1_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCCR1_Cmd PROC
;;;1201     */
;;;1202   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1203   {
000002  4603              MOV      r3,r0
;;;1204     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1205     uint32_t tmpreg_CH_CNTRL2;
;;;1206   
;;;1207     /* Check the parameters */
;;;1208     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1209     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1210     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1211   
;;;1212     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1030560          ADD      r5,r3,#0x60
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1213   
;;;1214     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00000c  6820              LDR      r0,[r4,#0]
;;;1215   
;;;1216     /* Form new value */
;;;1217     if (NewState != DISABLE)
00000e  b112              CBZ      r2,|L4.22|
;;;1218     {
;;;1219       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1220       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
000010  f0400004          ORR      r0,r0,#4
000014  e001              B        |L4.26|
                  |L4.22|
;;;1221     }
;;;1222     else
;;;1223     {
;;;1224       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1225       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
000016  f0200004          BIC      r0,r0,#4
                  |L4.26|
;;;1226     }
;;;1227   
;;;1228     /* Configure CNTRL register with new value */
;;;1229     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00001a  6020              STR      r0,[r4,#0]
;;;1230   }
00001c  bd30              POP      {r4,r5,pc}
;;;1231   
                          ENDP


                          AREA ||i.TIMER_ChnCCR1_EventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1170     */
;;;1171   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1172   {
000002  4603              MOV      r3,r0
;;;1173     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1174     uint32_t tmpreg_CH_CNTRL2;
;;;1175   
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1178     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1179     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1180   
;;;1181     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1030560          ADD      r5,r3,#0x60
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1182   
;;;1183     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00000c  6820              LDR      r0,[r4,#0]
;;;1184     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
00000e  f0200003          BIC      r0,r0,#3
;;;1185     tmpreg_CH_CNTRL2 += EventSource;
000012  4410              ADD      r0,r0,r2
;;;1186     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
000014  6020              STR      r0,[r4,#0]
;;;1187   }
000016  bd30              POP      {r4,r5,pc}
;;;1188   
                          ENDP


                          AREA ||i.TIMER_ChnCapturePrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCapturePrescalerConfig PROC
;;;1019     */
;;;1020   void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
000000  b530              PUSH     {r4,r5,lr}
;;;1021   {
000002  4603              MOV      r3,r0
;;;1022     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1023     uint32_t tmpreg_CH_CNTRL;
;;;1024   
;;;1025     /* Check the parameters */
;;;1026     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1027     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1028     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1029   
;;;1030     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1031   
;;;1032     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1033     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
00000e  f02000c0          BIC      r0,r0,#0xc0
;;;1034     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
000012  eb001082          ADD      r0,r0,r2,LSL #6
;;;1035     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000016  6020              STR      r0,[r4,#0]
;;;1036   }
000018  bd30              POP      {r4,r5,pc}
;;;1037   
                          ENDP


                          AREA ||i.TIMER_ChnCompare1Config||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCompare1Config PROC
;;;778    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;779    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;780    #endif
;;;781    {
000002  4614              MOV      r4,r2
;;;782      __IO uint32_t *tmpreg_CNTRL2x;
;;;783      __IO uint32_t *tmpreg_CCR1x;
;;;784      uint32_t tmpreg_CNTRL2;
;;;785    
;;;786      /* Check the parameters */
;;;787      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;788      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;789      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;790    
;;;791      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1000760          ADD      r7,r0,#0x60
000008  eb070581          ADD      r5,r7,r1,LSL #2
;;;792    
;;;793      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
00000c  682a              LDR      r2,[r5,#0]
;;;794      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
00000e  f0220208          BIC      r2,r2,#8
;;;795      tmpreg_CNTRL2 += UpdateMode;
000012  441a              ADD      r2,r2,r3
;;;796      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
000014  602a              STR      r2,[r5,#0]
;;;797    
;;;798      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000016  3710              ADDS     r7,r7,#0x10
000018  eb070681          ADD      r6,r7,r1,LSL #2
;;;799    
;;;800      *tmpreg_CCR1x = Compare;
00001c  6034              STR      r4,[r6,#0]
;;;801    }
00001e  bdf0              POP      {r4-r7,pc}
;;;802    
                          ENDP


                          AREA ||i.TIMER_ChnCompareConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCompareConfig PROC
;;;735    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;736    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;737    #endif
;;;738    {
000002  4614              MOV      r4,r2
;;;739      __IO uint32_t *tmpreg_CNTRL2x;
;;;740      __IO uint32_t *tmpreg_CCRx;
;;;741      uint32_t tmpreg_CNTRL2;
;;;742    
;;;743      /* Check the parameters */
;;;744      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;745      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;746      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;747    
;;;748      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1000760          ADD      r7,r0,#0x60
000008  eb070581          ADD      r5,r7,r1,LSL #2
;;;749    
;;;750      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
00000c  682a              LDR      r2,[r5,#0]
;;;751      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
00000e  f0220208          BIC      r2,r2,#8
;;;752      tmpreg_CNTRL2 += UpdateMode;
000012  441a              ADD      r2,r2,r3
;;;753      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
000014  602a              STR      r2,[r5,#0]
;;;754    
;;;755      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000016  3f50              SUBS     r7,r7,#0x50
000018  eb070681          ADD      r6,r7,r1,LSL #2
;;;756    
;;;757      *tmpreg_CCRx = Compare;
00001c  6034              STR      r4,[r6,#0]
;;;758    }
00001e  bdf0              POP      {r4-r7,pc}
;;;759    
                          ENDP


                          AREA ||i.TIMER_ChnETRResetConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnETRResetConfig PROC
;;;920      */
;;;921    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;922    {
000002  4603              MOV      r3,r0
;;;923      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;924      uint32_t tmpreg_CH_CNTRL;
;;;925    
;;;926      /* Check the parameters */
;;;927      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;928      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;929      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;930    
;;;931      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;932    
;;;933      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;934      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
00000e  f4205000          BIC      r0,r0,#0x2000
;;;935      tmpreg_CH_CNTRL += NewState;
000012  4410              ADD      r0,r0,r2
;;;936      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;937    }
000016  bd30              POP      {r4,r5,pc}
;;;938    
                          ENDP


                          AREA ||i.TIMER_ChnETR_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_ChnETR_Cmd PROC
;;;875      */
;;;876    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;877    {
000002  4603              MOV      r3,r0
;;;878      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;879      uint32_t tmpreg_CH_CNTRL;
;;;880    
;;;881      /* Check the parameters */
;;;882      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;883      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;884      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;885    
;;;886      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;887    
;;;888      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;889    
;;;890      /* Form new value */
;;;891      if (NewState != DISABLE)
00000e  b112              CBZ      r2,|L10.22|
;;;892      {
;;;893        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;894        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
000010  f4407080          ORR      r0,r0,#0x100
000014  e001              B        |L10.26|
                  |L10.22|
;;;895      }
;;;896      else
;;;897      {
;;;898        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;899        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000016  f4207080          BIC      r0,r0,#0x100
                  |L10.26|
;;;900      }
;;;901    
;;;902      /* Configure CNTRL register with new value */
;;;903      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00001a  6020              STR      r0,[r4,#0]
;;;904    }
00001c  bd30              POP      {r4,r5,pc}
;;;905    
                          ENDP


                          AREA ||i.TIMER_ChnEventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnEventSourceConfig PROC
;;;1054     */
;;;1055   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1056   {
000002  4603              MOV      r3,r0
;;;1057     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1058     uint32_t tmpreg_CH_CNTRL;
;;;1059   
;;;1060     /* Check the parameters */
;;;1061     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1062     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1063     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1064   
;;;1065     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1066   
;;;1067     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1068     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
00000e  f0200030          BIC      r0,r0,#0x30
;;;1069     tmpreg_CH_CNTRL += EventSource;
000012  4410              ADD      r0,r0,r2
;;;1070     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1071   }
000016  bd30              POP      {r4,r5,pc}
;;;1072   
                          ENDP


                          AREA ||i.TIMER_ChnFilterConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnFilterConfig PROC
;;;1101     */
;;;1102   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
000000  b530              PUSH     {r4,r5,lr}
;;;1103   {
000002  4603              MOV      r3,r0
;;;1104     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1105     uint32_t tmpreg_CH_CNTRL;
;;;1106   
;;;1107     /* Check the parameters */
;;;1108     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1109     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1110     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1111   
;;;1112     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1113   
;;;1114     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1115     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
00000e  f020000f          BIC      r0,r0,#0xf
;;;1116     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
000012  4410              ADD      r0,r0,r2
;;;1117     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1118   }
000016  bd30              POP      {r4,r5,pc}
;;;1119   
                          ENDP


                          AREA ||i.TIMER_ChnInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnInit PROC
;;;589      */
;;;590    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;591    {
;;;592      uint32_t tmpreg_CH_Number;
;;;593      uint32_t tmpreg_CH_CNTRL;
;;;594      uint32_t tmpreg_CH_CNTRL2;
;;;595    
;;;596      /* Check the parameters */
;;;597      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;598      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;599      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;600      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;601      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;602      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;603      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;604      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;605      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;606      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;607      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;608      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;609      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;610    
;;;611      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
000002  884d              LDRH     r5,[r1,#2]
000004  88ce              LDRH     r6,[r1,#6]
000006  4435              ADD      r5,r5,r6
000008  890e              LDRH     r6,[r1,#8]
00000a  4435              ADD      r5,r5,r6
00000c  894e              LDRH     r6,[r1,#0xa]
00000e  4435              ADD      r5,r5,r6
000010  898e              LDRH     r6,[r1,#0xc]
000012  eb051586          ADD      r5,r5,r6,LSL #6
000016  89ce              LDRH     r6,[r1,#0xe]
000018  4435              ADD      r5,r5,r6
00001a  8a0e              LDRH     r6,[r1,#0x10]
00001c  19ac              ADDS     r4,r5,r6
;;;612                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;613                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;614                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;615                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;616                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;617                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;618    
;;;619      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
00001e  888d              LDRH     r5,[r1,#4]
000020  b10d              CBZ      r5,|L13.38|
;;;620      {
;;;621        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
000022  f5045400          ADD      r4,r4,#0x2000
                  |L13.38|
;;;622      }
;;;623    
;;;624      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
000026  880a              LDRH     r2,[r1,#0]
;;;625    
;;;626      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
000028  f1000520          ADD      r5,r0,#0x20
00002c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;627    
;;;628      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
000030  8a4d              LDRH     r5,[r1,#0x12]
000032  8ace              LDRH     r6,[r1,#0x16]
000034  19ab              ADDS     r3,r5,r6
;;;629                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;630    
;;;631      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
000036  8a8d              LDRH     r5,[r1,#0x14]
000038  b105              CBZ      r5,|L13.60|
;;;632      {
;;;633        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
00003a  1d1b              ADDS     r3,r3,#4
                  |L13.60|
;;;634      }
;;;635    
;;;636      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
00003c  f1000560          ADD      r5,r0,#0x60
000040  f8453022          STR      r3,[r5,r2,LSL #2]
;;;637    }
000044  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP


                          AREA ||i.TIMER_ChnNOutConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutConfig PROC
;;;1475     */
;;;1476   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1477   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1478     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1479     uint32_t tmpreg_CH_CNTRL1;
;;;1480   
;;;1481     /* Check the parameters */
;;;1482     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1483     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1484     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1485     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1486     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1487   
;;;1488     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000006  f1040730          ADD      r7,r4,#0x30
00000a  eb070581          ADD      r5,r7,r1,LSL #2
;;;1489   
;;;1490     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000e  6828              LDR      r0,[r5,#0]
;;;1491     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
000010  f42050f8          BIC      r0,r0,#0x1f00
;;;1492     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
000014  0337              LSLS     r7,r6,#12
000016  eb072782          ADD      r7,r7,r2,LSL #10
00001a  eb072703          ADD      r7,r7,r3,LSL #8
00001e  4438              ADD      r0,r0,r7
;;;1493                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1494                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1495     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000020  6028              STR      r0,[r5,#0]
;;;1496   }
000022  bdf0              POP      {r4-r7,pc}
;;;1497   
                          ENDP


                          AREA ||i.TIMER_ChnNOutModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutModeConfig PROC
;;;1549     */
;;;1550   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000000  b530              PUSH     {r4,r5,lr}
;;;1551   {
000002  4603              MOV      r3,r0
;;;1552     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1553     uint32_t tmpreg_CH_CNTRL1;
;;;1554   
;;;1555     /* Check the parameters */
;;;1556     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1557     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1558     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1559   
;;;1560     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1561   
;;;1562     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1563     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
00000e  f4207040          BIC      r0,r0,#0x300
;;;1564     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
000012  eb002002          ADD      r0,r0,r2,LSL #8
;;;1565     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1566   }
000018  bd30              POP      {r4,r5,pc}
;;;1567   
                          ENDP


                          AREA ||i.TIMER_ChnNOutPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutPolarityConfig PROC
;;;1582     */
;;;1583   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000000  b530              PUSH     {r4,r5,lr}
;;;1584   {
000002  4603              MOV      r3,r0
;;;1585     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1586     uint32_t tmpreg_CH_CNTRL1;
;;;1587   
;;;1588     /* Check the parameters */
;;;1589     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1590     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1591     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1592   
;;;1593     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1594   
;;;1595     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1596     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
00000e  f4205080          BIC      r0,r0,#0x1000
;;;1597     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
000012  eb003002          ADD      r0,r0,r2,LSL #12
;;;1598     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1599   }
000018  bd30              POP      {r4,r5,pc}
;;;1600   
                          ENDP


                          AREA ||i.TIMER_ChnNOutSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutSourceConfig PROC
;;;1514     */
;;;1515   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1516   {
000002  4603              MOV      r3,r0
;;;1517     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1518     uint32_t tmpreg_CH_CNTRL1;
;;;1519   
;;;1520     /* Check the parameters */
;;;1521     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1522     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1523     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1524   
;;;1525     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1526   
;;;1527     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1528     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
00000e  f4206040          BIC      r0,r0,#0xc00
;;;1529     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
000012  eb002082          ADD      r0,r0,r2,LSL #10
;;;1530     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1531   }
000018  bd30              POP      {r4,r5,pc}
;;;1532   
                          ENDP


                          AREA ||i.TIMER_ChnOutConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutConfig PROC
;;;1323     */
;;;1324   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1325   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1326     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1327     uint32_t tmpreg_CH_CNTRL1;
;;;1328   
;;;1329     /* Check the parameters */
;;;1330     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1331     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1332     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1333     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1334     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1335   
;;;1336     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000006  f1040730          ADD      r7,r4,#0x30
00000a  eb070581          ADD      r5,r7,r1,LSL #2
;;;1337   
;;;1338     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000e  6828              LDR      r0,[r5,#0]
;;;1339     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
000010  f020001f          BIC      r0,r0,#0x1f
;;;1340     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
000014  0137              LSLS     r7,r6,#4
000016  eb070782          ADD      r7,r7,r2,LSL #2
00001a  441f              ADD      r7,r7,r3
00001c  4438              ADD      r0,r0,r7
;;;1341                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1342                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1343     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00001e  6028              STR      r0,[r5,#0]
;;;1344   }
000020  bdf0              POP      {r4-r7,pc}
;;;1345   
                          ENDP


                          AREA ||i.TIMER_ChnOutDTGConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutDTGConfig PROC
;;;1619     */
;;;1620   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
000000  b570              PUSH     {r4-r6,lr}
;;;1621                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1622   {
000002  9c04              LDR      r4,[sp,#0x10]
;;;1623     uint32_t tmpreg_CH_DTG;
;;;1624   
;;;1625     /* Check the parameters */
;;;1626     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1627     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1628     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1629     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1630     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1631   
;;;1632     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
000004  eb032602          ADD      r6,r3,r2,LSL #8
000008  1935              ADDS     r5,r6,r4
;;;1633                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1634                   + ClockSource;
;;;1635   
;;;1636     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
00000a  f1000640          ADD      r6,r0,#0x40
00000e  f8465021          STR      r5,[r6,r1,LSL #2]
;;;1637   }
000012  bd70              POP      {r4-r6,pc}
;;;1638   
                          ENDP


                          AREA ||i.TIMER_ChnOutInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutInit PROC
;;;1240     */
;;;1241   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1242   {
;;;1243     uint32_t tmpreg_CH_Number;
;;;1244     uint32_t tmpreg_CH_CNTRL1;
;;;1245     uint32_t tmpreg_CH_DTG;
;;;1246   
;;;1247     /* Check the parameters */
;;;1248     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1249     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1250     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1251     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1252     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1253     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1254     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1255     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1256     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1257     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1258     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1259   
;;;1260     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
000002  884d              LDRH     r5,[r1,#2]
000004  012d              LSLS     r5,r5,#4
000006  888e              LDRH     r6,[r1,#4]
000008  eb050586          ADD      r5,r5,r6,LSL #2
00000c  88ce              LDRH     r6,[r1,#6]
00000e  4435              ADD      r5,r5,r6
000010  890e              LDRH     r6,[r1,#8]
000012  eb053506          ADD      r5,r5,r6,LSL #12
000016  894e              LDRH     r6,[r1,#0xa]
000018  eb052586          ADD      r5,r5,r6,LSL #10
00001c  898e              LDRH     r6,[r1,#0xc]
00001e  eb052306          ADD      r3,r5,r6,LSL #8
;;;1261                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1262                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1263                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1264                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1265                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1266   
;;;1267     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
000022  880a              LDRH     r2,[r1,#0]
;;;1268   
;;;1269     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
000024  f1000530          ADD      r5,r0,#0x30
000028  f8453022          STR      r3,[r5,r2,LSL #2]
;;;1270   
;;;1271     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
00002c  8a0d              LDRH     r5,[r1,#0x10]
00002e  89ce              LDRH     r6,[r1,#0xe]
000030  eb052506          ADD      r5,r5,r6,LSL #8
000034  8a4e              LDRH     r6,[r1,#0x12]
000036  19ac              ADDS     r4,r5,r6
;;;1272                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1273                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1274   
;;;1275     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
000038  f1000540          ADD      r5,r0,#0x40
00003c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;1276   }
000040  bd70              POP      {r4-r6,pc}
;;;1277   
                          ENDP


                          AREA ||i.TIMER_ChnOutModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutModeConfig PROC
;;;1397     */
;;;1398   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000000  b530              PUSH     {r4,r5,lr}
;;;1399   {
000002  4603              MOV      r3,r0
;;;1400     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1401     uint32_t tmpreg_CH_CNTRL1;
;;;1402   
;;;1403     /* Check the parameters */
;;;1404     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1405     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1406     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1407   
;;;1408     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1409   
;;;1410     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1411     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
00000e  f0200003          BIC      r0,r0,#3
;;;1412     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
000012  4410              ADD      r0,r0,r2
;;;1413     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000014  6020              STR      r0,[r4,#0]
;;;1414   }
000016  bd30              POP      {r4,r5,pc}
;;;1415   
                          ENDP


                          AREA ||i.TIMER_ChnOutPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutPolarityConfig PROC
;;;1430     */
;;;1431   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000000  b530              PUSH     {r4,r5,lr}
;;;1432   {
000002  4603              MOV      r3,r0
;;;1433     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1434     uint32_t tmpreg_CH_CNTRL1;
;;;1435   
;;;1436     /* Check the parameters */
;;;1437     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1438     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1439     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1440   
;;;1441     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1442   
;;;1443     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1444     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
00000e  f0200010          BIC      r0,r0,#0x10
;;;1445     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
000012  eb001002          ADD      r0,r0,r2,LSL #4
;;;1446     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1447   }
000018  bd30              POP      {r4,r5,pc}
;;;1448   
                          ENDP


                          AREA ||i.TIMER_ChnOutSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutSourceConfig PROC
;;;1362     */
;;;1363   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1364   {
000002  4603              MOV      r3,r0
;;;1365     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1366     uint32_t tmpreg_CH_CNTRL1;
;;;1367   
;;;1368     /* Check the parameters */
;;;1369     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1370     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1371     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1372   
;;;1373     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1374   
;;;1375     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1376     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
00000e  f020000c          BIC      r0,r0,#0xc
;;;1377     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
000012  eb000082          ADD      r0,r0,r2,LSL #2
;;;1378     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1379   }
000018  bd30              POP      {r4,r5,pc}
;;;1380   
                          ENDP


                          AREA ||i.TIMER_ChnOutStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutStructInit PROC
;;;1283     */
;;;1284   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000000  2100              MOVS     r1,#0
;;;1285   {
;;;1286     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
000002  8041              STRH     r1,[r0,#2]
;;;1287     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
000004  8081              STRH     r1,[r0,#4]
;;;1288     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
000006  80c1              STRH     r1,[r0,#6]
;;;1289     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
000008  8101              STRH     r1,[r0,#8]
;;;1290     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
00000a  8141              STRH     r1,[r0,#0xa]
;;;1291     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
00000c  8181              STRH     r1,[r0,#0xc]
;;;1292     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
00000e  81c1              STRH     r1,[r0,#0xe]
;;;1293     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
000010  8201              STRH     r1,[r0,#0x10]
;;;1294     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
000012  8241              STRH     r1,[r0,#0x12]
;;;1295   }
000014  4770              BX       lr
;;;1296   
                          ENDP


                          AREA ||i.TIMER_ChnREFFormatConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnREFFormatConfig PROC
;;;984      */
;;;985    void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
000000  b530              PUSH     {r4,r5,lr}
;;;986    {
000002  4603              MOV      r3,r0
;;;987      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;988      uint32_t tmpreg_CH_CNTRL;
;;;989    
;;;990      /* Check the parameters */
;;;991      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;992      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;993      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;994    
;;;995      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;996    
;;;997      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;998      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
00000e  f4206060          BIC      r0,r0,#0xe00
;;;999      tmpreg_CH_CNTRL += Format;
000012  4410              ADD      r0,r0,r2
;;;1000     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1001   }
000016  bd30              POP      {r4,r5,pc}
;;;1002   
                          ENDP


                          AREA ||i.TIMER_ChnStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnStructInit PROC
;;;644      */
;;;645    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000000  2100              MOVS     r1,#0
;;;646    {
;;;647      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
000002  8001              STRH     r1,[r0,#0]
;;;648      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
000004  8041              STRH     r1,[r0,#2]
;;;649      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
000006  8081              STRH     r1,[r0,#4]
;;;650      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;651      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;652      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
00000c  8141              STRH     r1,[r0,#0xa]
;;;653      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
00000e  8181              STRH     r1,[r0,#0xc]
;;;654      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
000010  81c1              STRH     r1,[r0,#0xe]
;;;655      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
000012  8201              STRH     r1,[r0,#0x10]
;;;656      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
000014  8241              STRH     r1,[r0,#0x12]
;;;657      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
000016  8281              STRH     r1,[r0,#0x14]
;;;658      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
000018  82c1              STRH     r1,[r0,#0x16]
;;;659    }
00001a  4770              BX       lr
;;;660    
                          ENDP


                          AREA ||i.TIMER_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIMER_ClearFlag PROC
;;;1719     */
;;;1720   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1721   {
;;;1722     /* Check the parameters */
;;;1723     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1724     assert_param(IS_TIMER_STATUS(Flags));
;;;1725   
;;;1726     TIMERx->STATUS &= ~Flags;
000002  438a              BICS     r2,r2,r1
000004  6542              STR      r2,[r0,#0x54]
;;;1727   }
000006  4770              BX       lr
;;;1728   
                          ENDP


                          AREA ||i.TIMER_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_Cmd PROC
;;;149      */
;;;150    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;151    {
;;;152      uint32_t tmpreg_CNTRL;
;;;153    
;;;154      /* Check the parameters */
;;;155      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;156      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;157    
;;;158      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;159    
;;;160      /* Form new value */
;;;161      if (NewState != DISABLE)
000004  b112              CBZ      r2,|L28.12|
;;;162      {
;;;163        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;164        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L28.16|
                  |L28.12|
;;;165      }
;;;166      else
;;;167      {
;;;168        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;169        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
00000c  f0210101          BIC      r1,r1,#1
                  |L28.16|
;;;170      }
;;;171    
;;;172      /* Configure CNTRL register with new value */
;;;173      TIMERx->CNTRL = tmpreg_CNTRL;
000010  60c1              STR      r1,[r0,#0xc]
;;;174    }
000012  4770              BX       lr
;;;175    
                          ENDP


                          AREA ||i.TIMER_CntAutoreloadConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CntAutoreloadConfig PROC
;;;238    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;239    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
000000  b510              PUSH     {r4,lr}
;;;240    #endif
;;;241    {
000002  460b              MOV      r3,r1
;;;242      uint32_t tmpreg_CNTRL;
;;;243    
;;;244      /* Check the parameters */
;;;245      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;246      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;247    
;;;248      tmpreg_CNTRL = TIMERx->CNTRL;
000004  68c1              LDR      r1,[r0,#0xc]
;;;249      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
000006  f0210102          BIC      r1,r1,#2
;;;250      tmpreg_CNTRL += UpdateMode;
00000a  4411              ADD      r1,r1,r2
;;;251      TIMERx->CNTRL = tmpreg_CNTRL;
00000c  60c1              STR      r1,[r0,#0xc]
;;;252    
;;;253      TIMERx->ARR = Autoreload;
00000e  6083              STR      r3,[r0,#8]
;;;254    }
000010  bd10              POP      {r4,pc}
;;;255    
                          ENDP


                          AREA ||i.TIMER_CntEventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CntEventSourceConfig PROC
;;;288      */
;;;289    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
000000  460a              MOV      r2,r1
;;;290    {
;;;291      uint32_t tmpreg_CNTRL;
;;;292    
;;;293      /* Check the parameters */
;;;294      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;295      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;296    
;;;297      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;298      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
000004  f4216170          BIC      r1,r1,#0xf00
;;;299      tmpreg_CNTRL += EventSource;
000008  4411              ADD      r1,r1,r2
;;;300      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;301    }
00000c  4770              BX       lr
;;;302    
                          ENDP


                          AREA ||i.TIMER_CntInit||, CODE, READONLY, ALIGN=1

                  TIMER_CntInit PROC
;;;79       */
;;;80     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;81     {
;;;82       uint32_t tmpreg_CNTRL;
;;;83       uint32_t tmpreg_BRKETR_CNTRL;
;;;84     
;;;85       /* Check the parameters */
;;;86       assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;87       assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;88       assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;89       assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;90       assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;91       assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;92       assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;93       assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;94       assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;95       assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;96     
;;;97       TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000002  880c              LDRH     r4,[r1,#0]
000004  6004              STR      r4,[r0,#0]
;;;98       TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
000006  884c              LDRH     r4,[r1,#2]
000008  6044              STR      r4,[r0,#4]
;;;99       TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00000a  888c              LDRH     r4,[r1,#4]
00000c  6084              STR      r4,[r0,#8]
;;;100    
;;;101      /* Form new value for the TIMERx_CNTRL register */
;;;102      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
00000e  88cc              LDRH     r4,[r1,#6]
000010  890d              LDRH     r5,[r1,#8]
000012  442c              ADD      r4,r4,r5
000014  894d              LDRH     r5,[r1,#0xa]
000016  442c              ADD      r4,r4,r5
000018  898d              LDRH     r5,[r1,#0xc]
00001a  442c              ADD      r4,r4,r5
00001c  89cd              LDRH     r5,[r1,#0xe]
00001e  1963              ADDS     r3,r4,r5
;;;103                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;104                   + TIMER_CntInitStruct->TIMER_EventSource
;;;105                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;106                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;107    
;;;108      /* Configure TIMERx_CNTRL register with new value */
;;;109      TIMERx->CNTRL = tmpreg_CNTRL;
000020  60c3              STR      r3,[r0,#0xc]
;;;110    
;;;111      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;112      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000022  8a4c              LDRH     r4,[r1,#0x12]
000024  8a0d              LDRH     r5,[r1,#0x10]
000026  eb041405          ADD      r4,r4,r5,LSL #4
00002a  8a8d              LDRH     r5,[r1,#0x14]
00002c  442c              ADD      r4,r4,r5
00002e  8acd              LDRH     r5,[r1,#0x16]
000030  1962              ADDS     r2,r4,r5
;;;113                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;114                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;115                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;116    
;;;117      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;118      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000032  6502              STR      r2,[r0,#0x50]
;;;119    }
000034  bd30              POP      {r4,r5,pc}
;;;120    
                          ENDP


                          AREA ||i.TIMER_CntStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_CntStructInit PROC
;;;126      */
;;;127    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000000  2100              MOVS     r1,#0
;;;128    {
;;;129      TIMER_CntInitStruct->TIMER_IniCounter = 0;
000002  8001              STRH     r1,[r0,#0]
;;;130      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
000004  8041              STRH     r1,[r0,#2]
;;;131      TIMER_CntInitStruct->TIMER_Period     = 0;
000006  8081              STRH     r1,[r0,#4]
;;;132      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000008  80c1              STRH     r1,[r0,#6]
;;;133      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
00000a  8101              STRH     r1,[r0,#8]
;;;134      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
00000c  8141              STRH     r1,[r0,#0xa]
;;;135      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
00000e  8181              STRH     r1,[r0,#0xc]
;;;136      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
000010  81c1              STRH     r1,[r0,#0xe]
;;;137      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
000012  8201              STRH     r1,[r0,#0x10]
;;;138      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
000014  8241              STRH     r1,[r0,#0x12]
;;;139      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000016  8281              STRH     r1,[r0,#0x14]
;;;140      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000018  82c1              STRH     r1,[r0,#0x16]
;;;141    }
00001a  4770              BX       lr
;;;142    
                          ENDP


                          AREA ||i.TIMER_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CounterModeConfig PROC
;;;338      */
;;;339    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
000000  460a              MOV      r2,r1
;;;340    {
;;;341      uint32_t tmpreg_CNTRL;
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;345      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;346    
;;;347      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;348      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
000004  f02101c0          BIC      r1,r1,#0xc0
;;;349      tmpreg_CNTRL += Mode;
000008  4411              ADD      r1,r1,r2
;;;350      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;351    }
00000c  4770              BX       lr
;;;352    
                          ENDP


                          AREA ||i.TIMER_DMACmd||, CODE, READONLY, ALIGN=1

                  TIMER_DMACmd PROC
;;;1766   #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1767   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1768   #endif
;;;1769   {
000002  4613              MOV      r3,r2
;;;1770     uint32_t tmpreg_DMA_RE;
;;;1771   
;;;1772     /* Check the parameters */
;;;1773     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1774     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1775     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1776   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1777     if(TIMER_DMAChannel == TIMER_DMA_Channel0){
;;;1778   #endif
;;;1779   	  tmpreg_DMA_RE = TIMERx->DMA_RE;
000004  6dc2              LDR      r2,[r0,#0x5c]
;;;1780   
;;;1781   	  /* Form new value */
;;;1782   	  if (NewState != DISABLE)
000006  b10b              CBZ      r3,|L34.12|
;;;1783   	  {
;;;1784   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1785   		tmpreg_DMA_RE |= TIMER_DMASource;
000008  430a              ORRS     r2,r2,r1
00000a  e000              B        |L34.14|
                  |L34.12|
;;;1786   	  }
;;;1787   	  else
;;;1788   	  {
;;;1789   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1790   		tmpreg_DMA_RE &= ~TIMER_DMASource;
00000c  438a              BICS     r2,r2,r1
                  |L34.14|
;;;1791   	  }
;;;1792   
;;;1793   	  /* Configure CNTRL register with new value */
;;;1794   	  TIMERx->DMA_RE = tmpreg_DMA_RE;
00000e  65c2              STR      r2,[r0,#0x5c]
;;;1795   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1796     }
;;;1797     else{
;;;1798   	  tmpreg_DMA_RE = TIMERx->DMA_REChx[TIMER_DMAChannel];
;;;1799   
;;;1800   	  /* Form new value */
;;;1801   	  if (NewState != DISABLE)
;;;1802   	  {
;;;1803   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1804   		tmpreg_DMA_RE |= TIMER_DMASource;
;;;1805   	  }
;;;1806   	  else
;;;1807   	  {
;;;1808   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1809   		tmpreg_DMA_RE &= ~TIMER_DMASource;
;;;1810   	  }
;;;1811   
;;;1812   	  /* Configure CNTRL register with new value */
;;;1813   	  TIMERx->DMA_REChx[TIMER_DMAChannel] = tmpreg_DMA_RE;
;;;1814   
;;;1815     }
;;;1816   #endif
;;;1817   }
000010  bd10              POP      {r4,pc}
;;;1818   
                          ENDP


                          AREA ||i.TIMER_DeInit||, CODE, READONLY, ALIGN=1

                  TIMER_DeInit PROC
;;;26       */
;;;27     void TIMER_DeInit ( MDR_TIMER_TypeDef* TIMERx ) {
000000  2100              MOVS     r1,#0
;;;28     	/* Check the parameters */
;;;29     	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;30     
;;;31     	TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;32     	TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;33     	TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;34     	TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;35     
;;;36     	TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;37     	TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;38     	TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;39     	TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;40     	TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;41     	TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;42     	TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;43     	TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;44     	TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;45     	TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;46     	TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;47     	TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;48     
;;;49     	TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;50     	TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;51     	TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;52     	TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;53     	TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;54     	TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;55     	TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;56     	TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;57     	TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;58     	TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;59     	TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;60     	TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;61     	TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;62     	TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;63     	TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;64     	TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;65     #if defined(USE_MDR1986VE3) || defined (USE_MDR1986VE1T) /* For Cortex M1 */
;;;66     	TIMERx->DMA_REChx[0] = TIMERx->DMA_REChx[1] =
;;;67     			TIMERx->DMA_REChx[2] = TIMERx->DMA_REChx[3] = 0;
;;;68     #endif
;;;69     }
000042  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.TIMER_ETRFilterConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRFilterConfig PROC
;;;447      */
;;;448    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
000000  460a              MOV      r2,r1
;;;449    {
;;;450      uint32_t tmpreg_BRKETR_CNTRL;
;;;451    
;;;452      /* Check the parameters */
;;;453      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;454      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;455    
;;;456      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;457      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;458      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000008  eb011102          ADD      r1,r1,r2,LSL #4
;;;459      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000c  6501              STR      r1,[r0,#0x50]
;;;460    }
00000e  4770              BX       lr
;;;461    
                          ENDP


                          AREA ||i.TIMER_ETRInputConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRInputConfig PROC
;;;408      */
;;;409    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
000000  b530              PUSH     {r4,r5,lr}
;;;410    {
000002  460c              MOV      r4,r1
;;;411      uint32_t tmpreg_BRKETR_CNTRL;
;;;412    
;;;413      /* Check the parameters */
;;;414      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;415      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;416      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;417      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;418    
;;;419      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000004  6d01              LDR      r1,[r0,#0x50]
;;;420      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
000006  f02101fe          BIC      r1,r1,#0xfe
;;;421      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
00000a  18a5              ADDS     r5,r4,r2
00000c  eb051503          ADD      r5,r5,r3,LSL #4
000010  4429              ADD      r1,r1,r5
;;;422      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000012  6501              STR      r1,[r0,#0x50]
;;;423    }
000014  bd30              POP      {r4,r5,pc}
;;;424    
                          ENDP


                          AREA ||i.TIMER_ETRPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRPolarityConfig PROC
;;;495      */
;;;496    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000000  460a              MOV      r2,r1
;;;497    {
;;;498      uint32_t tmpreg_BRKETR_CNTRL;
;;;499    
;;;500      /* Check the parameters */
;;;501      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;502      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;503    
;;;504      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;505      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000004  f0210102          BIC      r1,r1,#2
;;;506      tmpreg_BRKETR_CNTRL += Polarity;
000008  4411              ADD      r1,r1,r2
;;;507      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;508    }
00000c  4770              BX       lr
;;;509    
                          ENDP


                          AREA ||i.TIMER_ETRPrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRPrescalerConfig PROC
;;;472      */
;;;473    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
000000  460a              MOV      r2,r1
;;;474    {
;;;475      uint32_t tmpreg_BRKETR_CNTRL;
;;;476    
;;;477      /* Check the parameters */
;;;478      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;479      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;480    
;;;481      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;482      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
000004  f021010c          BIC      r1,r1,#0xc
;;;483      tmpreg_BRKETR_CNTRL += Prescaler;
000008  4411              ADD      r1,r1,r2
;;;484      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;485    }
00000c  4770              BX       lr
;;;486    
                          ENDP


                          AREA ||i.TIMER_FilterSamplingConfig||, CODE, READONLY, ALIGN=1

                  TIMER_FilterSamplingConfig PROC
;;;313      */
;;;314    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
000000  460a              MOV      r2,r1
;;;315    {
;;;316      uint32_t tmpreg_CNTRL;
;;;317    
;;;318      /* Check the parameters */
;;;319      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;320      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;321    
;;;322      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;323      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
000004  f0210130          BIC      r1,r1,#0x30
;;;324      tmpreg_CNTRL += Prescaler;
000008  4411              ADD      r1,r1,r2
;;;325      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;326    }
00000c  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.TIMER_GetChnCapture||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnCapture PROC
;;;816    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;817    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;818    #endif
;;;819    {
000002  4602              MOV      r2,r0
;;;820      __IO uint32_t *tmpreg_CCRx;
;;;821      uint32_t tmpreg;
;;;822    
;;;823      /* Check the parameters */
;;;824      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;825      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;826    
;;;827      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000004  f1020010          ADD      r0,r2,#0x10
000008  eb000381          ADD      r3,r0,r1,LSL #2
;;;828      tmpreg = *tmpreg_CCRx;
00000c  681c              LDR      r4,[r3,#0]
;;;829    
;;;830      return tmpreg;
00000e  b2a0              UXTH     r0,r4
;;;831    }
000010  bd10              POP      {r4,pc}
;;;832    
                          ENDP


                          AREA ||i.TIMER_GetChnCapture1||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnCapture1 PROC
;;;846    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;847    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;848    #endif
;;;849    {
000002  4602              MOV      r2,r0
;;;850      __IO uint32_t *tmpreg_CCR1x;
;;;851      uint32_t tmpreg;
;;;852    
;;;853      /* Check the parameters */
;;;854      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;855      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;856    
;;;857      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000004  f1020070          ADD      r0,r2,#0x70
000008  eb000381          ADD      r3,r0,r1,LSL #2
;;;858      tmpreg = *tmpreg_CCR1x;
00000c  681c              LDR      r4,[r3,#0]
;;;859    
;;;860      return tmpreg;
00000e  b2a0              UXTH     r0,r4
;;;861    }
000010  bd10              POP      {r4,pc}
;;;862    
                          ENDP


                          AREA ||i.TIMER_GetChnWriteComplete||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnWriteComplete PROC
;;;1130     */
;;;1131   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1132   {
000002  4602              MOV      r2,r0
;;;1133     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1134     FlagStatus bitstatus;
;;;1135   
;;;1136     /* Check the parameters */
;;;1137     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1138     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1139   
;;;1140     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1020420          ADD      r4,r2,#0x20
000008  eb040381          ADD      r3,r4,r1,LSL #2
;;;1141   
;;;1142     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
00000c  681c              LDR      r4,[r3,#0]
00000e  f4044480          AND      r4,r4,#0x4000
000012  b90c              CBNZ     r4,|L43.24|
;;;1143     {
;;;1144       bitstatus = RESET;
000014  2000              MOVS     r0,#0
000016  e000              B        |L43.26|
                  |L43.24|
;;;1145     }
;;;1146     else
;;;1147     {
;;;1148       bitstatus = SET;
000018  2001              MOVS     r0,#1
                  |L43.26|
;;;1149     }
;;;1150   
;;;1151     return bitstatus;
;;;1152   }
00001a  bd10              POP      {r4,pc}
;;;1153   
                          ENDP


                          AREA ||i.TIMER_GetCntWriteComplete||, CODE, READONLY, ALIGN=1

                  TIMER_GetCntWriteComplete PROC
;;;561      */
;;;562    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;563    {
;;;564      FlagStatus bitstatus;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;568    
;;;569      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0020204          AND      r2,r2,#4
000008  b90a              CBNZ     r2,|L44.14|
;;;570      {
;;;571        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L44.16|
                  |L44.14|
;;;572      }
;;;573      else
;;;574      {
;;;575        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L44.16|
;;;576      }
;;;577    
;;;578      return bitstatus;
;;;579    }
000010  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.TIMER_GetCounter||, CODE, READONLY, ALIGN=1

                  TIMER_GetCounter PROC
;;;263    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;264    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;265    #endif
;;;266    {
;;;267      /* Check the parameters */
;;;268      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;269    
;;;270      return TIMERx->CNT;
000002  6808              LDR      r0,[r1,#0]
000004  b280              UXTH     r0,r0
;;;271    }
000006  4770              BX       lr
;;;272    
                          ENDP


                          AREA ||i.TIMER_GetCounterDirection||, CODE, READONLY, ALIGN=1

                  TIMER_GetCounterDirection PROC
;;;537      */
;;;538    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;539    {
;;;540      uint32_t bitstatus;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544    
;;;545      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0020208          AND      r2,r2,#8
000008  b90a              CBNZ     r2,|L46.14|
;;;546      {
;;;547        bitstatus = TIMER_CntDir_Up;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L46.16|
                  |L46.14|
;;;548      }
;;;549      else
;;;550      {
;;;551        bitstatus = TIMER_CntDir_Dn;
00000e  2008              MOVS     r0,#8
                  |L46.16|
;;;552      }
;;;553    
;;;554      return bitstatus;
;;;555    }
000010  4770              BX       lr
;;;556    
                          ENDP


                          AREA ||i.TIMER_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetFlagStatus PROC
;;;1675     */
;;;1676   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
000000  4602              MOV      r2,r0
;;;1677   {
;;;1678     FlagStatus bitstatus;
;;;1679   
;;;1680     /* Check the parameters */
;;;1681     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1682     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1683   
;;;1684     if ((TIMERx->STATUS & Flag) == 0)
000002  6d53              LDR      r3,[r2,#0x54]
000004  400b              ANDS     r3,r3,r1
000006  b90b              CBNZ     r3,|L47.12|
;;;1685     {
;;;1686       bitstatus = RESET;
000008  2000              MOVS     r0,#0
00000a  e000              B        |L47.14|
                  |L47.12|
;;;1687     }
;;;1688     else
;;;1689     {
;;;1690       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L47.14|
;;;1691     }
;;;1692   
;;;1693     return bitstatus;
;;;1694   }
00000e  4770              BX       lr
;;;1695   
                          ENDP


                          AREA ||i.TIMER_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetITStatus PROC
;;;1895     */
;;;1896   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
000000  b510              PUSH     {r4,lr}
;;;1897   {
000002  4602              MOV      r2,r0
;;;1898     ITStatus bitstatus;
;;;1899     uint32_t tmpreg;
;;;1900   
;;;1901     /* Check the parameters */
;;;1902     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1903     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1904   
;;;1905     tmpreg = TIMERx->IE;
000004  6d93              LDR      r3,[r2,#0x58]
;;;1906     tmpreg = TIMERx->STATUS & tmpreg & TIMER_IT;
000006  6d54              LDR      r4,[r2,#0x54]
000008  401c              ANDS     r4,r4,r3
00000a  ea040301          AND      r3,r4,r1
;;;1907   
;;;1908     if (tmpreg == 0)
00000e  b90b              CBNZ     r3,|L48.20|
;;;1909     {
;;;1910       bitstatus = RESET;
000010  2000              MOVS     r0,#0
000012  e000              B        |L48.22|
                  |L48.20|
;;;1911     }
;;;1912     else
;;;1913     {
;;;1914       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L48.22|
;;;1915     }
;;;1916   
;;;1917     return bitstatus;
;;;1918   }
000016  bd10              POP      {r4,pc}
;;;1919   
                          ENDP


                          AREA ||i.TIMER_GetStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetStatus PROC
;;;1643     */
;;;1644   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;1645   {
;;;1646     /* Check the parameters */
;;;1647     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1648   
;;;1649     return (TIMERx->STATUS);
000002  6d48              LDR      r0,[r1,#0x54]
;;;1650   }
000004  4770              BX       lr
;;;1651   
                          ENDP


                          AREA ||i.TIMER_ITConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ITConfig PROC
;;;1844     */
;;;1845   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1846   {
000002  4613              MOV      r3,r2
;;;1847     uint32_t tmpreg_IE;
;;;1848   
;;;1849     /* Check the parameters */
;;;1850     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1851     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1852     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1853   
;;;1854     tmpreg_IE = TIMERx->IE;
000004  6d82              LDR      r2,[r0,#0x58]
;;;1855   
;;;1856     /* Form new value */
;;;1857     if (NewState != DISABLE)
000006  b10b              CBZ      r3,|L50.12|
;;;1858     {
;;;1859       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1860       tmpreg_IE |= TIMER_IT;
000008  430a              ORRS     r2,r2,r1
00000a  e000              B        |L50.14|
                  |L50.12|
;;;1861     }
;;;1862     else
;;;1863     {
;;;1864       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1865       tmpreg_IE &= ~TIMER_IT;
00000c  438a              BICS     r2,r2,r1
                  |L50.14|
;;;1866     }
;;;1867   
;;;1868     /* Configure CNTRL register with new value */
;;;1869     TIMERx->IE = tmpreg_IE;
00000e  6582              STR      r2,[r0,#0x58]
;;;1870   }
000010  bd10              POP      {r4,pc}
;;;1871   
                          ENDP


                          AREA ||i.TIMER_SetChnCompare||, CODE, READONLY, ALIGN=1

                  TIMER_SetChnCompare PROC
;;;675    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;676    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
000000  b510              PUSH     {r4,lr}
;;;677    #endif
;;;678    {
;;;679      __IO uint32_t *tmpreg_CCRx;
;;;680    
;;;681      /* Check the parameters */
;;;682      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;683      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;684    
;;;685      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000002  f1000410          ADD      r4,r0,#0x10
000006  eb040381          ADD      r3,r4,r1,LSL #2
;;;686      *tmpreg_CCRx = Compare;
00000a  601a              STR      r2,[r3,#0]
;;;687    }
00000c  bd10              POP      {r4,pc}
;;;688    
                          ENDP


                          AREA ||i.TIMER_SetChnCompare1||, CODE, READONLY, ALIGN=1

                  TIMER_SetChnCompare1 PROC
;;;703    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;704    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
000000  b510              PUSH     {r4,lr}
;;;705    #endif
;;;706    {
;;;707      __IO uint32_t *tmpreg_CCR1x;
;;;708    
;;;709      /* Check the parameters */
;;;710      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;711      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;712    
;;;713      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000002  f1000470          ADD      r4,r0,#0x70
000006  eb040381          ADD      r3,r4,r1,LSL #2
;;;714      *tmpreg_CCR1x = Compare;
00000a  601a              STR      r2,[r3,#0]
;;;715    }
00000c  bd10              POP      {r4,pc}
;;;716    
                          ENDP


                          AREA ||i.TIMER_SetCntAutoreload||, CODE, READONLY, ALIGN=1

                  TIMER_SetCntAutoreload PROC
;;;216    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;217    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
000000  6081              STR      r1,[r0,#8]
;;;218    #endif
;;;219    {
;;;220      /* Check the parameters */
;;;221      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;222    
;;;223      TIMERx->ARR = Autoreload;
;;;224    }
000002  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.TIMER_SetCntPrescaler||, CODE, READONLY, ALIGN=1

                  TIMER_SetCntPrescaler PROC
;;;199      */
;;;200    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
000000  6041              STR      r1,[r0,#4]
;;;201    {
;;;202      /* Check the parameters */
;;;203      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;204    
;;;205      TIMERx->PSG = Prescaler;
;;;206    }
000002  4770              BX       lr
;;;207    
                          ENDP


                          AREA ||i.TIMER_SetCounter||, CODE, READONLY, ALIGN=1

                  TIMER_SetCounter PROC
;;;184    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;185    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
000000  6001              STR      r1,[r0,#0]
;;;186    #endif
;;;187    {
;;;188      /* Check the parameters */
;;;189      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;190    
;;;191      TIMERx->CNT = Counter;
;;;192    }
000002  4770              BX       lr
;;;193    
                          ENDP


                          AREA ||i.TIMER_SetCounterDirection||, CODE, READONLY, ALIGN=1

                  TIMER_SetCounterDirection PROC
;;;361      */
;;;362    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
000000  460a              MOV      r2,r1
;;;363    {
;;;364      uint32_t tmpreg_CNTRL;
;;;365    
;;;366      /* Check the parameters */
;;;367      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;368      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;369    
;;;370      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;371      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
000004  f0210108          BIC      r1,r1,#8
;;;372      tmpreg_CNTRL += Direction;
000008  4411              ADD      r1,r1,r2
;;;373      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;374    }
00000c  4770              BX       lr
;;;375    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 482
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____RRX|
#line 669
|__asm___17_MDR32F9Qx_timer_c_566b03da____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
