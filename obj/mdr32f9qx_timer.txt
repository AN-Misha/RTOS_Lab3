; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_timer.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_timer.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_timer.c]
                          THUMB

                          AREA ||i.TIMER_BRGInit||, CODE, READONLY, ALIGN=2

                  TIMER_BRGInit PROC
;;;1953     */
;;;1954   void TIMER_BRGInit ( MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_BRG ) {
000000  4602              MOV      r2,r0
;;;1955   	uint32_t tmpreg;
;;;1956   
;;;1957   	/* Check the parameters */
;;;1958   	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1959   	assert_param(IS_TIMER_CLOCK_BRG(TIMER_BRG));
;;;1960   
;;;1961   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1962   	if(TIMERx == MDR_TIMER4)
;;;1963   		tmpreg = MDR_RST_CLK->UART_CLOCK;
;;;1964   	else
;;;1965   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1966   		tmpreg = MDR_RST_CLK->TIM_CLOCK;
000002  4b10              LDR      r3,|L1.68|
000004  6a58              LDR      r0,[r3,#0x24]
;;;1967   
;;;1968   	if (TIMERx == MDR_TIMER1) {
000006  4b10              LDR      r3,|L1.72|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;1969   		tmpreg &= ~RST_CLK_TIM_CLOCK_TIM1_BRG_Msk;
00000c  f02000ff          BIC      r0,r0,#0xff
;;;1970   		tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM1_BRG_Pos;
000010  4308              ORRS     r0,r0,r1
;;;1971   		tmpreg |= RST_CLK_TIM_CLOCK_TIM1_CLK_EN;
000012  f0407080          ORR      r0,r0,#0x1000000
000016  e012              B        |L1.62|
                  |L1.24|
;;;1972   	}
;;;1973   	else
;;;1974   		if (TIMERx == MDR_TIMER2) {
000018  4b0c              LDR      r3,|L1.76|
00001a  429a              CMP      r2,r3
00001c  d106              BNE      |L1.44|
;;;1975   			tmpreg &= ~RST_CLK_TIM_CLOCK_TIM2_BRG_Msk;
00001e  f420407f          BIC      r0,r0,#0xff00
;;;1976   			tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM2_BRG_Pos;
000022  ea402001          ORR      r0,r0,r1,LSL #8
;;;1977   			tmpreg |= RST_CLK_TIM_CLOCK_TIM2_CLK_EN;
000026  f0407000          ORR      r0,r0,#0x2000000
00002a  e008              B        |L1.62|
                  |L1.44|
;;;1978   		}
;;;1979   		else
;;;1980   			if (TIMERx == MDR_TIMER3) {
00002c  4b08              LDR      r3,|L1.80|
00002e  429a              CMP      r2,r3
000030  d105              BNE      |L1.62|
;;;1981   				tmpreg &= ~RST_CLK_TIM_CLOCK_TIM3_BRG_Msk;
000032  f420007f          BIC      r0,r0,#0xff0000
;;;1982   				tmpreg |= TIMER_BRG << RST_CLK_TIM_CLOCK_TIM3_BRG_Pos;
000036  ea404001          ORR      r0,r0,r1,LSL #16
;;;1983   				tmpreg |= RST_CLK_TIM_CLOCK_TIM3_CLK_EN;
00003a  f0406080          ORR      r0,r0,#0x4000000
                  |L1.62|
;;;1984   			}
;;;1985   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1986   			else
;;;1987   				if(TIMERx == MDR_TIMER4) {
;;;1988   					tmpreg &= ~RST_CLK_UART_CLOCK_TIM4_BRG_Msk;
;;;1989   					tmpreg |= TIMER_BRG << RST_CLK_UART_CLOCK_TIM4_BRG_Pos;
;;;1990   					tmpreg |= RST_CLK_UART_CLOCK_TIM4_CLK_EN;
;;;1991   				} // if(TIMERx == MDR_TIMER4) {
;;;1992   #endif // #if ( (defined (USE_MDR1986VE3) ) || (defined (MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1993   
;;;1994   #if ( (defined (USE_MDR1986VE3) ) || (defined (USE_MDR1986VE1T)) ) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1995   	if(TIMERx == MDR_TIMER4)
;;;1996   		MDR_RST_CLK->UART_CLOCK = tmpreg;
;;;1997   	else
;;;1998   #endif // #if (defined (USE_MDR1986VE3) || defined (MDR1986VE1T)) /* For USE_MDR1986VE3 (Cortex M1) */
;;;1999   		MDR_RST_CLK->TIM_CLOCK = tmpreg;
00003e  4b01              LDR      r3,|L1.68|
000040  6258              STR      r0,[r3,#0x24]
;;;2000   
;;;2001   }
000042  4770              BX       lr
;;;2002   
                          ENDP

                  |L1.68|
                          DCD      0x40020000
                  |L1.72|
                          DCD      0x40070000
                  |L1.76|
                          DCD      0x40078000
                  |L1.80|
                          DCD      0x40080000

                          AREA ||i.TIMER_BRKPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_BRKPolarityConfig PROC
;;;537      */
;;;538    void TIMER_BRKPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000000  460a              MOV      r2,r1
;;;539    {
;;;540      uint32_t tmpreg_BRKETR_CNTRL;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;544      assert_param(IS_TIMER_BRK_POLARITY(Polarity));
;;;545    
;;;546      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;547      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_BRK_INV;
000004  f0210101          BIC      r1,r1,#1
;;;548      tmpreg_BRKETR_CNTRL += Polarity;
000008  4411              ADD      r1,r1,r2
;;;549      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;550    }
00000c  4770              BX       lr
;;;551    
                          ENDP


                          AREA ||i.TIMER_ChnBRKResetConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnBRKResetConfig PROC
;;;972      */
;;;973    void TIMER_ChnBRKResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;974    {
000002  4603              MOV      r3,r0
;;;975      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;976      uint32_t tmpreg_CH_CNTRL;
;;;977    
;;;978      /* Check the parameters */
;;;979      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;980      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;981      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(NewState));
;;;982    
;;;983      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;984    
;;;985      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;986      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_BRKEN;
00000e  f4205080          BIC      r0,r0,#0x1000
;;;987      tmpreg_CH_CNTRL += NewState;
000012  4410              ADD      r0,r0,r2
;;;988      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;989    }
000016  bd30              POP      {r4,r5,pc}
;;;990    
                          ENDP


                          AREA ||i.TIMER_ChnCCR1_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCCR1_Cmd PROC
;;;1220     */
;;;1221   void TIMER_ChnCCR1_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;1222   {
000002  4603              MOV      r3,r0
;;;1223     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1224     uint32_t tmpreg_CH_CNTRL2;
;;;1225   
;;;1226     /* Check the parameters */
;;;1227     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1228     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1229     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1230   
;;;1231     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1030560          ADD      r5,r3,#0x60
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1232   
;;;1233     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00000c  6820              LDR      r0,[r4,#0]
;;;1234   
;;;1235     /* Form new value */
;;;1236     if (NewState != DISABLE)
00000e  b112              CBZ      r2,|L4.22|
;;;1237     {
;;;1238       /* Enable TIMERx by setting the CCR1_EN bit in the CNTRL2 register */
;;;1239       tmpreg_CH_CNTRL2 |= TIMER_CH_CNTRL2_CCR1_EN;
000010  f0400004          ORR      r0,r0,#4
000014  e001              B        |L4.26|
                  |L4.22|
;;;1240     }
;;;1241     else
;;;1242     {
;;;1243       /* Disable TIMERx by resetting the CCR1_EN bit in the CNTRL2 register */
;;;1244       tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CCR1_EN;
000016  f0200004          BIC      r0,r0,#4
                  |L4.26|
;;;1245     }
;;;1246   
;;;1247     /* Configure CNTRL register with new value */
;;;1248     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
00001a  6020              STR      r0,[r4,#0]
;;;1249   }
00001c  bd30              POP      {r4,r5,pc}
;;;1250   
                          ENDP


                          AREA ||i.TIMER_ChnCCR1_EventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCCR1_EventSourceConfig PROC
;;;1189     */
;;;1190   void TIMER_ChnCCR1_EventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1191   {
000002  4603              MOV      r3,r0
;;;1192     __IO uint32_t *tmpreg_CH_CNTRL2x;
;;;1193     uint32_t tmpreg_CH_CNTRL2;
;;;1194   
;;;1195     /* Check the parameters */
;;;1196     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1197     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1198     assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(EventSource));
;;;1199   
;;;1200     tmpreg_CH_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1030560          ADD      r5,r3,#0x60
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1201   
;;;1202     tmpreg_CH_CNTRL2 = *tmpreg_CH_CNTRL2x;
00000c  6820              LDR      r0,[r4,#0]
;;;1203     tmpreg_CH_CNTRL2 &= ~TIMER_CH_CNTRL2_CHSEL1_Msk;
00000e  f0200003          BIC      r0,r0,#3
;;;1204     tmpreg_CH_CNTRL2 += EventSource;
000012  4410              ADD      r0,r0,r2
;;;1205     *tmpreg_CH_CNTRL2x = tmpreg_CH_CNTRL2;
000014  6020              STR      r0,[r4,#0]
;;;1206   }
000016  bd30              POP      {r4,r5,pc}
;;;1207   
                          ENDP


                          AREA ||i.TIMER_ChnCapturePrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCapturePrescalerConfig PROC
;;;1038     */
;;;1039   void TIMER_ChnCapturePrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Prescaler)
000000  b530              PUSH     {r4,r5,lr}
;;;1040   {
000002  4603              MOV      r3,r0
;;;1041     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1042     uint32_t tmpreg_CH_CNTRL;
;;;1043   
;;;1044     /* Check the parameters */
;;;1045     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1046     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1047     assert_param(IS_TIMER_CHANNEL_PRESCALER(Prescaler));
;;;1048   
;;;1049     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1050   
;;;1051     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1052     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHPSC_Msk;
00000e  f02000c0          BIC      r0,r0,#0xc0
;;;1053     tmpreg_CH_CNTRL += Prescaler << TIMER_CH_CNTRL_CHPSC_Pos;
000012  eb001082          ADD      r0,r0,r2,LSL #6
;;;1054     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000016  6020              STR      r0,[r4,#0]
;;;1055   }
000018  bd30              POP      {r4,r5,pc}
;;;1056   
                          ENDP


                          AREA ||i.TIMER_ChnCompare1Config||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCompare1Config PROC
;;;797    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;798    void TIMER_ChnCompare1Config(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;799    #endif
;;;800    {
000002  4614              MOV      r4,r2
;;;801      __IO uint32_t *tmpreg_CNTRL2x;
;;;802      __IO uint32_t *tmpreg_CCR1x;
;;;803      uint32_t tmpreg_CNTRL2;
;;;804    
;;;805      /* Check the parameters */
;;;806      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;807      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;808      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;809    
;;;810      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1000760          ADD      r7,r0,#0x60
000008  eb070581          ADD      r5,r7,r1,LSL #2
;;;811    
;;;812      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
00000c  682a              LDR      r2,[r5,#0]
;;;813      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
00000e  f0220208          BIC      r2,r2,#8
;;;814      tmpreg_CNTRL2 += UpdateMode;
000012  441a              ADD      r2,r2,r3
;;;815      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
000014  602a              STR      r2,[r5,#0]
;;;816    
;;;817      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000016  3710              ADDS     r7,r7,#0x10
000018  eb070681          ADD      r6,r7,r1,LSL #2
;;;818    
;;;819      *tmpreg_CCR1x = Compare;
00001c  6034              STR      r4,[r6,#0]
;;;820    }
00001e  bdf0              POP      {r4-r7,pc}
;;;821    
                          ENDP


                          AREA ||i.TIMER_ChnCompareConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnCompareConfig PROC
;;;754    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;755    void TIMER_ChnCompareConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare, uint32_t UpdateMode)
000000  b5f0              PUSH     {r4-r7,lr}
;;;756    #endif
;;;757    {
000002  4614              MOV      r4,r2
;;;758      __IO uint32_t *tmpreg_CNTRL2x;
;;;759      __IO uint32_t *tmpreg_CCRx;
;;;760      uint32_t tmpreg_CNTRL2;
;;;761    
;;;762      /* Check the parameters */
;;;763      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;764      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;765      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;766    
;;;767      tmpreg_CNTRL2x = &TIMERx->CH1_CNTRL2 + Channel;
000004  f1000760          ADD      r7,r0,#0x60
000008  eb070581          ADD      r5,r7,r1,LSL #2
;;;768    
;;;769      tmpreg_CNTRL2 = *tmpreg_CNTRL2x;
00000c  682a              LDR      r2,[r5,#0]
;;;770      tmpreg_CNTRL2 &= ~TIMER_CH_CNTRL2_CCRRLD;
00000e  f0220208          BIC      r2,r2,#8
;;;771      tmpreg_CNTRL2 += UpdateMode;
000012  441a              ADD      r2,r2,r3
;;;772      *tmpreg_CNTRL2x = tmpreg_CNTRL2;
000014  602a              STR      r2,[r5,#0]
;;;773    
;;;774      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000016  3f50              SUBS     r7,r7,#0x50
000018  eb070681          ADD      r6,r7,r1,LSL #2
;;;775    
;;;776      *tmpreg_CCRx = Compare;
00001c  6034              STR      r4,[r6,#0]
;;;777    }
00001e  bdf0              POP      {r4-r7,pc}
;;;778    
                          ENDP


                          AREA ||i.TIMER_ChnETRResetConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnETRResetConfig PROC
;;;939      */
;;;940    void TIMER_ChnETRResetConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;941    {
000002  4603              MOV      r3,r0
;;;942      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;943      uint32_t tmpreg_CH_CNTRL;
;;;944    
;;;945      /* Check the parameters */
;;;946      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;947      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;948      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(NewState));
;;;949    
;;;950      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;951    
;;;952      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;953      tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_ETREN;
00000e  f4205000          BIC      r0,r0,#0x2000
;;;954      tmpreg_CH_CNTRL += NewState;
000012  4410              ADD      r0,r0,r2
;;;955      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;956    }
000016  bd30              POP      {r4,r5,pc}
;;;957    
                          ENDP


                          AREA ||i.TIMER_ChnETR_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_ChnETR_Cmd PROC
;;;894      */
;;;895    void TIMER_ChnETR_Cmd(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;896    {
000002  4603              MOV      r3,r0
;;;897      __IO uint32_t *tmpreg_CH_CNTRLx;
;;;898      uint32_t tmpreg_CH_CNTRL;
;;;899    
;;;900      /* Check the parameters */
;;;901      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;902      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;903      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;904    
;;;905      tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;906    
;;;907      tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;908    
;;;909      /* Form new value */
;;;910      if (NewState != DISABLE)
00000e  b112              CBZ      r2,|L10.22|
;;;911      {
;;;912        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;913        tmpreg_CH_CNTRL |= TIMER_CH_CNTRL_OCCE;
000010  f4407080          ORR      r0,r0,#0x100
000014  e001              B        |L10.26|
                  |L10.22|
;;;914      }
;;;915      else
;;;916      {
;;;917        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;918        tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCE;
000016  f4207080          BIC      r0,r0,#0x100
                  |L10.26|
;;;919      }
;;;920    
;;;921      /* Configure CNTRL register with new value */
;;;922      *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
00001a  6020              STR      r0,[r4,#0]
;;;923    }
00001c  bd30              POP      {r4,r5,pc}
;;;924    
                          ENDP


                          AREA ||i.TIMER_ChnEventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnEventSourceConfig PROC
;;;1073     */
;;;1074   void TIMER_ChnEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t EventSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1075   {
000002  4603              MOV      r3,r0
;;;1076     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1077     uint32_t tmpreg_CH_CNTRL;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1081     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1082     assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(EventSource));
;;;1083   
;;;1084     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1085   
;;;1086     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1087     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHSEL_Msk;
00000e  f0200030          BIC      r0,r0,#0x30
;;;1088     tmpreg_CH_CNTRL += EventSource;
000012  4410              ADD      r0,r0,r2
;;;1089     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1090   }
000016  bd30              POP      {r4,r5,pc}
;;;1091   
                          ENDP


                          AREA ||i.TIMER_ChnFilterConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnFilterConfig PROC
;;;1120     */
;;;1121   void TIMER_ChnFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Filter)
000000  b530              PUSH     {r4,r5,lr}
;;;1122   {
000002  4603              MOV      r3,r0
;;;1123     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1124     uint32_t tmpreg_CH_CNTRL;
;;;1125   
;;;1126     /* Check the parameters */
;;;1127     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1128     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1129     assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;1130   
;;;1131     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1132   
;;;1133     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1134     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_CHFLTR_Msk;
00000e  f020000f          BIC      r0,r0,#0xf
;;;1135     tmpreg_CH_CNTRL += Filter << TIMER_CH_CNTRL_CHFLTR_Pos;
000012  4410              ADD      r0,r0,r2
;;;1136     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1137   }
000016  bd30              POP      {r4,r5,pc}
;;;1138   
                          ENDP


                          AREA ||i.TIMER_ChnInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnInit PROC
;;;608      */
;;;609    void TIMER_ChnInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
;;;611      uint32_t tmpreg_CH_Number;
;;;612      uint32_t tmpreg_CH_CNTRL;
;;;613      uint32_t tmpreg_CH_CNTRL2;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;617      assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnInitStruct->TIMER_CH_Number));
;;;618      assert_param(IS_TIMER_CHANNEL_MODE(TIMER_ChnInitStruct->TIMER_CH_Mode));
;;;619      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_ETR_Ena));
;;;620      assert_param(IS_TIMER_CHANNEL_ETR_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_ETR_Reset));
;;;621      assert_param(IS_TIMER_CHANNEL_BRK_RESET_CONFIG(TIMER_ChnInitStruct->TIMER_CH_BRK_Reset));
;;;622      assert_param(IS_TIMER_CHANNEL_REF_FORMAT(TIMER_ChnInitStruct->TIMER_CH_REF_Format));
;;;623      assert_param(IS_TIMER_CHANNEL_PRESCALER(TIMER_ChnInitStruct->TIMER_CH_Prescaler));
;;;624      assert_param(IS_TIMER_CHANNEL_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_EventSource));
;;;625      assert_param(IS_TIMER_FILTER_CONF(TIMER_ChnInitStruct->TIMER_CH_FilterConf));
;;;626      assert_param(IS_TIMER_CHANNEL_CCR_UPDATE_MODE(TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode));
;;;627      assert_param(IS_FUNCTIONAL_STATE(TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena));
;;;628      assert_param(IS_TIMER_CHANNEL_CCR1_EVENT_SOURCE(TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource));
;;;629    
;;;630      tmpreg_CH_CNTRL = TIMER_ChnInitStruct->TIMER_CH_Mode
000002  884d              LDRH     r5,[r1,#2]
000004  88ce              LDRH     r6,[r1,#6]
000006  4435              ADD      r5,r5,r6
000008  890e              LDRH     r6,[r1,#8]
00000a  4435              ADD      r5,r5,r6
00000c  894e              LDRH     r6,[r1,#0xa]
00000e  4435              ADD      r5,r5,r6
000010  898e              LDRH     r6,[r1,#0xc]
000012  eb051586          ADD      r5,r5,r6,LSL #6
000016  89ce              LDRH     r6,[r1,#0xe]
000018  4435              ADD      r5,r5,r6
00001a  8a0e              LDRH     r6,[r1,#0x10]
00001c  19ac              ADDS     r4,r5,r6
;;;631                      + TIMER_ChnInitStruct->TIMER_CH_ETR_Reset
;;;632                      + TIMER_ChnInitStruct->TIMER_CH_BRK_Reset
;;;633                      + TIMER_ChnInitStruct->TIMER_CH_REF_Format
;;;634                      + (TIMER_ChnInitStruct->TIMER_CH_Prescaler << TIMER_CH_CNTRL_CHPSC_Pos)
;;;635                      + TIMER_ChnInitStruct->TIMER_CH_EventSource
;;;636                      + (TIMER_ChnInitStruct->TIMER_CH_FilterConf << TIMER_CH_CNTRL_CHFLTR_Pos);
;;;637    
;;;638      if (TIMER_ChnInitStruct->TIMER_CH_ETR_Ena != DISABLE)
00001e  888d              LDRH     r5,[r1,#4]
000020  b10d              CBZ      r5,|L13.38|
;;;639      {
;;;640        tmpreg_CH_CNTRL += TIMER_CH_CNTRL_ETREN;
000022  f5045400          ADD      r4,r4,#0x2000
                  |L13.38|
;;;641      }
;;;642    
;;;643      tmpreg_CH_Number = TIMER_ChnInitStruct->TIMER_CH_Number;
000026  880a              LDRH     r2,[r1,#0]
;;;644    
;;;645      *(&TIMERx->CH1_CNTRL + tmpreg_CH_Number) = tmpreg_CH_CNTRL;
000028  f1000520          ADD      r5,r0,#0x20
00002c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;646    
;;;647      tmpreg_CH_CNTRL2 = TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode
000030  8a4d              LDRH     r5,[r1,#0x12]
000032  8ace              LDRH     r6,[r1,#0x16]
000034  19ab              ADDS     r3,r5,r6
;;;648                       + TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource;
;;;649    
;;;650      if (TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena != DISABLE)
000036  8a8d              LDRH     r5,[r1,#0x14]
000038  b105              CBZ      r5,|L13.60|
;;;651      {
;;;652        tmpreg_CH_CNTRL2 += TIMER_CH_CNTRL2_CCR1_EN;
00003a  1d1b              ADDS     r3,r3,#4
                  |L13.60|
;;;653      }
;;;654    
;;;655      *(&TIMERx->CH1_CNTRL2 + tmpreg_CH_Number) = tmpreg_CH_CNTRL2;
00003c  f1000560          ADD      r5,r0,#0x60
000040  f8453022          STR      r3,[r5,r2,LSL #2]
;;;656    }
000044  bd70              POP      {r4-r6,pc}
;;;657    
                          ENDP


                          AREA ||i.TIMER_ChnNOutConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutConfig PROC
;;;1494     */
;;;1495   void TIMER_ChnNOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1496   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1497     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1498     uint32_t tmpreg_CH_CNTRL1;
;;;1499   
;;;1500     /* Check the parameters */
;;;1501     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1502     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1503     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1504     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1505     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1506   
;;;1507     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000006  f1040730          ADD      r7,r4,#0x30
00000a  eb070581          ADD      r5,r7,r1,LSL #2
;;;1508   
;;;1509     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000e  6828              LDR      r0,[r5,#0]
;;;1510     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_NINV + TIMER_CH_CNTRL1_NSELO_Msk + TIMER_CH_CNTRL1_NSELOE_Msk);
000010  f42050f8          BIC      r0,r0,#0x1f00
;;;1511     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_NINV_Pos)
000014  0337              LSLS     r7,r6,#12
000016  eb072782          ADD      r7,r7,r2,LSL #10
00001a  eb072703          ADD      r7,r7,r3,LSL #8
00001e  4438              ADD      r0,r0,r7
;;;1512                       + (OutSource << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1513                       + (Mode      << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1514     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000020  6028              STR      r0,[r5,#0]
;;;1515   }
000022  bdf0              POP      {r4-r7,pc}
;;;1516   
                          ENDP


                          AREA ||i.TIMER_ChnNOutModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutModeConfig PROC
;;;1568     */
;;;1569   void TIMER_ChnNOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000000  b530              PUSH     {r4,r5,lr}
;;;1570   {
000002  4603              MOV      r3,r0
;;;1571     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1572     uint32_t tmpreg_CH_CNTRL1;
;;;1573   
;;;1574     /* Check the parameters */
;;;1575     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1576     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1577     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1578   
;;;1579     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1580   
;;;1581     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1582     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELOE_Msk;
00000e  f4207040          BIC      r0,r0,#0x300
;;;1583     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_NSELOE_Pos;
000012  eb002002          ADD      r0,r0,r2,LSL #8
;;;1584     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1585   }
000018  bd30              POP      {r4,r5,pc}
;;;1586   
                          ENDP


                          AREA ||i.TIMER_ChnNOutPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutPolarityConfig PROC
;;;1601     */
;;;1602   void TIMER_ChnNOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000000  b530              PUSH     {r4,r5,lr}
;;;1603   {
000002  4603              MOV      r3,r0
;;;1604     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1605     uint32_t tmpreg_CH_CNTRL1;
;;;1606   
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1609     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1610     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1611   
;;;1612     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1613   
;;;1614     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1615     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NINV;
00000e  f4205080          BIC      r0,r0,#0x1000
;;;1616     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_NINV_Pos;
000012  eb003002          ADD      r0,r0,r2,LSL #12
;;;1617     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1618   }
000018  bd30              POP      {r4,r5,pc}
;;;1619   
                          ENDP


                          AREA ||i.TIMER_ChnNOutSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnNOutSourceConfig PROC
;;;1533     */
;;;1534   void TIMER_ChnNOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1535   {
000002  4603              MOV      r3,r0
;;;1536     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1537     uint32_t tmpreg_CH_CNTRL1;
;;;1538   
;;;1539     /* Check the parameters */
;;;1540     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1541     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1542     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1543   
;;;1544     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1545   
;;;1546     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1547     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_NSELO_Msk;
00000e  f4206040          BIC      r0,r0,#0xc00
;;;1548     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_NSELO_Pos;
000012  eb002082          ADD      r0,r0,r2,LSL #10
;;;1549     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1550   }
000018  bd30              POP      {r4,r5,pc}
;;;1551   
                          ENDP


                          AREA ||i.TIMER_ChnOutConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutConfig PROC
;;;1342     */
;;;1343   void TIMER_ChnOutConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource, uint32_t Mode, uint32_t Polarity)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1344   {
000002  4604              MOV      r4,r0
000004  9e05              LDR      r6,[sp,#0x14]
;;;1345     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1346     uint32_t tmpreg_CH_CNTRL1;
;;;1347   
;;;1348     /* Check the parameters */
;;;1349     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1350     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1351     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1352     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1353     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1354   
;;;1355     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000006  f1040730          ADD      r7,r4,#0x30
00000a  eb070581          ADD      r5,r7,r1,LSL #2
;;;1356   
;;;1357     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000e  6828              LDR      r0,[r5,#0]
;;;1358     tmpreg_CH_CNTRL1 &= ~(TIMER_CH_CNTRL1_INV + TIMER_CH_CNTRL1_SELO_Msk + TIMER_CH_CNTRL1_SELOE_Msk);
000010  f020001f          BIC      r0,r0,#0x1f
;;;1359     tmpreg_CH_CNTRL1 += (Polarity  << TIMER_CH_CNTRL1_INV_Pos)
000014  0137              LSLS     r7,r6,#4
000016  eb070782          ADD      r7,r7,r2,LSL #2
00001a  441f              ADD      r7,r7,r3
00001c  4438              ADD      r0,r0,r7
;;;1360                       + (OutSource << TIMER_CH_CNTRL1_SELO_Pos)
;;;1361                       + (Mode      << TIMER_CH_CNTRL1_SELOE_Pos);
;;;1362     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
00001e  6028              STR      r0,[r5,#0]
;;;1363   }
000020  bdf0              POP      {r4-r7,pc}
;;;1364   
                          ENDP


                          AREA ||i.TIMER_ChnOutDTGConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutDTGConfig PROC
;;;1638     */
;;;1639   void TIMER_ChnOutDTGConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel,
000000  b570              PUSH     {r4-r6,lr}
;;;1640                            uint32_t MainPrescaler, uint32_t AuxPrescaler, uint32_t ClockSource)
;;;1641   {
000002  9c04              LDR      r4,[sp,#0x10]
;;;1642     uint32_t tmpreg_CH_DTG;
;;;1643   
;;;1644     /* Check the parameters */
;;;1645     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1646     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1647     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(MainPrescaler));
;;;1648     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(AuxPrescaler));
;;;1649     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(ClockSource));
;;;1650   
;;;1651     tmpreg_CH_DTG = (MainPrescaler << TIMER_CH_DTG_Pos)
000004  eb032602          ADD      r6,r3,r2,LSL #8
000008  1935              ADDS     r5,r6,r4
;;;1652                   + (AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1653                   + ClockSource;
;;;1654   
;;;1655     *(&TIMERx->CH1_DTG + Channel) = tmpreg_CH_DTG;
00000a  f1000640          ADD      r6,r0,#0x40
00000e  f8465021          STR      r5,[r6,r1,LSL #2]
;;;1656   }
000012  bd70              POP      {r4-r6,pc}
;;;1657   
                          ENDP


                          AREA ||i.TIMER_ChnOutInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutInit PROC
;;;1259     */
;;;1260   void TIMER_ChnOutInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1261   {
;;;1262     uint32_t tmpreg_CH_Number;
;;;1263     uint32_t tmpreg_CH_CNTRL1;
;;;1264     uint32_t tmpreg_CH_DTG;
;;;1265   
;;;1266     /* Check the parameters */
;;;1267     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1268     assert_param(IS_TIMER_CHANNEL_NUMBER(TIMER_ChnOutInitStruct->TIMER_CH_Number));
;;;1269     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity));
;;;1270     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source));
;;;1271     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode));
;;;1272     assert_param(IS_TIMER_CHO_POLARITY(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity));
;;;1273     assert_param(IS_TIMER_CHO_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source));
;;;1274     assert_param(IS_TIMER_CHO_MODE(TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode));
;;;1275     assert_param(IS_TIMER_CHANNEL_DTG_MAIN_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler));
;;;1276     assert_param(IS_TIMER_CHANNEL_DTG_AUX_PRESCALER(TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler));
;;;1277     assert_param(IS_TIMER_CHANNEL_DTG_CLK_SOURCE(TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource));
;;;1278   
;;;1279     tmpreg_CH_CNTRL1 = (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity << TIMER_CH_CNTRL1_INV_Pos)
000002  884d              LDRH     r5,[r1,#2]
000004  012d              LSLS     r5,r5,#4
000006  888e              LDRH     r6,[r1,#4]
000008  eb050586          ADD      r5,r5,r6,LSL #2
00000c  88ce              LDRH     r6,[r1,#6]
00000e  4435              ADD      r5,r5,r6
000010  890e              LDRH     r6,[r1,#8]
000012  eb053506          ADD      r5,r5,r6,LSL #12
000016  894e              LDRH     r6,[r1,#0xa]
000018  eb052586          ADD      r5,r5,r6,LSL #10
00001c  898e              LDRH     r6,[r1,#0xc]
00001e  eb052306          ADD      r3,r5,r6,LSL #8
;;;1280                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source   << TIMER_CH_CNTRL1_SELO_Pos)
;;;1281                      + (TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode     << TIMER_CH_CNTRL1_SELOE_Pos)
;;;1282                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity << TIMER_CH_CNTRL1_NINV_Pos)
;;;1283                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source   << TIMER_CH_CNTRL1_NSELO_Pos)
;;;1284                      + (TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode     << TIMER_CH_CNTRL1_NSELOE_Pos);
;;;1285   
;;;1286     tmpreg_CH_Number = TIMER_ChnOutInitStruct->TIMER_CH_Number;
000022  880a              LDRH     r2,[r1,#0]
;;;1287   
;;;1288     *(&TIMERx->CH1_CNTRL1 + tmpreg_CH_Number) = tmpreg_CH_CNTRL1;
000024  f1000530          ADD      r5,r0,#0x30
000028  f8453022          STR      r3,[r5,r2,LSL #2]
;;;1289   
;;;1290     tmpreg_CH_DTG = (TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler << TIMER_CH_DTG_Pos)
00002c  8a0d              LDRH     r5,[r1,#0x10]
00002e  89ce              LDRH     r6,[r1,#0xe]
000030  eb052506          ADD      r5,r5,r6,LSL #8
000034  8a4e              LDRH     r6,[r1,#0x12]
000036  19ac              ADDS     r4,r5,r6
;;;1291                   + (TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  << TIMER_CH_DTGX_Pos)
;;;1292                   + TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource;
;;;1293   
;;;1294     *(&TIMERx->CH1_DTG + tmpreg_CH_Number) = tmpreg_CH_DTG;
000038  f1000540          ADD      r5,r0,#0x40
00003c  f8454022          STR      r4,[r5,r2,LSL #2]
;;;1295   }
000040  bd70              POP      {r4-r6,pc}
;;;1296   
                          ENDP


                          AREA ||i.TIMER_ChnOutModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutModeConfig PROC
;;;1416     */
;;;1417   void TIMER_ChnOutModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Mode)
000000  b530              PUSH     {r4,r5,lr}
;;;1418   {
000002  4603              MOV      r3,r0
;;;1419     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1420     uint32_t tmpreg_CH_CNTRL1;
;;;1421   
;;;1422     /* Check the parameters */
;;;1423     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1424     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1425     assert_param(IS_TIMER_CHO_MODE(Mode));
;;;1426   
;;;1427     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1428   
;;;1429     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1430     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELOE_Msk;
00000e  f0200003          BIC      r0,r0,#3
;;;1431     tmpreg_CH_CNTRL1 += Mode << TIMER_CH_CNTRL1_SELOE_Pos;
000012  4410              ADD      r0,r0,r2
;;;1432     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000014  6020              STR      r0,[r4,#0]
;;;1433   }
000016  bd30              POP      {r4,r5,pc}
;;;1434   
                          ENDP


                          AREA ||i.TIMER_ChnOutPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutPolarityConfig PROC
;;;1449     */
;;;1450   void TIMER_ChnOutPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Polarity)
000000  b530              PUSH     {r4,r5,lr}
;;;1451   {
000002  4603              MOV      r3,r0
;;;1452     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1453     uint32_t tmpreg_CH_CNTRL1;
;;;1454   
;;;1455     /* Check the parameters */
;;;1456     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1457     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1458     assert_param(IS_TIMER_CHO_POLARITY(Polarity));
;;;1459   
;;;1460     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1461   
;;;1462     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1463     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_INV;
00000e  f0200010          BIC      r0,r0,#0x10
;;;1464     tmpreg_CH_CNTRL1 += Polarity << TIMER_CH_CNTRL1_INV_Pos;
000012  eb001002          ADD      r0,r0,r2,LSL #4
;;;1465     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1466   }
000018  bd30              POP      {r4,r5,pc}
;;;1467   
                          ENDP


                          AREA ||i.TIMER_ChnOutSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutSourceConfig PROC
;;;1381     */
;;;1382   void TIMER_ChnOutSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t OutSource)
000000  b530              PUSH     {r4,r5,lr}
;;;1383   {
000002  4603              MOV      r3,r0
;;;1384     __IO uint32_t *tmpreg_CH_CNTRL1x;
;;;1385     uint32_t tmpreg_CH_CNTRL1;
;;;1386   
;;;1387     /* Check the parameters */
;;;1388     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1389     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1390     assert_param(IS_TIMER_CHO_SOURCE(OutSource));
;;;1391   
;;;1392     tmpreg_CH_CNTRL1x = &TIMERx->CH1_CNTRL1 + Channel;
000004  f1030530          ADD      r5,r3,#0x30
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1393   
;;;1394     tmpreg_CH_CNTRL1 = *tmpreg_CH_CNTRL1x;
00000c  6820              LDR      r0,[r4,#0]
;;;1395     tmpreg_CH_CNTRL1 &= ~TIMER_CH_CNTRL1_SELO_Msk;
00000e  f020000c          BIC      r0,r0,#0xc
;;;1396     tmpreg_CH_CNTRL1 += OutSource << TIMER_CH_CNTRL1_SELO_Pos;
000012  eb000082          ADD      r0,r0,r2,LSL #2
;;;1397     *tmpreg_CH_CNTRL1x = tmpreg_CH_CNTRL1;
000016  6020              STR      r0,[r4,#0]
;;;1398   }
000018  bd30              POP      {r4,r5,pc}
;;;1399   
                          ENDP


                          AREA ||i.TIMER_ChnOutStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnOutStructInit PROC
;;;1302     */
;;;1303   void TIMER_ChnOutStructInit(TIMER_ChnOutInitTypeDef* TIMER_ChnOutInitStruct)
000000  2100              MOVS     r1,#0
;;;1304   {
;;;1305     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Polarity   = TIMER_CHOPolarity_NonInverted;
000002  8041              STRH     r1,[r0,#2]
;;;1306     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Source     = TIMER_CH_OutSrc_Only_0;
000004  8081              STRH     r1,[r0,#4]
;;;1307     TIMER_ChnOutInitStruct->TIMER_CH_DirOut_Mode       = TIMER_CH_OutMode_Input;
000006  80c1              STRH     r1,[r0,#6]
;;;1308     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Polarity   = TIMER_CHOPolarity_NonInverted;
000008  8101              STRH     r1,[r0,#8]
;;;1309     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Source     = TIMER_CH_OutSrc_Only_0;
00000a  8141              STRH     r1,[r0,#0xa]
;;;1310     TIMER_ChnOutInitStruct->TIMER_CH_NegOut_Mode       = TIMER_CH_OutMode_Input;
00000c  8181              STRH     r1,[r0,#0xc]
;;;1311     TIMER_ChnOutInitStruct->TIMER_CH_DTG_MainPrescaler = 0;
00000e  81c1              STRH     r1,[r0,#0xe]
;;;1312     TIMER_ChnOutInitStruct->TIMER_CH_DTG_AuxPrescaler  = 0;
000010  8201              STRH     r1,[r0,#0x10]
;;;1313     TIMER_ChnOutInitStruct->TIMER_CH_DTG_ClockSource   = TIMER_CH_DTG_ClkSrc_TIMER_CLK;
000012  8241              STRH     r1,[r0,#0x12]
;;;1314   }
000014  4770              BX       lr
;;;1315   
                          ENDP


                          AREA ||i.TIMER_ChnREFFormatConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ChnREFFormatConfig PROC
;;;1003     */
;;;1004   void TIMER_ChnREFFormatConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint32_t Format)
000000  b530              PUSH     {r4,r5,lr}
;;;1005   {
000002  4603              MOV      r3,r0
;;;1006     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1007     uint32_t tmpreg_CH_CNTRL;
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1011     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1012     assert_param(IS_TIMER_CHANNEL_REF_FORMAT(Format));
;;;1013   
;;;1014     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1030520          ADD      r5,r3,#0x20
000008  eb050481          ADD      r4,r5,r1,LSL #2
;;;1015   
;;;1016     tmpreg_CH_CNTRL = *tmpreg_CH_CNTRLx;
00000c  6820              LDR      r0,[r4,#0]
;;;1017     tmpreg_CH_CNTRL &= ~TIMER_CH_CNTRL_OCCM_Msk;
00000e  f4206060          BIC      r0,r0,#0xe00
;;;1018     tmpreg_CH_CNTRL += Format;
000012  4410              ADD      r0,r0,r2
;;;1019     *tmpreg_CH_CNTRLx = tmpreg_CH_CNTRL;
000014  6020              STR      r0,[r4,#0]
;;;1020   }
000016  bd30              POP      {r4,r5,pc}
;;;1021   
                          ENDP


                          AREA ||i.TIMER_ChnStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_ChnStructInit PROC
;;;663      */
;;;664    void TIMER_ChnStructInit(TIMER_ChnInitTypeDef* TIMER_ChnInitStruct)
000000  2100              MOVS     r1,#0
;;;665    {
;;;666      TIMER_ChnInitStruct->TIMER_CH_Number           = TIMER_CHANNEL1;
000002  8001              STRH     r1,[r0,#0]
;;;667      TIMER_ChnInitStruct->TIMER_CH_Mode             = TIMER_CH_MODE_PWM;
000004  8041              STRH     r1,[r0,#2]
;;;668      TIMER_ChnInitStruct->TIMER_CH_ETR_Ena          = DISABLE;
000006  8081              STRH     r1,[r0,#4]
;;;669      TIMER_ChnInitStruct->TIMER_CH_ETR_Reset        = TIMER_CH_ETR_RESET_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;670      TIMER_ChnInitStruct->TIMER_CH_BRK_Reset        = TIMER_CH_BRK_RESET_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;671      TIMER_ChnInitStruct->TIMER_CH_REF_Format       = TIMER_CH_REF_Format0;
00000c  8141              STRH     r1,[r0,#0xa]
;;;672      TIMER_ChnInitStruct->TIMER_CH_Prescaler        = TIMER_CH_Prescaler_None;
00000e  8181              STRH     r1,[r0,#0xc]
;;;673      TIMER_ChnInitStruct->TIMER_CH_EventSource      = TIMER_CH_EvSrc_PE;
000010  81c1              STRH     r1,[r0,#0xe]
;;;674      TIMER_ChnInitStruct->TIMER_CH_FilterConf       = TIMER_Filter_1FF_at_TIMER_CLK;
000012  8201              STRH     r1,[r0,#0x10]
;;;675      TIMER_ChnInitStruct->TIMER_CH_CCR_UpdateMode   = TIMER_CH_CCR_Update_Immediately;
000014  8241              STRH     r1,[r0,#0x12]
;;;676      TIMER_ChnInitStruct->TIMER_CH_CCR1_Ena         = DISABLE;
000016  8281              STRH     r1,[r0,#0x14]
;;;677      TIMER_ChnInitStruct->TIMER_CH_CCR1_EventSource = TIMER_CH_CCR1EvSrc_PE;
000018  82c1              STRH     r1,[r0,#0x16]
;;;678    }
00001a  4770              BX       lr
;;;679    
                          ENDP


                          AREA ||i.TIMER_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIMER_ClearFlag PROC
;;;1738     */
;;;1739   void TIMER_ClearFlag(MDR_TIMER_TypeDef* TIMERx, uint32_t Flags)
000000  6d42              LDR      r2,[r0,#0x54]
;;;1740   {
;;;1741     /* Check the parameters */
;;;1742     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1743     assert_param(IS_TIMER_STATUS(Flags));
;;;1744   
;;;1745     TIMERx->STATUS &= ~Flags;
000002  438a              BICS     r2,r2,r1
000004  6542              STR      r2,[r0,#0x54]
;;;1746   }
000006  4770              BX       lr
;;;1747   
                          ENDP


                          AREA ||i.TIMER_Cmd||, CODE, READONLY, ALIGN=1

                  TIMER_Cmd PROC
;;;168      */
;;;169    void TIMER_Cmd(MDR_TIMER_TypeDef* TIMERx, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;170    {
;;;171      uint32_t tmpreg_CNTRL;
;;;172    
;;;173      /* Check the parameters */
;;;174      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;175      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;176    
;;;177      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;178    
;;;179      /* Form new value */
;;;180      if (NewState != DISABLE)
000004  b112              CBZ      r2,|L28.12|
;;;181      {
;;;182        /* Enable TIMERx by setting the CNT_EN bit in the CNTRL register */
;;;183        tmpreg_CNTRL |= TIMER_CNTRL_CNT_EN;
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L28.16|
                  |L28.12|
;;;184      }
;;;185      else
;;;186      {
;;;187        /* Disable TIMERx by resetting the CNT_EN bit in the CNTRL register */
;;;188        tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_EN;
00000c  f0210101          BIC      r1,r1,#1
                  |L28.16|
;;;189      }
;;;190    
;;;191      /* Configure CNTRL register with new value */
;;;192      TIMERx->CNTRL = tmpreg_CNTRL;
000010  60c1              STR      r1,[r0,#0xc]
;;;193    }
000012  4770              BX       lr
;;;194    
                          ENDP


                          AREA ||i.TIMER_CntAutoreloadConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CntAutoreloadConfig PROC
;;;257    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;258    void TIMER_CntAutoreloadConfig(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload, uint32_t UpdateMode)
000000  b510              PUSH     {r4,lr}
;;;259    #endif
;;;260    {
000002  460b              MOV      r3,r1
;;;261      uint32_t tmpreg_CNTRL;
;;;262    
;;;263      /* Check the parameters */
;;;264      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;265      assert_param(IS_TIMER_ARR_UPDATE_MODE(UpdateMode));
;;;266    
;;;267      tmpreg_CNTRL = TIMERx->CNTRL;
000004  68c1              LDR      r1,[r0,#0xc]
;;;268      tmpreg_CNTRL &= ~TIMER_CNTRL_ARRB_EN;
000006  f0210102          BIC      r1,r1,#2
;;;269      tmpreg_CNTRL += UpdateMode;
00000a  4411              ADD      r1,r1,r2
;;;270      TIMERx->CNTRL = tmpreg_CNTRL;
00000c  60c1              STR      r1,[r0,#0xc]
;;;271    
;;;272      TIMERx->ARR = Autoreload;
00000e  6083              STR      r3,[r0,#8]
;;;273    }
000010  bd10              POP      {r4,pc}
;;;274    
                          ENDP


                          AREA ||i.TIMER_CntEventSourceConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CntEventSourceConfig PROC
;;;307      */
;;;308    void TIMER_CntEventSourceConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t EventSource)
000000  460a              MOV      r2,r1
;;;309    {
;;;310      uint32_t tmpreg_CNTRL;
;;;311    
;;;312      /* Check the parameters */
;;;313      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;314      assert_param(IS_TIMER_EVENT_SOURCE(EventSource));
;;;315    
;;;316      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;317      tmpreg_CNTRL &= ~TIMER_CNTRL_EVENT_SEL_Msk;
000004  f4216170          BIC      r1,r1,#0xf00
;;;318      tmpreg_CNTRL += EventSource;
000008  4411              ADD      r1,r1,r2
;;;319      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;320    }
00000c  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.TIMER_CntInit||, CODE, READONLY, ALIGN=1

                  TIMER_CntInit PROC
;;;98       */
;;;99     void TIMER_CntInit(MDR_TIMER_TypeDef* TIMERx, const TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;100    {
;;;101      uint32_t tmpreg_CNTRL;
;;;102      uint32_t tmpreg_BRKETR_CNTRL;
;;;103    
;;;104      /* Check the parameters */
;;;105      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;106      assert_param(IS_TIMER_COUNTER_MODE(TIMER_CntInitStruct->TIMER_CounterMode));
;;;107      assert_param(IS_TIMER_COUNTER_DIR(TIMER_CntInitStruct->TIMER_CounterDirection));
;;;108      assert_param(IS_TIMER_EVENT_SOURCE(TIMER_CntInitStruct->TIMER_EventSource));
;;;109      assert_param(IS_TIMER_FILTER_SAMPLING(TIMER_CntInitStruct->TIMER_FilterSampling));
;;;110      assert_param(IS_TIMER_ARR_UPDATE_MODE(TIMER_CntInitStruct->TIMER_ARR_UpdateMode));
;;;111      assert_param(IS_TIMER_FILTER_CONF(TIMER_CntInitStruct->TIMER_ETR_FilterConf));
;;;112      assert_param(IS_TIMER_ETR_PRESCALER(TIMER_CntInitStruct->TIMER_ETR_Prescaler));
;;;113      assert_param(IS_TIMER_ETR_POLARITY(TIMER_CntInitStruct->TIMER_ETR_Polarity));
;;;114      assert_param(IS_TIMER_BRK_POLARITY(TIMER_CntInitStruct->TIMER_BRK_Polarity));
;;;115    
;;;116      TIMERx->CNT = TIMER_CntInitStruct->TIMER_IniCounter;
000002  880c              LDRH     r4,[r1,#0]
000004  6004              STR      r4,[r0,#0]
;;;117      TIMERx->PSG = TIMER_CntInitStruct->TIMER_Prescaler;
000006  884c              LDRH     r4,[r1,#2]
000008  6044              STR      r4,[r0,#4]
;;;118      TIMERx->ARR = TIMER_CntInitStruct->TIMER_Period;
00000a  888c              LDRH     r4,[r1,#4]
00000c  6084              STR      r4,[r0,#8]
;;;119    
;;;120      /* Form new value for the TIMERx_CNTRL register */
;;;121      tmpreg_CNTRL = TIMER_CntInitStruct->TIMER_CounterMode
00000e  88cc              LDRH     r4,[r1,#6]
000010  890d              LDRH     r5,[r1,#8]
000012  442c              ADD      r4,r4,r5
000014  894d              LDRH     r5,[r1,#0xa]
000016  442c              ADD      r4,r4,r5
000018  898d              LDRH     r5,[r1,#0xc]
00001a  442c              ADD      r4,r4,r5
00001c  89cd              LDRH     r5,[r1,#0xe]
00001e  1963              ADDS     r3,r4,r5
;;;122                   + TIMER_CntInitStruct->TIMER_CounterDirection
;;;123                   + TIMER_CntInitStruct->TIMER_EventSource
;;;124                   + TIMER_CntInitStruct->TIMER_FilterSampling
;;;125                   + TIMER_CntInitStruct->TIMER_ARR_UpdateMode;
;;;126    
;;;127      /* Configure TIMERx_CNTRL register with new value */
;;;128      TIMERx->CNTRL = tmpreg_CNTRL;
000020  60c3              STR      r3,[r0,#0xc]
;;;129    
;;;130      /* Form new value for the TIMERx_BRKETR_CNTRL register */
;;;131      tmpreg_BRKETR_CNTRL = (TIMER_CntInitStruct->TIMER_ETR_FilterConf << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos)
000022  8a4c              LDRH     r4,[r1,#0x12]
000024  8a0d              LDRH     r5,[r1,#0x10]
000026  eb041405          ADD      r4,r4,r5,LSL #4
00002a  8a8d              LDRH     r5,[r1,#0x14]
00002c  442c              ADD      r4,r4,r5
00002e  8acd              LDRH     r5,[r1,#0x16]
000030  1962              ADDS     r2,r4,r5
;;;132                          + TIMER_CntInitStruct->TIMER_ETR_Prescaler
;;;133                          + TIMER_CntInitStruct->TIMER_ETR_Polarity
;;;134                          + TIMER_CntInitStruct->TIMER_BRK_Polarity;
;;;135    
;;;136      /* Configure TIMERx_BRKETR_CNTRL register with new value */
;;;137      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000032  6502              STR      r2,[r0,#0x50]
;;;138    }
000034  bd30              POP      {r4,r5,pc}
;;;139    
                          ENDP


                          AREA ||i.TIMER_CntStructInit||, CODE, READONLY, ALIGN=1

                  TIMER_CntStructInit PROC
;;;145      */
;;;146    void TIMER_CntStructInit(TIMER_CntInitTypeDef* TIMER_CntInitStruct)
000000  2100              MOVS     r1,#0
;;;147    {
;;;148      TIMER_CntInitStruct->TIMER_IniCounter = 0;
000002  8001              STRH     r1,[r0,#0]
;;;149      TIMER_CntInitStruct->TIMER_Prescaler  = 0;
000004  8041              STRH     r1,[r0,#2]
;;;150      TIMER_CntInitStruct->TIMER_Period     = 0;
000006  8081              STRH     r1,[r0,#4]
;;;151      TIMER_CntInitStruct->TIMER_CounterMode      = TIMER_CntMode_ClkFixedDir;
000008  80c1              STRH     r1,[r0,#6]
;;;152      TIMER_CntInitStruct->TIMER_CounterDirection = TIMER_CntDir_Up;
00000a  8101              STRH     r1,[r0,#8]
;;;153      TIMER_CntInitStruct->TIMER_EventSource      = TIMER_EvSrc_None;
00000c  8141              STRH     r1,[r0,#0xa]
;;;154      TIMER_CntInitStruct->TIMER_FilterSampling   = TIMER_FDTS_TIMER_CLK_div_1;
00000e  8181              STRH     r1,[r0,#0xc]
;;;155      TIMER_CntInitStruct->TIMER_ARR_UpdateMode   = TIMER_ARR_Update_Immediately;
000010  81c1              STRH     r1,[r0,#0xe]
;;;156      TIMER_CntInitStruct->TIMER_ETR_FilterConf   = TIMER_Filter_1FF_at_TIMER_CLK;
000012  8201              STRH     r1,[r0,#0x10]
;;;157      TIMER_CntInitStruct->TIMER_ETR_Prescaler    = TIMER_ETR_Prescaler_None;
000014  8241              STRH     r1,[r0,#0x12]
;;;158      TIMER_CntInitStruct->TIMER_ETR_Polarity     = TIMER_ETRPolarity_NonInverted;
000016  8281              STRH     r1,[r0,#0x14]
;;;159      TIMER_CntInitStruct->TIMER_BRK_Polarity     = TIMER_BRKPolarity_NonInverted;
000018  82c1              STRH     r1,[r0,#0x16]
;;;160    }
00001a  4770              BX       lr
;;;161    
                          ENDP


                          AREA ||i.TIMER_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIMER_CounterModeConfig PROC
;;;357      */
;;;358    void TIMER_CounterModeConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Mode)
000000  460a              MOV      r2,r1
;;;359    {
;;;360      uint32_t tmpreg_CNTRL;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;364      assert_param(IS_TIMER_COUNTER_MODE(Mode));
;;;365    
;;;366      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;367      tmpreg_CNTRL &= ~TIMER_CNTRL_CNT_MODE_Msk;
000004  f02101c0          BIC      r1,r1,#0xc0
;;;368      tmpreg_CNTRL += Mode;
000008  4411              ADD      r1,r1,r2
;;;369      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;370    }
00000c  4770              BX       lr
;;;371    
                          ENDP


                          AREA ||i.TIMER_DMACmd||, CODE, READONLY, ALIGN=1

                  TIMER_DMACmd PROC
;;;1785   #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1786   void TIMER_DMACmd(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_DMASource, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1787   #endif
;;;1788   {
000002  4613              MOV      r3,r2
;;;1789     uint32_t tmpreg_DMA_RE;
;;;1790   
;;;1791     /* Check the parameters */
;;;1792     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1793     assert_param(IS_TIMER_STATUS(TIMER_DMASource));
;;;1794     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1795   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1796     if(TIMER_DMAChannel == TIMER_DMA_Channel0){
;;;1797   #endif
;;;1798   	  tmpreg_DMA_RE = TIMERx->DMA_RE;
000004  6dc2              LDR      r2,[r0,#0x5c]
;;;1799   
;;;1800   	  /* Form new value */
;;;1801   	  if (NewState != DISABLE)
000006  b10b              CBZ      r3,|L34.12|
;;;1802   	  {
;;;1803   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1804   		tmpreg_DMA_RE |= TIMER_DMASource;
000008  430a              ORRS     r2,r2,r1
00000a  e000              B        |L34.14|
                  |L34.12|
;;;1805   	  }
;;;1806   	  else
;;;1807   	  {
;;;1808   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1809   		tmpreg_DMA_RE &= ~TIMER_DMASource;
00000c  438a              BICS     r2,r2,r1
                  |L34.14|
;;;1810   	  }
;;;1811   
;;;1812   	  /* Configure CNTRL register with new value */
;;;1813   	  TIMERx->DMA_RE = tmpreg_DMA_RE;
00000e  65c2              STR      r2,[r0,#0x5c]
;;;1814   #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;1815     }
;;;1816     else{
;;;1817   	  tmpreg_DMA_RE = TIMERx->DMA_REChx[TIMER_DMAChannel];
;;;1818   
;;;1819   	  /* Form new value */
;;;1820   	  if (NewState != DISABLE)
;;;1821   	  {
;;;1822   		/* Enable TIMERx DMA Requests by setting bits in the DMA_RE register */
;;;1823   		tmpreg_DMA_RE |= TIMER_DMASource;
;;;1824   	  }
;;;1825   	  else
;;;1826   	  {
;;;1827   		/* Disable TIMERx DMA Requests by clearing bits in the DMA_RE register */
;;;1828   		tmpreg_DMA_RE &= ~TIMER_DMASource;
;;;1829   	  }
;;;1830   
;;;1831   	  /* Configure CNTRL register with new value */
;;;1832   	  TIMERx->DMA_REChx[TIMER_DMAChannel] = tmpreg_DMA_RE;
;;;1833   
;;;1834     }
;;;1835   #endif
;;;1836   }
000010  bd10              POP      {r4,pc}
;;;1837   
                          ENDP


                          AREA ||i.TIMER_DeInit||, CODE, READONLY, ALIGN=1

                  TIMER_DeInit PROC
;;;45       */
;;;46     void TIMER_DeInit ( MDR_TIMER_TypeDef* TIMERx ) {
000000  2100              MOVS     r1,#0
;;;47     	/* Check the parameters */
;;;48     	assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;49     
;;;50     	TIMERx->CNTRL = 0;
000002  60c1              STR      r1,[r0,#0xc]
;;;51     	TIMERx->CNT = 0;
000004  6001              STR      r1,[r0,#0]
;;;52     	TIMERx->PSG = 0;
000006  6041              STR      r1,[r0,#4]
;;;53     	TIMERx->ARR = 0;
000008  6081              STR      r1,[r0,#8]
;;;54     
;;;55     	TIMERx->CH1_CNTRL = 0;
00000a  6201              STR      r1,[r0,#0x20]
;;;56     	TIMERx->CH2_CNTRL = 0;
00000c  6241              STR      r1,[r0,#0x24]
;;;57     	TIMERx->CH3_CNTRL = 0;
00000e  6281              STR      r1,[r0,#0x28]
;;;58     	TIMERx->CH4_CNTRL = 0;
000010  62c1              STR      r1,[r0,#0x2c]
;;;59     	TIMERx->CH1_CNTRL1 = 0;
000012  6301              STR      r1,[r0,#0x30]
;;;60     	TIMERx->CH2_CNTRL1 = 0;
000014  6341              STR      r1,[r0,#0x34]
;;;61     	TIMERx->CH3_CNTRL1 = 0;
000016  6381              STR      r1,[r0,#0x38]
;;;62     	TIMERx->CH4_CNTRL1 = 0;
000018  63c1              STR      r1,[r0,#0x3c]
;;;63     	TIMERx->CH1_CNTRL2 = 0;
00001a  6601              STR      r1,[r0,#0x60]
;;;64     	TIMERx->CH2_CNTRL2 = 0;
00001c  6641              STR      r1,[r0,#0x64]
;;;65     	TIMERx->CH3_CNTRL2 = 0;
00001e  6681              STR      r1,[r0,#0x68]
;;;66     	TIMERx->CH4_CNTRL2 = 0;
000020  66c1              STR      r1,[r0,#0x6c]
;;;67     
;;;68     	TIMERx->CCR1 = 0;
000022  6101              STR      r1,[r0,#0x10]
;;;69     	TIMERx->CCR2 = 0;
000024  6141              STR      r1,[r0,#0x14]
;;;70     	TIMERx->CCR3 = 0;
000026  6181              STR      r1,[r0,#0x18]
;;;71     	TIMERx->CCR4 = 0;
000028  61c1              STR      r1,[r0,#0x1c]
;;;72     	TIMERx->CCR11 = 0;
00002a  6701              STR      r1,[r0,#0x70]
;;;73     	TIMERx->CCR21 = 0;
00002c  6741              STR      r1,[r0,#0x74]
;;;74     	TIMERx->CCR31 = 0;
00002e  6781              STR      r1,[r0,#0x78]
;;;75     	TIMERx->CCR41 = 0;
000030  67c1              STR      r1,[r0,#0x7c]
;;;76     	TIMERx->CH1_DTG = 0;
000032  6401              STR      r1,[r0,#0x40]
;;;77     	TIMERx->CH2_DTG = 0;
000034  6441              STR      r1,[r0,#0x44]
;;;78     	TIMERx->CH3_DTG = 0;
000036  6481              STR      r1,[r0,#0x48]
;;;79     	TIMERx->CH4_DTG = 0;
000038  64c1              STR      r1,[r0,#0x4c]
;;;80     	TIMERx->BRKETR_CNTRL = 0;
00003a  6501              STR      r1,[r0,#0x50]
;;;81     	TIMERx->STATUS = 0;
00003c  6541              STR      r1,[r0,#0x54]
;;;82     	TIMERx->IE = 0;
00003e  6581              STR      r1,[r0,#0x58]
;;;83     	TIMERx->DMA_RE = 0;
000040  65c1              STR      r1,[r0,#0x5c]
;;;84     #if defined(USE_MDR1986VE3) || defined (USE_MDR1986VE1T) /* For Cortex M1 */
;;;85     	TIMERx->DMA_REChx[0] = TIMERx->DMA_REChx[1] =
;;;86     			TIMERx->DMA_REChx[2] = TIMERx->DMA_REChx[3] = 0;
;;;87     #endif
;;;88     }
000042  4770              BX       lr
;;;89     
                          ENDP


                          AREA ||i.TIMER_ETRFilterConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRFilterConfig PROC
;;;466      */
;;;467    void TIMER_ETRFilterConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Filter)
000000  460a              MOV      r2,r1
;;;468    {
;;;469      uint32_t tmpreg_BRKETR_CNTRL;
;;;470    
;;;471      /* Check the parameters */
;;;472      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;473      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;474    
;;;475      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;476      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_FILTER_Msk;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;477      tmpreg_BRKETR_CNTRL += Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos;
000008  eb011102          ADD      r1,r1,r2,LSL #4
;;;478      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000c  6501              STR      r1,[r0,#0x50]
;;;479    }
00000e  4770              BX       lr
;;;480    
                          ENDP


                          AREA ||i.TIMER_ETRInputConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRInputConfig PROC
;;;427      */
;;;428    void TIMER_ETRInputConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler, uint32_t Polarity, uint32_t Filter)
000000  b530              PUSH     {r4,r5,lr}
;;;429    {
000002  460c              MOV      r4,r1
;;;430      uint32_t tmpreg_BRKETR_CNTRL;
;;;431    
;;;432      /* Check the parameters */
;;;433      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;434      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;435      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;436      assert_param(IS_TIMER_FILTER_CONF(Filter));
;;;437    
;;;438      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000004  6d01              LDR      r1,[r0,#0x50]
;;;439      tmpreg_BRKETR_CNTRL &= ~(TIMER_BRKETR_CNTRL_ETR_PSC_Msk + TIMER_BRKETR_CNTRL_ETR_INV + TIMER_BRKETR_CNTRL_ETR_FILTER_Msk);
000006  f02101fe          BIC      r1,r1,#0xfe
;;;440      tmpreg_BRKETR_CNTRL += Prescaler + Polarity + (Filter << TIMER_BRKETR_CNTRL_ETR_FILTER_Pos);
00000a  18a5              ADDS     r5,r4,r2
00000c  eb051503          ADD      r5,r5,r3,LSL #4
000010  4429              ADD      r1,r1,r5
;;;441      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
000012  6501              STR      r1,[r0,#0x50]
;;;442    }
000014  bd30              POP      {r4,r5,pc}
;;;443    
                          ENDP


                          AREA ||i.TIMER_ETRPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRPolarityConfig PROC
;;;514      */
;;;515    void TIMER_ETRPolarityConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Polarity)
000000  460a              MOV      r2,r1
;;;516    {
;;;517      uint32_t tmpreg_BRKETR_CNTRL;
;;;518    
;;;519      /* Check the parameters */
;;;520      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;521      assert_param(IS_TIMER_ETR_POLARITY(Polarity));
;;;522    
;;;523      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;524      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_INV;
000004  f0210102          BIC      r1,r1,#2
;;;525      tmpreg_BRKETR_CNTRL += Polarity;
000008  4411              ADD      r1,r1,r2
;;;526      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;527    }
00000c  4770              BX       lr
;;;528    
                          ENDP


                          AREA ||i.TIMER_ETRPrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ETRPrescalerConfig PROC
;;;491      */
;;;492    void TIMER_ETRPrescalerConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
000000  460a              MOV      r2,r1
;;;493    {
;;;494      uint32_t tmpreg_BRKETR_CNTRL;
;;;495    
;;;496      /* Check the parameters */
;;;497      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;498      assert_param(IS_TIMER_ETR_PRESCALER(Prescaler));
;;;499    
;;;500      tmpreg_BRKETR_CNTRL = TIMERx->BRKETR_CNTRL;
000002  6d01              LDR      r1,[r0,#0x50]
;;;501      tmpreg_BRKETR_CNTRL &= ~TIMER_BRKETR_CNTRL_ETR_PSC_Msk;
000004  f021010c          BIC      r1,r1,#0xc
;;;502      tmpreg_BRKETR_CNTRL += Prescaler;
000008  4411              ADD      r1,r1,r2
;;;503      TIMERx->BRKETR_CNTRL = tmpreg_BRKETR_CNTRL;
00000a  6501              STR      r1,[r0,#0x50]
;;;504    }
00000c  4770              BX       lr
;;;505    
                          ENDP


                          AREA ||i.TIMER_FilterSamplingConfig||, CODE, READONLY, ALIGN=1

                  TIMER_FilterSamplingConfig PROC
;;;332      */
;;;333    void TIMER_FilterSamplingConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t Prescaler)
000000  460a              MOV      r2,r1
;;;334    {
;;;335      uint32_t tmpreg_CNTRL;
;;;336    
;;;337      /* Check the parameters */
;;;338      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;339      assert_param(IS_TIMER_FILTER_SAMPLING(Prescaler));
;;;340    
;;;341      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;342      tmpreg_CNTRL &= ~TIMER_CNTRL_FDTS_Msk;
000004  f0210130          BIC      r1,r1,#0x30
;;;343      tmpreg_CNTRL += Prescaler;
000008  4411              ADD      r1,r1,r2
;;;344      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;345    }
00000c  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.TIMER_GetChnCapture||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnCapture PROC
;;;835    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;836    uint16_t TIMER_GetChnCapture(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;837    #endif
;;;838    {
000002  4602              MOV      r2,r0
;;;839      __IO uint32_t *tmpreg_CCRx;
;;;840      uint32_t tmpreg;
;;;841    
;;;842      /* Check the parameters */
;;;843      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;844      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;845    
;;;846      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000004  f1020010          ADD      r0,r2,#0x10
000008  eb000381          ADD      r3,r0,r1,LSL #2
;;;847      tmpreg = *tmpreg_CCRx;
00000c  681c              LDR      r4,[r3,#0]
;;;848    
;;;849      return tmpreg;
00000e  b2a0              UXTH     r0,r4
;;;850    }
000010  bd10              POP      {r4,pc}
;;;851    
                          ENDP


                          AREA ||i.TIMER_GetChnCapture1||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnCapture1 PROC
;;;865    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;866    uint16_t TIMER_GetChnCapture1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;867    #endif
;;;868    {
000002  4602              MOV      r2,r0
;;;869      __IO uint32_t *tmpreg_CCR1x;
;;;870      uint32_t tmpreg;
;;;871    
;;;872      /* Check the parameters */
;;;873      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;874      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;875    
;;;876      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000004  f1020070          ADD      r0,r2,#0x70
000008  eb000381          ADD      r3,r0,r1,LSL #2
;;;877      tmpreg = *tmpreg_CCR1x;
00000c  681c              LDR      r4,[r3,#0]
;;;878    
;;;879      return tmpreg;
00000e  b2a0              UXTH     r0,r4
;;;880    }
000010  bd10              POP      {r4,pc}
;;;881    
                          ENDP


                          AREA ||i.TIMER_GetChnWriteComplete||, CODE, READONLY, ALIGN=1

                  TIMER_GetChnWriteComplete PROC
;;;1149     */
;;;1150   FlagStatus TIMER_GetChnWriteComplete(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel)
000000  b510              PUSH     {r4,lr}
;;;1151   {
000002  4602              MOV      r2,r0
;;;1152     __IO uint32_t *tmpreg_CH_CNTRLx;
;;;1153     FlagStatus bitstatus;
;;;1154   
;;;1155     /* Check the parameters */
;;;1156     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1157     assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;1158   
;;;1159     tmpreg_CH_CNTRLx = &TIMERx->CH1_CNTRL + Channel;
000004  f1020420          ADD      r4,r2,#0x20
000008  eb040381          ADD      r3,r4,r1,LSL #2
;;;1160   
;;;1161     if ((*tmpreg_CH_CNTRLx & TIMER_CH_CNTRL_WR_CMPL) == 0)
00000c  681c              LDR      r4,[r3,#0]
00000e  f4044480          AND      r4,r4,#0x4000
000012  b90c              CBNZ     r4,|L43.24|
;;;1162     {
;;;1163       bitstatus = RESET;
000014  2000              MOVS     r0,#0
000016  e000              B        |L43.26|
                  |L43.24|
;;;1164     }
;;;1165     else
;;;1166     {
;;;1167       bitstatus = SET;
000018  2001              MOVS     r0,#1
                  |L43.26|
;;;1168     }
;;;1169   
;;;1170     return bitstatus;
;;;1171   }
00001a  bd10              POP      {r4,pc}
;;;1172   
                          ENDP


                          AREA ||i.TIMER_GetCntWriteComplete||, CODE, READONLY, ALIGN=1

                  TIMER_GetCntWriteComplete PROC
;;;580      */
;;;581    FlagStatus TIMER_GetCntWriteComplete(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;582    {
;;;583      FlagStatus bitstatus;
;;;584    
;;;585      /* Check the parameters */
;;;586      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;587    
;;;588      if ((TIMERx->CNTRL & TIMER_CNTRL_WR_CMPL) == 0)
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0020204          AND      r2,r2,#4
000008  b90a              CBNZ     r2,|L44.14|
;;;589      {
;;;590        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L44.16|
                  |L44.14|
;;;591      }
;;;592      else
;;;593      {
;;;594        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L44.16|
;;;595      }
;;;596    
;;;597      return bitstatus;
;;;598    }
000010  4770              BX       lr
;;;599    
                          ENDP


                          AREA ||i.TIMER_GetCounter||, CODE, READONLY, ALIGN=1

                  TIMER_GetCounter PROC
;;;282    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;283    uint16_t TIMER_GetCounter(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;284    #endif
;;;285    {
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;288    
;;;289      return TIMERx->CNT;
000002  6808              LDR      r0,[r1,#0]
000004  b280              UXTH     r0,r0
;;;290    }
000006  4770              BX       lr
;;;291    
                          ENDP


                          AREA ||i.TIMER_GetCounterDirection||, CODE, READONLY, ALIGN=1

                  TIMER_GetCounterDirection PROC
;;;556      */
;;;557    uint32_t TIMER_GetCounterDirection(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;558    {
;;;559      uint32_t bitstatus;
;;;560    
;;;561      /* Check the parameters */
;;;562      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;563    
;;;564      if ((TIMERx->CNTRL & TIMER_CNTRL_DIR) == 0)
000002  68ca              LDR      r2,[r1,#0xc]
000004  f0020208          AND      r2,r2,#8
000008  b90a              CBNZ     r2,|L46.14|
;;;565      {
;;;566        bitstatus = TIMER_CntDir_Up;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L46.16|
                  |L46.14|
;;;567      }
;;;568      else
;;;569      {
;;;570        bitstatus = TIMER_CntDir_Dn;
00000e  2008              MOVS     r0,#8
                  |L46.16|
;;;571      }
;;;572    
;;;573      return bitstatus;
;;;574    }
000010  4770              BX       lr
;;;575    
                          ENDP


                          AREA ||i.TIMER_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetFlagStatus PROC
;;;1694     */
;;;1695   FlagStatus TIMER_GetFlagStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t Flag)
000000  4602              MOV      r2,r0
;;;1696   {
;;;1697     FlagStatus bitstatus;
;;;1698   
;;;1699     /* Check the parameters */
;;;1700     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1701     assert_param(IS_TIMER_STATUS_FLAG(Flag));
;;;1702   
;;;1703     if ((TIMERx->STATUS & Flag) == 0)
000002  6d53              LDR      r3,[r2,#0x54]
000004  400b              ANDS     r3,r3,r1
000006  b90b              CBNZ     r3,|L47.12|
;;;1704     {
;;;1705       bitstatus = RESET;
000008  2000              MOVS     r0,#0
00000a  e000              B        |L47.14|
                  |L47.12|
;;;1706     }
;;;1707     else
;;;1708     {
;;;1709       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L47.14|
;;;1710     }
;;;1711   
;;;1712     return bitstatus;
;;;1713   }
00000e  4770              BX       lr
;;;1714   
                          ENDP


                          AREA ||i.TIMER_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetITStatus PROC
;;;1914     */
;;;1915   ITStatus TIMER_GetITStatus(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1916   {
000002  4602              MOV      r2,r0
;;;1917     ITStatus bitstatus;
;;;1918     uint32_t tmpreg;
;;;1919   
;;;1920     /* Check the parameters */
;;;1921     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1922     assert_param(IS_TIMER_STATUS_FLAG(TIMER_IT));
;;;1923   
;;;1924     tmpreg = TIMERx->STATUS & TIMERx->IE & TIMER_IT;
000004  6d54              LDR      r4,[r2,#0x54]
000006  6d95              LDR      r5,[r2,#0x58]
000008  402c              ANDS     r4,r4,r5
00000a  ea040301          AND      r3,r4,r1
;;;1925   
;;;1926     if (tmpreg == 0)
00000e  b90b              CBNZ     r3,|L48.20|
;;;1927     {
;;;1928       bitstatus = RESET;
000010  2000              MOVS     r0,#0
000012  e000              B        |L48.22|
                  |L48.20|
;;;1929     }
;;;1930     else
;;;1931     {
;;;1932       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L48.22|
;;;1933     }
;;;1934   
;;;1935     return bitstatus;
;;;1936   }
000016  bd30              POP      {r4,r5,pc}
;;;1937   
                          ENDP


                          AREA ||i.TIMER_GetStatus||, CODE, READONLY, ALIGN=1

                  TIMER_GetStatus PROC
;;;1662     */
;;;1663   uint32_t TIMER_GetStatus(MDR_TIMER_TypeDef* TIMERx)
000000  4601              MOV      r1,r0
;;;1664   {
;;;1665     /* Check the parameters */
;;;1666     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1667   
;;;1668     return (TIMERx->STATUS);
000002  6d48              LDR      r0,[r1,#0x54]
;;;1669   }
000004  4770              BX       lr
;;;1670   
                          ENDP


                          AREA ||i.TIMER_ITConfig||, CODE, READONLY, ALIGN=1

                  TIMER_ITConfig PROC
;;;1863     */
;;;1864   void TIMER_ITConfig(MDR_TIMER_TypeDef* TIMERx, uint32_t TIMER_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;1865   {
000002  4613              MOV      r3,r2
;;;1866     uint32_t tmpreg_IE;
;;;1867   
;;;1868     /* Check the parameters */
;;;1869     assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;1870     assert_param(IS_TIMER_STATUS(TIMER_IT));
;;;1871     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1872   
;;;1873     tmpreg_IE = TIMERx->IE;
000004  6d82              LDR      r2,[r0,#0x58]
;;;1874   
;;;1875     /* Form new value */
;;;1876     if (NewState != DISABLE)
000006  b10b              CBZ      r3,|L50.12|
;;;1877     {
;;;1878       /* Enable the TIMERx Interrupt requests by setting bits in the IE register */
;;;1879       tmpreg_IE |= TIMER_IT;
000008  430a              ORRS     r2,r2,r1
00000a  e000              B        |L50.14|
                  |L50.12|
;;;1880     }
;;;1881     else
;;;1882     {
;;;1883       /* Disable the TIMERx Interrupt requests by clearing bits in the IE register */
;;;1884       tmpreg_IE &= ~TIMER_IT;
00000c  438a              BICS     r2,r2,r1
                  |L50.14|
;;;1885     }
;;;1886   
;;;1887     /* Configure CNTRL register with new value */
;;;1888     TIMERx->IE = tmpreg_IE;
00000e  6582              STR      r2,[r0,#0x58]
;;;1889   }
000010  bd10              POP      {r4,pc}
;;;1890   
                          ENDP


                          AREA ||i.TIMER_SetChnCompare||, CODE, READONLY, ALIGN=1

                  TIMER_SetChnCompare PROC
;;;694    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;695    void TIMER_SetChnCompare(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
000000  b510              PUSH     {r4,lr}
;;;696    #endif
;;;697    {
;;;698      __IO uint32_t *tmpreg_CCRx;
;;;699    
;;;700      /* Check the parameters */
;;;701      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;702      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;703    
;;;704      tmpreg_CCRx = &TIMERx->CCR1 + Channel;
000002  f1000410          ADD      r4,r0,#0x10
000006  eb040381          ADD      r3,r4,r1,LSL #2
;;;705      *tmpreg_CCRx = Compare;
00000a  601a              STR      r2,[r3,#0]
;;;706    }
00000c  bd10              POP      {r4,pc}
;;;707    
                          ENDP


                          AREA ||i.TIMER_SetChnCompare1||, CODE, READONLY, ALIGN=1

                  TIMER_SetChnCompare1 PROC
;;;722    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;723    void TIMER_SetChnCompare1(MDR_TIMER_TypeDef* TIMERx, uint32_t Channel, uint16_t Compare)
000000  b510              PUSH     {r4,lr}
;;;724    #endif
;;;725    {
;;;726      __IO uint32_t *tmpreg_CCR1x;
;;;727    
;;;728      /* Check the parameters */
;;;729      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;730      assert_param(IS_TIMER_CHANNEL_NUMBER(Channel));
;;;731    
;;;732      tmpreg_CCR1x = &TIMERx->CCR11 + Channel;
000002  f1000470          ADD      r4,r0,#0x70
000006  eb040381          ADD      r3,r4,r1,LSL #2
;;;733      *tmpreg_CCR1x = Compare;
00000a  601a              STR      r2,[r3,#0]
;;;734    }
00000c  bd10              POP      {r4,pc}
;;;735    
                          ENDP


                          AREA ||i.TIMER_SetCntAutoreload||, CODE, READONLY, ALIGN=1

                  TIMER_SetCntAutoreload PROC
;;;235    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;236    void TIMER_SetCntAutoreload(MDR_TIMER_TypeDef* TIMERx, uint16_t Autoreload)
000000  6081              STR      r1,[r0,#8]
;;;237    #endif
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;241    
;;;242      TIMERx->ARR = Autoreload;
;;;243    }
000002  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.TIMER_SetCntPrescaler||, CODE, READONLY, ALIGN=1

                  TIMER_SetCntPrescaler PROC
;;;218      */
;;;219    void TIMER_SetCntPrescaler(MDR_TIMER_TypeDef* TIMERx, uint16_t Prescaler)
000000  6041              STR      r1,[r0,#4]
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;223    
;;;224      TIMERx->PSG = Prescaler;
;;;225    }
000002  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.TIMER_SetCounter||, CODE, READONLY, ALIGN=1

                  TIMER_SetCounter PROC
;;;203    #elif defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;204    void TIMER_SetCounter(MDR_TIMER_TypeDef* TIMERx, uint16_t Counter)
000000  6001              STR      r1,[r0,#0]
;;;205    #endif
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;209    
;;;210      TIMERx->CNT = Counter;
;;;211    }
000002  4770              BX       lr
;;;212    
                          ENDP


                          AREA ||i.TIMER_SetCounterDirection||, CODE, READONLY, ALIGN=1

                  TIMER_SetCounterDirection PROC
;;;380      */
;;;381    void TIMER_SetCounterDirection(MDR_TIMER_TypeDef* TIMERx, uint32_t Direction)
000000  460a              MOV      r2,r1
;;;382    {
;;;383      uint32_t tmpreg_CNTRL;
;;;384    
;;;385      /* Check the parameters */
;;;386      assert_param(IS_TIMER_ALL_PERIPH(TIMERx));
;;;387      assert_param(IS_TIMER_COUNTER_DIR(Direction));
;;;388    
;;;389      tmpreg_CNTRL = TIMERx->CNTRL;
000002  68c1              LDR      r1,[r0,#0xc]
;;;390      tmpreg_CNTRL &= ~TIMER_CNTRL_DIR;
000004  f0210108          BIC      r1,r1,#8
;;;391      tmpreg_CNTRL += Direction;
000008  4411              ADD      r1,r1,r2
;;;392      TIMERx->CNTRL = tmpreg_CNTRL;
00000a  60c1              STR      r1,[r0,#0xc]
;;;393    }
00000c  4770              BX       lr
;;;394    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_MDR32F9Qx_timer_c_566b03da____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH|
#line 462
|__asm___17_MDR32F9Qx_timer_c_566b03da____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_timer_c_566b03da____RRX|
#line 649
|__asm___17_MDR32F9Qx_timer_c_566b03da____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
