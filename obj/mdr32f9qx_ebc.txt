; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_ebc.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_ebc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_ebc.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_ebc.c]
                          THUMB

                          AREA ||i.EBC_CalcNandCycles||, CODE, READONLY, ALIGN=2

                  EBC_CalcNandCycles PROC
;;;204      */
;;;205    uint32_t EBC_CalcNandCycles(uint32_t HCLK_Frequency_KHz, uint32_t Time_ns)
000000  b510              PUSH     {r4,lr}
;;;206    {
000002  4602              MOV      r2,r0
;;;207      uint32_t Cycles;
;;;208    
;;;209      if ( HCLK_Frequency_KHz == 0 )
000004  b90a              CBNZ     r2,|L1.10|
;;;210      {
;;;211        Cycles = 0;
000006  2000              MOVS     r0,#0
000008  e012              B        |L1.48|
                  |L1.10|
;;;212      }
;;;213      else if ( Time_ns > NAND_SYCLES_MAX * NAND_SYCLES_COEF / HCLK_Frequency_KHz )
00000a  4b0a              LDR      r3,|L1.52|
00000c  fbb3f3f2          UDIV     r3,r3,r2
000010  428b              CMP      r3,r1
000012  d202              BCS      |L1.26|
;;;214      {
;;;215        Cycles = 0xFFFFFFFF;
000014  f04f30ff          MOV      r0,#0xffffffff
000018  e00a              B        |L1.48|
                  |L1.26|
;;;216      }
;;;217      else
;;;218      {
;;;219        Cycles = (HCLK_Frequency_KHz * Time_ns + NAND_SYCLES_COEF - 1) / NAND_SYCLES_COEF;
00001a  4b07              LDR      r3,|L1.56|
00001c  fb023301          MLA      r3,r2,r1,r3
000020  1e5b              SUBS     r3,r3,#1
000022  4c05              LDR      r4,|L1.56|
000024  fbb3f0f4          UDIV     r0,r3,r4
;;;220        if ( Cycles > NAND_SYCLES_MAX)
000028  280f              CMP      r0,#0xf
00002a  d901              BLS      |L1.48|
;;;221        {
;;;222          Cycles = 0xFFFFFFFF;
00002c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.48|
;;;223        }
;;;224      }
;;;225    
;;;226      return Cycles;
;;;227    }
000030  bd10              POP      {r4,pc}
;;;228    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x00e4e1c0
                  |L1.56|
                          DCD      0x000f4240

                          AREA ||i.EBC_CalcWaitStates||, CODE, READONLY, ALIGN=2

                  EBC_CalcWaitStates PROC
;;;164      */
;;;165    uint32_t EBC_CalcWaitStates(uint32_t HCLK_Frequency_KHz, uint32_t Time_ns)
000000  b510              PUSH     {r4,lr}
;;;166    {
000002  4602              MOV      r2,r0
;;;167      uint32_t Cycles;
;;;168    
;;;169      if ( HCLK_Frequency_KHz == 0 )
000004  b90a              CBNZ     r2,|L2.10|
;;;170      {
;;;171        Cycles = 0;
000006  2000              MOVS     r0,#0
000008  e018              B        |L2.60|
                  |L2.10|
;;;172      }
;;;173      else if ( Time_ns > WAIT_STATES_MAX * WAIT_STATES_COEF / HCLK_Frequency_KHz )
00000a  4b0d              LDR      r3,|L2.64|
00000c  fbb3f3f2          UDIV     r3,r3,r2
000010  428b              CMP      r3,r1
000012  d202              BCS      |L2.26|
;;;174      {
;;;175        Cycles = 0xFFFFFFFF;
000014  f04f30ff          MOV      r0,#0xffffffff
000018  e010              B        |L2.60|
                  |L2.26|
;;;176      }
;;;177      else
;;;178      {
;;;179        Cycles = (HCLK_Frequency_KHz * Time_ns + WAIT_STATES_COEF - 1) / WAIT_STATES_COEF;
00001a  4b0a              LDR      r3,|L2.68|
00001c  fb023301          MLA      r3,r2,r1,r3
000020  1e5b              SUBS     r3,r3,#1
000022  4c08              LDR      r4,|L2.68|
000024  fbb3f0f4          UDIV     r0,r3,r4
;;;180        if ( Cycles > WAIT_STATES_MAX)
000028  2812              CMP      r0,#0x12
00002a  d902              BLS      |L2.50|
;;;181        {
;;;182          Cycles = 0xFFFFFFFF;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  e004              B        |L2.60|
                  |L2.50|
;;;183        }
;;;184        else if ( Cycles >= WAIT_STATES_MIN)
000032  2803              CMP      r0,#3
000034  d301              BCC      |L2.58|
;;;185        {
;;;186          Cycles -= WAIT_STATES_MIN;
000036  1ec0              SUBS     r0,r0,#3
000038  e000              B        |L2.60|
                  |L2.58|
;;;187        }
;;;188        else
;;;189        {
;;;190          Cycles = 0;
00003a  2000              MOVS     r0,#0
                  |L2.60|
;;;191        }
;;;192      }
;;;193    
;;;194      return Cycles;
;;;195    }
00003c  bd10              POP      {r4,pc}
;;;196    
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x0112a880
                  |L2.68|
                          DCD      0x000f4240

                          AREA ||i.EBC_DeInit||, CODE, READONLY, ALIGN=2

                  EBC_DeInit PROC
;;;59       */
;;;60     void EBC_DeInit(void)
000000  4802              LDR      r0,|L3.12|
;;;61     {
;;;62       MDR_EBC_TypeDef *EBCx;
;;;63     
;;;64       EBCx = MDR_EBC;
;;;65     
;;;66       EBCx->CONTROL = 0;
000002  2100              MOVS     r1,#0
000004  6541              STR      r1,[r0,#0x54]
;;;67       EBCx->NAND_CYCLES = 0;
000006  6501              STR      r1,[r0,#0x50]
;;;68     
;;;69     #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;70     
;;;71       EBCx->MEM_REGION[0] = 0;
;;;72       EBCx->MEM_REGION[1] = 0;
;;;73       EBCx->MEM_REGION[2] = 0;
;;;74       EBCx->MEM_REGION[3] = 0;
;;;75     
;;;76     #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;77     }
000008  4770              BX       lr
;;;78     
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x400f0000

                          AREA ||i.EBC_GetBusyStatus||, CODE, READONLY, ALIGN=2

                  EBC_GetBusyStatus PROC
;;;233      */
;;;234    FlagStatus EBC_GetBusyStatus(void)
000000  4904              LDR      r1,|L4.20|
;;;235    {
;;;236      MDR_EBC_TypeDef *EBCx;
;;;237      FlagStatus tmpreg_BUSY_STS;
;;;238    
;;;239      EBCx = MDR_EBC;
;;;240    
;;;241      if ((EBCx->CONTROL & EBC_CONTROL_BUSY) == 0)
000002  6d4a              LDR      r2,[r1,#0x54]
000004  f0020280          AND      r2,r2,#0x80
000008  b90a              CBNZ     r2,|L4.14|
;;;242      {
;;;243        tmpreg_BUSY_STS = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L4.16|
                  |L4.14|
;;;244      }
;;;245      else
;;;246      {
;;;247        tmpreg_BUSY_STS = SET;
00000e  2001              MOVS     r0,#1
                  |L4.16|
;;;248      }
;;;249    
;;;250      return tmpreg_BUSY_STS;
;;;251    }
000010  4770              BX       lr
;;;252    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x400f0000

                          AREA ||i.EBC_Init||, CODE, READONLY, ALIGN=2

                  EBC_Init PROC
;;;85       */
;;;86     void EBC_Init(const EBC_InitTypeDef* EBC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;87     {
;;;88       MDR_EBC_TypeDef *EBCx;
;;;89       uint32_t tmpreg_CONTROL;
;;;90       uint32_t tmpreg_CYCLES;
;;;91     
;;;92       /* Check the parameters */
;;;93       assert_param(IS_EBC_MODE(EBC_InitStruct->EBC_Mode));
;;;94       assert_param(IS_EBC_CPOL(EBC_InitStruct->EBC_Cpol));
;;;95       assert_param(IS_EBC_WAIT_STATE(EBC_InitStruct->EBC_WaitState));
;;;96       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrc));
;;;97       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwc));
;;;98       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrea));
;;;99       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwp));
;;;100      assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwhr));
;;;101      assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTalea));
;;;102      assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrr));
;;;103    
;;;104      /* Form new value for the EBC_CONTROL register */
;;;105      tmpreg_CONTROL = (EBC_InitStruct->EBC_Mode)
000002  e9d04500          LDRD     r4,r5,[r0,#0]
000006  432c              ORRS     r4,r4,r5
000008  7a05              LDRB     r5,[r0,#8]
00000a  ea443205          ORR      r2,r4,r5,LSL #12
;;;106                     | (EBC_InitStruct->EBC_Cpol)
;;;107                     | (EBC_InitStruct->EBC_WaitState << EBC_CONTROL_WAIT_STATE_Pos);
;;;108    
;;;109    #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;110    
;;;111      /* Using the alignment data by LSB EBC */
;;;112      tmpreg_CONTROL |= EBC_InitStruct->EBC_DataAlignment;
;;;113    
;;;114    #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;115    
;;;116      /* Form new value for the EBC_NAND_CYCLES register */
;;;117      tmpreg_CYCLES  = (EBC_InitStruct->EBC_NandTrc       << EBC_NAND_CYCLES_TRC_Pos)
00000e  7a44              LDRB     r4,[r0,#9]
000010  7a85              LDRB     r5,[r0,#0xa]
000012  ea441405          ORR      r4,r4,r5,LSL #4
000016  7ac5              LDRB     r5,[r0,#0xb]
000018  ea442405          ORR      r4,r4,r5,LSL #8
00001c  7b05              LDRB     r5,[r0,#0xc]
00001e  ea443405          ORR      r4,r4,r5,LSL #12
000022  7b45              LDRB     r5,[r0,#0xd]
000024  ea444405          ORR      r4,r4,r5,LSL #16
000028  7b85              LDRB     r5,[r0,#0xe]
00002a  ea445405          ORR      r4,r4,r5,LSL #20
00002e  7bc5              LDRB     r5,[r0,#0xf]
000030  ea446305          ORR      r3,r4,r5,LSL #24
;;;118                     | (EBC_InitStruct->EBC_NandTwc       << EBC_NAND_CYCLES_TWC_Pos)
;;;119                     | (EBC_InitStruct->EBC_NandTrea      << EBC_NAND_CYCLES_TREA_Pos)
;;;120                     | (EBC_InitStruct->EBC_NandTwp       << EBC_NAND_CYCLES_TWP_Pos)
;;;121                     | (EBC_InitStruct->EBC_NandTwhr      << EBC_NAND_CYCLES_TWHR_Pos)
;;;122                     | (EBC_InitStruct->EBC_NandTalea 	  << EBC_NAND_CYCLES_TALEA_Pos)
;;;123                     | (EBC_InitStruct->EBC_NandTrr       << EBC_NAND_CYCLES_TRR_Pos);
;;;124    
;;;125      EBCx = MDR_EBC;
000034  4901              LDR      r1,|L5.60|
;;;126    
;;;127      /* Configure EBC registers with new values */
;;;128      EBCx->NAND_CYCLES = tmpreg_CYCLES;
000036  650b              STR      r3,[r1,#0x50]
;;;129      EBCx->CONTROL = tmpreg_CONTROL;
000038  654a              STR      r2,[r1,#0x54]
;;;130    }
00003a  bd30              POP      {r4,r5,pc}
;;;131    
                          ENDP

                  |L5.60|
                          DCD      0x400f0000

                          AREA ||i.EBC_StructInit||, CODE, READONLY, ALIGN=1

                  EBC_StructInit PROC
;;;137      */
;;;138    void EBC_StructInit(EBC_InitTypeDef* EBC_InitStruct)
000000  2100              MOVS     r1,#0
;;;139    {
;;;140      /* Reset EBC initialization structure parameters values */
;;;141      EBC_InitStruct->EBC_Mode          = EBC_MODE_OFF;
000002  6001              STR      r1,[r0,#0]
;;;142      EBC_InitStruct->EBC_Cpol          = EBC_CPOL_POSITIVE;
000004  6041              STR      r1,[r0,#4]
;;;143      EBC_InitStruct->EBC_WaitState 	= EBC_WAIT_STATE_3HCLK;
000006  7201              STRB     r1,[r0,#8]
;;;144      EBC_InitStruct->EBC_NandTrc       = EBC_NAND_CYCLES_0HCLK;
000008  7241              STRB     r1,[r0,#9]
;;;145      EBC_InitStruct->EBC_NandTwc       = EBC_NAND_CYCLES_0HCLK;
00000a  7281              STRB     r1,[r0,#0xa]
;;;146      EBC_InitStruct->EBC_NandTrea      = EBC_NAND_CYCLES_0HCLK;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;147      EBC_InitStruct->EBC_NandTwp       = EBC_NAND_CYCLES_0HCLK;
00000e  7301              STRB     r1,[r0,#0xc]
;;;148      EBC_InitStruct->EBC_NandTwhr      = EBC_NAND_CYCLES_0HCLK;
000010  7341              STRB     r1,[r0,#0xd]
;;;149      EBC_InitStruct->EBC_NandTalea 	= EBC_NAND_CYCLES_0HCLK;
000012  7381              STRB     r1,[r0,#0xe]
;;;150      EBC_InitStruct->EBC_NandTrr       = EBC_NAND_CYCLES_0HCLK;
000014  73c1              STRB     r1,[r0,#0xf]
;;;151    #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;152      EBC_InitStruct->EBC_DataAlignment = EBC_EBC_DATA_ALIGNMENT_OFF;
;;;153      EBC_InitStruct->EBC_UseMemRegion = DISABLE;
;;;154    #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;155    }
000016  4770              BX       lr
;;;156    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_ebc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____REVSH|
#line 462
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____RRX|
#line 649
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
