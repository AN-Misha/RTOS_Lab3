; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_ebc.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_ebc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_ebc.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_ebc.c]
                          THUMB

                          AREA ||i.EBC_CalcNandCycles||, CODE, READONLY, ALIGN=2

                  EBC_CalcNandCycles PROC
;;;185      */
;;;186    uint32_t EBC_CalcNandCycles(uint32_t HCLK_Frequency_KHz, uint32_t Time_ns)
000000  b510              PUSH     {r4,lr}
;;;187    {
000002  4602              MOV      r2,r0
;;;188      uint32_t Cycles;
;;;189    
;;;190      if ( HCLK_Frequency_KHz == 0 )
000004  b90a              CBNZ     r2,|L1.10|
;;;191      {
;;;192        Cycles = 0;
000006  2000              MOVS     r0,#0
000008  e012              B        |L1.48|
                  |L1.10|
;;;193      }
;;;194      else if ( Time_ns > NAND_SYCLES_MAX * NAND_SYCLES_COEF / HCLK_Frequency_KHz )
00000a  4b0a              LDR      r3,|L1.52|
00000c  fbb3f3f2          UDIV     r3,r3,r2
000010  428b              CMP      r3,r1
000012  d202              BCS      |L1.26|
;;;195      {
;;;196        Cycles = 0xFFFFFFFF;
000014  f04f30ff          MOV      r0,#0xffffffff
000018  e00a              B        |L1.48|
                  |L1.26|
;;;197      }
;;;198      else
;;;199      {
;;;200        Cycles = (HCLK_Frequency_KHz * Time_ns + NAND_SYCLES_COEF - 1) / NAND_SYCLES_COEF;
00001a  4b07              LDR      r3,|L1.56|
00001c  fb023301          MLA      r3,r2,r1,r3
000020  1e5b              SUBS     r3,r3,#1
000022  4c05              LDR      r4,|L1.56|
000024  fbb3f0f4          UDIV     r0,r3,r4
;;;201        if ( Cycles > NAND_SYCLES_MAX)
000028  280f              CMP      r0,#0xf
00002a  d901              BLS      |L1.48|
;;;202        {
;;;203          Cycles = 0xFFFFFFFF;
00002c  f04f30ff          MOV      r0,#0xffffffff
                  |L1.48|
;;;204        }
;;;205      }
;;;206    
;;;207      return Cycles;
;;;208    }
000030  bd10              POP      {r4,pc}
;;;209    
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      0x00e4e1c0
                  |L1.56|
                          DCD      0x000f4240

                          AREA ||i.EBC_CalcWaitStates||, CODE, READONLY, ALIGN=2

                  EBC_CalcWaitStates PROC
;;;145      */
;;;146    uint32_t EBC_CalcWaitStates(uint32_t HCLK_Frequency_KHz, uint32_t Time_ns)
000000  b510              PUSH     {r4,lr}
;;;147    {
000002  4602              MOV      r2,r0
;;;148      uint32_t Cycles;
;;;149    
;;;150      if ( HCLK_Frequency_KHz == 0 )
000004  b90a              CBNZ     r2,|L2.10|
;;;151      {
;;;152        Cycles = 0;
000006  2000              MOVS     r0,#0
000008  e018              B        |L2.60|
                  |L2.10|
;;;153      }
;;;154      else if ( Time_ns > WAIT_STATES_MAX * WAIT_STATES_COEF / HCLK_Frequency_KHz )
00000a  4b0d              LDR      r3,|L2.64|
00000c  fbb3f3f2          UDIV     r3,r3,r2
000010  428b              CMP      r3,r1
000012  d202              BCS      |L2.26|
;;;155      {
;;;156        Cycles = 0xFFFFFFFF;
000014  f04f30ff          MOV      r0,#0xffffffff
000018  e010              B        |L2.60|
                  |L2.26|
;;;157      }
;;;158      else
;;;159      {
;;;160        Cycles = (HCLK_Frequency_KHz * Time_ns + WAIT_STATES_COEF - 1) / WAIT_STATES_COEF;
00001a  4b0a              LDR      r3,|L2.68|
00001c  fb023301          MLA      r3,r2,r1,r3
000020  1e5b              SUBS     r3,r3,#1
000022  4c08              LDR      r4,|L2.68|
000024  fbb3f0f4          UDIV     r0,r3,r4
;;;161        if ( Cycles > WAIT_STATES_MAX)
000028  2812              CMP      r0,#0x12
00002a  d902              BLS      |L2.50|
;;;162        {
;;;163          Cycles = 0xFFFFFFFF;
00002c  f04f30ff          MOV      r0,#0xffffffff
000030  e004              B        |L2.60|
                  |L2.50|
;;;164        }
;;;165        else if ( Cycles >= WAIT_STATES_MIN)
000032  2803              CMP      r0,#3
000034  d301              BCC      |L2.58|
;;;166        {
;;;167          Cycles -= WAIT_STATES_MIN;
000036  1ec0              SUBS     r0,r0,#3
000038  e000              B        |L2.60|
                  |L2.58|
;;;168        }
;;;169        else
;;;170        {
;;;171          Cycles = 0;
00003a  2000              MOVS     r0,#0
                  |L2.60|
;;;172        }
;;;173      }
;;;174    
;;;175      return Cycles;
;;;176    }
00003c  bd10              POP      {r4,pc}
;;;177    
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x0112a880
                  |L2.68|
                          DCD      0x000f4240

                          AREA ||i.EBC_DeInit||, CODE, READONLY, ALIGN=2

                  EBC_DeInit PROC
;;;40       */
;;;41     void EBC_DeInit(void)
000000  4802              LDR      r0,|L3.12|
;;;42     {
;;;43       MDR_EBC_TypeDef *EBCx;
;;;44     
;;;45       EBCx = MDR_EBC;
;;;46     
;;;47       EBCx->CONTROL = 0;
000002  2100              MOVS     r1,#0
000004  6541              STR      r1,[r0,#0x54]
;;;48       EBCx->NAND_CYCLES = 0;
000006  6501              STR      r1,[r0,#0x50]
;;;49     
;;;50     #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;51     
;;;52       EBCx->MEM_REGION[0] = 0;
;;;53       EBCx->MEM_REGION[1] = 0;
;;;54       EBCx->MEM_REGION[2] = 0;
;;;55       EBCx->MEM_REGION[3] = 0;
;;;56     
;;;57     #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;58     }
000008  4770              BX       lr
;;;59     
                          ENDP

00000a  0000              DCW      0x0000
                  |L3.12|
                          DCD      0x400f0000

                          AREA ||i.EBC_GetBusyStatus||, CODE, READONLY, ALIGN=2

                  EBC_GetBusyStatus PROC
;;;214      */
;;;215    FlagStatus EBC_GetBusyStatus(void)
000000  4904              LDR      r1,|L4.20|
;;;216    {
;;;217      MDR_EBC_TypeDef *EBCx;
;;;218      FlagStatus tmpreg_BUSY_STS;
;;;219    
;;;220      EBCx = MDR_EBC;
;;;221    
;;;222      if ((EBCx->CONTROL & EBC_CONTROL_BUSY) == 0)
000002  6d4a              LDR      r2,[r1,#0x54]
000004  f0020280          AND      r2,r2,#0x80
000008  b90a              CBNZ     r2,|L4.14|
;;;223      {
;;;224        tmpreg_BUSY_STS = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L4.16|
                  |L4.14|
;;;225      }
;;;226      else
;;;227      {
;;;228        tmpreg_BUSY_STS = SET;
00000e  2001              MOVS     r0,#1
                  |L4.16|
;;;229      }
;;;230    
;;;231      return tmpreg_BUSY_STS;
;;;232    }
000010  4770              BX       lr
;;;233    
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x400f0000

                          AREA ||i.EBC_Init||, CODE, READONLY, ALIGN=2

                  EBC_Init PROC
;;;66       */
;;;67     void EBC_Init(const EBC_InitTypeDef* EBC_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;68     {
;;;69       MDR_EBC_TypeDef *EBCx;
;;;70       uint32_t tmpreg_CONTROL;
;;;71       uint32_t tmpreg_CYCLES;
;;;72     
;;;73       /* Check the parameters */
;;;74       assert_param(IS_EBC_MODE(EBC_InitStruct->EBC_Mode));
;;;75       assert_param(IS_EBC_CPOL(EBC_InitStruct->EBC_Cpol));
;;;76       assert_param(IS_EBC_WAIT_STATE(EBC_InitStruct->EBC_WaitState));
;;;77       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrc));
;;;78       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwc));
;;;79       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrea));
;;;80       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwp));
;;;81       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTwhr));
;;;82       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTalea));
;;;83       assert_param(IS_EBC_NAND_CYCLES(EBC_InitStruct->EBC_NandTrr));
;;;84     
;;;85       /* Form new value for the EBC_CONTROL register */
;;;86       tmpreg_CONTROL = (EBC_InitStruct->EBC_Mode)
000002  e9d04500          LDRD     r4,r5,[r0,#0]
000006  432c              ORRS     r4,r4,r5
000008  7a05              LDRB     r5,[r0,#8]
00000a  ea443205          ORR      r2,r4,r5,LSL #12
;;;87                      | (EBC_InitStruct->EBC_Cpol)
;;;88                      | (EBC_InitStruct->EBC_WaitState << EBC_CONTROL_WAIT_STATE_Pos);
;;;89     
;;;90     #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;91     
;;;92       /* Using the alignment data by LSB EBC */
;;;93       tmpreg_CONTROL |= EBC_InitStruct->EBC_DataAlignment;
;;;94     
;;;95     #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;96     
;;;97       /* Form new value for the EBC_NAND_CYCLES register */
;;;98       tmpreg_CYCLES  = (EBC_InitStruct->EBC_NandTrc       << EBC_NAND_CYCLES_TRC_Pos)
00000e  7a44              LDRB     r4,[r0,#9]
000010  7a85              LDRB     r5,[r0,#0xa]
000012  ea441405          ORR      r4,r4,r5,LSL #4
000016  7ac5              LDRB     r5,[r0,#0xb]
000018  ea442405          ORR      r4,r4,r5,LSL #8
00001c  7b05              LDRB     r5,[r0,#0xc]
00001e  ea443405          ORR      r4,r4,r5,LSL #12
000022  7b45              LDRB     r5,[r0,#0xd]
000024  ea444405          ORR      r4,r4,r5,LSL #16
000028  7b85              LDRB     r5,[r0,#0xe]
00002a  ea445405          ORR      r4,r4,r5,LSL #20
00002e  7bc5              LDRB     r5,[r0,#0xf]
000030  ea446305          ORR      r3,r4,r5,LSL #24
;;;99                      | (EBC_InitStruct->EBC_NandTwc       << EBC_NAND_CYCLES_TWC_Pos)
;;;100                     | (EBC_InitStruct->EBC_NandTrea      << EBC_NAND_CYCLES_TREA_Pos)
;;;101                     | (EBC_InitStruct->EBC_NandTwp       << EBC_NAND_CYCLES_TWP_Pos)
;;;102                     | (EBC_InitStruct->EBC_NandTwhr      << EBC_NAND_CYCLES_TWHR_Pos)
;;;103                     | (EBC_InitStruct->EBC_NandTalea 	  << EBC_NAND_CYCLES_TALEA_Pos)
;;;104                     | (EBC_InitStruct->EBC_NandTrr       << EBC_NAND_CYCLES_TRR_Pos);
;;;105    
;;;106      EBCx = MDR_EBC;
000034  4901              LDR      r1,|L5.60|
;;;107    
;;;108      /* Configure EBC registers with new values */
;;;109      EBCx->NAND_CYCLES = tmpreg_CYCLES;
000036  650b              STR      r3,[r1,#0x50]
;;;110      EBCx->CONTROL = tmpreg_CONTROL;
000038  654a              STR      r2,[r1,#0x54]
;;;111    }
00003a  bd30              POP      {r4,r5,pc}
;;;112    
                          ENDP

                  |L5.60|
                          DCD      0x400f0000

                          AREA ||i.EBC_StructInit||, CODE, READONLY, ALIGN=1

                  EBC_StructInit PROC
;;;118      */
;;;119    void EBC_StructInit(EBC_InitTypeDef* EBC_InitStruct)
000000  2100              MOVS     r1,#0
;;;120    {
;;;121      /* Reset EBC initialization structure parameters values */
;;;122      EBC_InitStruct->EBC_Mode          = EBC_MODE_OFF;
000002  6001              STR      r1,[r0,#0]
;;;123      EBC_InitStruct->EBC_Cpol          = EBC_CPOL_POSITIVE;
000004  6041              STR      r1,[r0,#4]
;;;124      EBC_InitStruct->EBC_WaitState 	= EBC_WAIT_STATE_3HCLK;
000006  7201              STRB     r1,[r0,#8]
;;;125      EBC_InitStruct->EBC_NandTrc       = EBC_NAND_CYCLES_0HCLK;
000008  7241              STRB     r1,[r0,#9]
;;;126      EBC_InitStruct->EBC_NandTwc       = EBC_NAND_CYCLES_0HCLK;
00000a  7281              STRB     r1,[r0,#0xa]
;;;127      EBC_InitStruct->EBC_NandTrea      = EBC_NAND_CYCLES_0HCLK;
00000c  72c1              STRB     r1,[r0,#0xb]
;;;128      EBC_InitStruct->EBC_NandTwp       = EBC_NAND_CYCLES_0HCLK;
00000e  7301              STRB     r1,[r0,#0xc]
;;;129      EBC_InitStruct->EBC_NandTwhr      = EBC_NAND_CYCLES_0HCLK;
000010  7341              STRB     r1,[r0,#0xd]
;;;130      EBC_InitStruct->EBC_NandTalea 	= EBC_NAND_CYCLES_0HCLK;
000012  7381              STRB     r1,[r0,#0xe]
;;;131      EBC_InitStruct->EBC_NandTrr       = EBC_NAND_CYCLES_0HCLK;
000014  73c1              STRB     r1,[r0,#0xf]
;;;132    #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE94)
;;;133      EBC_InitStruct->EBC_DataAlignment = EBC_EBC_DATA_ALIGNMENT_OFF;
;;;134      EBC_InitStruct->EBC_UseMemRegion = DISABLE;
;;;135    #endif /* #if defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T) */
;;;136    }
000016  4770              BX       lr
;;;137    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_ebc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____REVSH|
#line 482
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ebc_c_9bebf752____RRX|
#line 669
|__asm___15_MDR32F9Qx_ebc_c_9bebf752____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
