; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_bkp.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_bkp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_bkp.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_bkp.c]
                          THUMB

                          AREA ||i.BKP_DeInit||, CODE, READONLY, ALIGN=2

                  BKP_DeInit PROC
;;;101      */
;;;102    void BKP_DeInit(void)
000000  4910              LDR      r1,|L1.68|
;;;103    {
;;;104      #define BKP_RTC_CS_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CS) - BKP_OFFSET)/4)
;;;105      #define BKP_REG_0F_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0F) - BKP_OFFSET)/4)
;;;106      #define BKP_REG_0E_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0E) - BKP_OFFSET)/4)
;;;107      #define BKP_RTC_CNT_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CNT) - BKP_OFFSET)/4)
;;;108    
;;;109      uint32_t * _bkp = (uint32_t *) MDR_BKP_BASE;
;;;110      uint32_t i;
;;;111    
;;;112      for ( i = 0; i < BKP_REG_0E_NUM; i++)
000002  2000              MOVS     r0,#0
000004  e003              B        |L1.14|
                  |L1.6|
;;;113      {
;;;114        _bkp[i] = 0;
000006  2200              MOVS     r2,#0
000008  f8412020          STR      r2,[r1,r0,LSL #2]
00000c  1c40              ADDS     r0,r0,#1              ;112
                  |L1.14|
00000e  280e              CMP      r0,#0xe               ;112
000010  d3f9              BCC      |L1.6|
;;;115      }
;;;116    
;;;117      for ( i = BKP_RTC_CNT_NUM; i <= BKP_RTC_CS_NUM; i++)
000012  2010              MOVS     r0,#0x10
000014  e003              B        |L1.30|
                  |L1.22|
;;;118      {
;;;119        _bkp[i] = 0;
000016  2200              MOVS     r2,#0
000018  f8412020          STR      r2,[r1,r0,LSL #2]
00001c  1c40              ADDS     r0,r0,#1              ;117
                  |L1.30|
00001e  2814              CMP      r0,#0x14              ;117
000020  d9f9              BLS      |L1.22|
;;;120      }
;;;121    
;;;122      MDR_BKP -> REG_0E |= (uint32_t) (BKP_REG_0E_ON);
000022  4a08              LDR      r2,|L1.68|
000024  6b92              LDR      r2,[r2,#0x38]
000026  f4426200          ORR      r2,r2,#0x800
00002a  4b06              LDR      r3,|L1.68|
00002c  639a              STR      r2,[r3,#0x38]
;;;123      MDR_BKP -> REG_0E &= (uint32_t) (BKP_REG_0E_OFF);
00002e  461a              MOV      r2,r3
000030  6b92              LDR      r2,[r2,#0x38]
000032  4b05              LDR      r3,|L1.72|
000034  401a              ANDS     r2,r2,r3
000036  4b03              LDR      r3,|L1.68|
000038  639a              STR      r2,[r3,#0x38]
;;;124      MDR_BKP -> REG_0F = (uint32_t) (BKP_REG_0F_LSI_ON);
00003a  f44f4200          MOV      r2,#0x8000
00003e  63da              STR      r2,[r3,#0x3c]
;;;125    }
000040  4770              BX       lr
;;;126    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x400d8000
                  |L1.72|
                          DCD      0x7ffff8c0

                          AREA ||i.BKP_JTAGA_CMD||, CODE, READONLY, ALIGN=2

                  BKP_JTAGA_CMD PROC
;;;134      */
;;;135    void BKP_JTAGA_CMD(FunctionalState NewState)
000000  4901              LDR      r1,|L2.8|
;;;136    {
;;;137      /* Check the parameters */
;;;138      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;139    
;;;140      *(__IO uint32_t *) BKP_JTAGA_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;141    }
000004  4770              BX       lr
;;;142    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x43b00718

                          AREA ||i.BKP_JTAGB_CMD||, CODE, READONLY, ALIGN=2

                  BKP_JTAGB_CMD PROC
;;;150      */
;;;151    void BKP_JTAGB_CMD(FunctionalState NewState)
000000  4901              LDR      r1,|L3.8|
;;;152    {
;;;153      /* Check the parameters */
;;;154      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;155    
;;;156      *(__IO uint32_t *) BKP_JTAGB_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;157    }
000004  4770              BX       lr
;;;158    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x43b0071c

                          AREA ||i.BKP_RTC_Calibration||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Calibration PROC
;;;212      */
;;;213    void BKP_RTC_Calibration(uint32_t RTC_Calibration)
000000  4a05              LDR      r2,|L4.24|
;;;214    {
;;;215      uint32_t tmpreg;
;;;216    
;;;217      /* Check the parameters */
;;;218      assert_param(IS_RTC_CALIBRATION(RTC_Calibration));
;;;219      /* Clear BKP_REG0F[12:5] bits */
;;;220      tmpreg  = MDR_BKP -> REG_0F & (uint32_t) (~BKP_REG_0F_CAL_Msk);
000002  6bd2              LDR      r2,[r2,#0x3c]
000004  f42251ff          BIC      r1,r2,#0x1fe0
;;;221      /* Set BKP_REG0F[12:5] bits according to RTC clock source*/
;;;222      tmpreg |= BKP_REG_0F_CAL_Msk & (RTC_Calibration << BKP_REG_0F_CAL_Pos);
000008  f44f52ff          MOV      r2,#0x1fe0
00000c  ea021240          AND      r2,r2,r0,LSL #5
000010  4311              ORRS     r1,r1,r2
;;;223      MDR_BKP -> REG_0F = tmpreg;
000012  4a01              LDR      r2,|L4.24|
000014  63d1              STR      r1,[r2,#0x3c]
;;;224    }
000016  4770              BX       lr
;;;225    
                          ENDP

                  |L4.24|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_Enable||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Enable PROC
;;;190      */
;;;191    void BKP_RTC_Enable ( FunctionalState NewState )
000000  4901              LDR      r1,|L5.8|
;;;192    {
;;;193    	/* Check the parameters */
;;;194    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;195    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;196    	*(__IO uint32_t *) RTC_ENABLE_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;197    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;198    	if(NewState != DISABLE){
;;;199    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_EN;
;;;200    	}
;;;201    	else{
;;;202    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_EN;
;;;203    	}
;;;204    #endif
;;;205    }
000004  4770              BX       lr
;;;206    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x43b00790

                          AREA ||i.BKP_RTC_GetCounter||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetCounter PROC
;;;282      */
;;;283    uint32_t BKP_RTC_GetCounter(void)
000000  4801              LDR      r0,|L6.8|
;;;284    {
;;;285      return MDR_BKP -> RTC_CNT;
000002  6c00              LDR      r0,[r0,#0x40]
;;;286    }
000004  4770              BX       lr
;;;287    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_GetDivider||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetDivider PROC
;;;312      */
;;;313    uint32_t BKP_RTC_GetDivider(void)
000000  4801              LDR      r0,|L7.8|
;;;314    {
;;;315      return MDR_BKP -> RTC_DIV;
000002  6c40              LDR      r0,[r0,#0x44]
;;;316    }
000004  4770              BX       lr
;;;317    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetFlagStatus PROC
;;;358      */
;;;359    FlagStatus BKP_RTC_GetFlagStatus(uint32_t BKP_RTC_FLAG)
000000  4601              MOV      r1,r0
;;;360    {
;;;361      FlagStatus status;
;;;362    
;;;363      /* Check the parameters */
;;;364      assert_param(IS_BKP_RTC_GET_FLAG(BKP_RTC_FLAG));
;;;365    
;;;366      if ((MDR_BKP -> RTC_CS & BKP_RTC_FLAG) != 0)
000002  4a04              LDR      r2,|L8.20|
000004  6d12              LDR      r2,[r2,#0x50]
000006  400a              ANDS     r2,r2,r1
000008  b10a              CBZ      r2,|L8.14|
;;;367      {
;;;368        status = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;369      }
;;;370      else
;;;371      {
;;;372        status = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;373      }
;;;374      return status;
;;;375    }
000010  4770              BX       lr
;;;376    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  BKP_RTC_ITConfig PROC
;;;261      */
;;;262    void BKP_RTC_ITConfig(uint32_t BKP_RTC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;263    {
;;;264      /* Check the parameters */
;;;265      assert_param(IS_RTC_CLK_IT(BKP_RTC_IT));
;;;266      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;267    
;;;268      if (NewState != DISABLE)
;;;269      {
;;;270        MDR_BKP->RTC_CS |= BKP_RTC_IT;
000002  4a06              LDR      r2,|L9.28|
000004  6d12              LDR      r2,[r2,#0x50]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  651a              STR      r2,[r3,#0x50]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;271      }
;;;272      else
;;;273      {
;;;274        MDR_BKP->RTC_CS &= (uint32_t)~BKP_RTC_IT;
00000e  4a03              LDR      r2,|L9.28|
000010  6d12              LDR      r2,[r2,#0x50]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  651a              STR      r2,[r3,#0x50]
                  |L9.24|
;;;275      }
;;;276    }
000018  4770              BX       lr
;;;277    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_Reset||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Reset PROC
;;;233      */
;;;234    void BKP_RTC_Reset ( FunctionalState NewState )
000000  4901              LDR      r1,|L10.8|
;;;235    {
;;;236    	/* Check the parameters */
;;;237    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;238    
;;;239    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;240    	*(__IO uint32_t *) RTC_RESET_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;241    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;242    	if(NewState != DISABLE){
;;;243    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_RESET;
;;;244    	}
;;;245    	else{
;;;246    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_RESET;
;;;247    	}
;;;248    #endif // #elif defined (USE_MDR1986VE3)
;;;249    }
000004  4770              BX       lr
;;;250    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x43b007fc

                          AREA ||i.BKP_RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetAlarm PROC
;;;302      */
;;;303    void  BKP_RTC_SetAlarm(uint32_t AlarmValue)
000000  4901              LDR      r1,|L11.8|
;;;304    {
;;;305      MDR_BKP -> RTC_ALRM = AlarmValue;
000002  64c8              STR      r0,[r1,#0x4c]
;;;306    }
000004  4770              BX       lr
;;;307    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_SetCounter||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetCounter PROC
;;;292      */
;;;293    void BKP_RTC_SetCounter(uint32_t CounterValue)
000000  4901              LDR      r1,|L12.8|
;;;294    {
;;;295      MDR_BKP -> RTC_CNT = CounterValue;
000002  6408              STR      r0,[r1,#0x40]
;;;296    }
000004  4770              BX       lr
;;;297    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetPrescaler PROC
;;;323      */
;;;324    void BKP_RTC_SetPrescaler(uint32_t PrescalerValue)
000000  4901              LDR      r1,|L13.8|
;;;325    {
;;;326      /* Check the parameter */
;;;327      assert_param(IS_BKP_PRESCALER_VALUE(PrescalerValue));
;;;328    
;;;329      MDR_BKP -> RTC_PRL = PrescalerValue;
000002  6488              STR      r0,[r1,#0x48]
;;;330    }
000004  4770              BX       lr
;;;331    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_WaitForUpdate||, CODE, READONLY, ALIGN=2

                  BKP_RTC_WaitForUpdate PROC
;;;337      */
;;;338    void BKP_RTC_WaitForUpdate ( void )
000000  bf00              NOP      
                  |L14.2|
;;;339    {
;;;340    	/* Loop until WEC flag is set */
;;;341    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;342    	while (*(__IO uint32_t *) RTC_WEC_BB != 0);
000002  4802              LDR      r0,|L14.12|
000004  6800              LDR      r0,[r0,#0]
000006  2800              CMP      r0,#0
000008  d1fb              BNE      |L14.2|
;;;343    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;344    	while((MDR_BKP->RTC_CS & BKP_RTC_CS_WEC) == BKP_RTC_CS_WEC);
;;;345    #endif
;;;346    
;;;347    }
00000a  4770              BX       lr
;;;348    
                          ENDP

                  |L14.12|
                          DCD      0x43b00a18

                          AREA ||i.BKP_RTCclkSource||, CODE, READONLY, ALIGN=2

                  BKP_RTCclkSource PROC
;;;168      */
;;;169    void BKP_RTCclkSource(uint32_t RTC_CLK)
000000  4a04              LDR      r2,|L15.20|
;;;170    {
;;;171    	uint32_t tmpreg;
;;;172    
;;;173    	/* Check the parameters */
;;;174    	assert_param(IS_RTC_CLK_SOURCE(RTC_CLK));
;;;175    	/* Clear BKP_REG0F[3:2] bits */
;;;176    	tmpreg = MDR_BKP ->REG_0F & (uint32_t) (~BKP_REG_0F_RTC_SEL_Msk );
000002  6bd2              LDR      r2,[r2,#0x3c]
000004  f022010c          BIC      r1,r2,#0xc
;;;177    	/* Set BKP_REG0F[3:2] bits according to RTC clock source*/
;;;178    	tmpreg |= BKP_REG_0F_RTC_SEL_Msk & RTC_CLK;
000008  f000020c          AND      r2,r0,#0xc
00000c  4311              ORRS     r1,r1,r2
;;;179    	MDR_BKP ->REG_0F = tmpreg;
00000e  4a01              LDR      r2,|L15.20|
000010  63d1              STR      r1,[r2,#0x3c]
;;;180    
;;;181    }
000012  4770              BX       lr
;;;182    
                          ENDP

                  |L15.20|
                          DCD      0x400d8000

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_bkp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH|
#line 462
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____RRX|
#line 649
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
