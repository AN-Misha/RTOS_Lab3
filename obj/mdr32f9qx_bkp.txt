; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_bkp.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_bkp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_bkp.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_bkp.c]
                          THUMB

                          AREA ||i.BKP_DeInit||, CODE, READONLY, ALIGN=2

                  BKP_DeInit PROC
;;;82       */
;;;83     void BKP_DeInit(void)
000000  4910              LDR      r1,|L1.68|
;;;84     {
;;;85       #define BKP_RTC_CS_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CS) - BKP_OFFSET)/4)
;;;86       #define BKP_REG_0F_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0F) - BKP_OFFSET)/4)
;;;87       #define BKP_REG_0E_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, REG_0E) - BKP_OFFSET)/4)
;;;88       #define BKP_RTC_CNT_NUM ((uint32_t) (SFR_OFFSET(MDR_BKP_TypeDef, BKP_OFFSET, RTC_CNT) - BKP_OFFSET)/4)
;;;89     
;;;90       uint32_t * _bkp = (uint32_t *) MDR_BKP_BASE;
;;;91       uint32_t i;
;;;92     
;;;93       for ( i = 0; i < BKP_REG_0E_NUM; i++)
000002  2000              MOVS     r0,#0
000004  e003              B        |L1.14|
                  |L1.6|
;;;94       {
;;;95         _bkp[i] = 0;
000006  2200              MOVS     r2,#0
000008  f8412020          STR      r2,[r1,r0,LSL #2]
00000c  1c40              ADDS     r0,r0,#1              ;93
                  |L1.14|
00000e  280e              CMP      r0,#0xe               ;93
000010  d3f9              BCC      |L1.6|
;;;96       }
;;;97     
;;;98       for ( i = BKP_RTC_CNT_NUM; i <= BKP_RTC_CS_NUM; i++)
000012  2010              MOVS     r0,#0x10
000014  e003              B        |L1.30|
                  |L1.22|
;;;99       {
;;;100        _bkp[i] = 0;
000016  2200              MOVS     r2,#0
000018  f8412020          STR      r2,[r1,r0,LSL #2]
00001c  1c40              ADDS     r0,r0,#1              ;98
                  |L1.30|
00001e  2814              CMP      r0,#0x14              ;98
000020  d9f9              BLS      |L1.22|
;;;101      }
;;;102    
;;;103      MDR_BKP -> REG_0E |= (uint32_t) (BKP_REG_0E_ON);
000022  4a08              LDR      r2,|L1.68|
000024  6b92              LDR      r2,[r2,#0x38]
000026  f4426200          ORR      r2,r2,#0x800
00002a  4b06              LDR      r3,|L1.68|
00002c  639a              STR      r2,[r3,#0x38]
;;;104      MDR_BKP -> REG_0E &= (uint32_t) (BKP_REG_0E_OFF);
00002e  461a              MOV      r2,r3
000030  6b92              LDR      r2,[r2,#0x38]
000032  4b05              LDR      r3,|L1.72|
000034  401a              ANDS     r2,r2,r3
000036  4b03              LDR      r3,|L1.68|
000038  639a              STR      r2,[r3,#0x38]
;;;105      MDR_BKP -> REG_0F = (uint32_t) (BKP_REG_0F_LSI_ON | BKP_REG_0F_HSI_ON);
00003a  f44f0281          MOV      r2,#0x408000
00003e  63da              STR      r2,[r3,#0x3c]
;;;106    }
000040  4770              BX       lr
;;;107    
                          ENDP

000042  0000              DCW      0x0000
                  |L1.68|
                          DCD      0x400d8000
                  |L1.72|
                          DCD      0x7ffff8c0

                          AREA ||i.BKP_JTAGA_CMD||, CODE, READONLY, ALIGN=2

                  BKP_JTAGA_CMD PROC
;;;115      */
;;;116    void BKP_JTAGA_CMD(FunctionalState NewState)
000000  4901              LDR      r1,|L2.8|
;;;117    {
;;;118      /* Check the parameters */
;;;119      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;120    
;;;121      *(__IO uint32_t *) BKP_JTAGA_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;122    }
000004  4770              BX       lr
;;;123    
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      0x43b00718

                          AREA ||i.BKP_JTAGB_CMD||, CODE, READONLY, ALIGN=2

                  BKP_JTAGB_CMD PROC
;;;131      */
;;;132    void BKP_JTAGB_CMD(FunctionalState NewState)
000000  4901              LDR      r1,|L3.8|
;;;133    {
;;;134      /* Check the parameters */
;;;135      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;136    
;;;137      *(__IO uint32_t *) BKP_JTAGB_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;138    }
000004  4770              BX       lr
;;;139    #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      0x43b0071c

                          AREA ||i.BKP_RTC_Calibration||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Calibration PROC
;;;193      */
;;;194    void BKP_RTC_Calibration(uint32_t RTC_Calibration)
000000  4a05              LDR      r2,|L4.24|
;;;195    {
;;;196      uint32_t tmpreg;
;;;197    
;;;198      /* Check the parameters */
;;;199      assert_param(IS_RTC_CALIBRATION(RTC_Calibration));
;;;200      /* Clear BKP_REG0F[12:5] bits */
;;;201      tmpreg  = MDR_BKP -> REG_0F & (uint32_t) (~BKP_REG_0F_CAL_Msk);
000002  6bd2              LDR      r2,[r2,#0x3c]
000004  f42251ff          BIC      r1,r2,#0x1fe0
;;;202      /* Set BKP_REG0F[12:5] bits according to RTC clock source*/
;;;203      tmpreg |= BKP_REG_0F_CAL_Msk & (RTC_Calibration << BKP_REG_0F_CAL_Pos);
000008  f44f52ff          MOV      r2,#0x1fe0
00000c  ea021240          AND      r2,r2,r0,LSL #5
000010  4311              ORRS     r1,r1,r2
;;;204      MDR_BKP -> REG_0F = tmpreg;
000012  4a01              LDR      r2,|L4.24|
000014  63d1              STR      r1,[r2,#0x3c]
;;;205    }
000016  4770              BX       lr
;;;206    
                          ENDP

                  |L4.24|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_Enable||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Enable PROC
;;;171      */
;;;172    void BKP_RTC_Enable ( FunctionalState NewState )
000000  4901              LDR      r1,|L5.8|
;;;173    {
;;;174    	/* Check the parameters */
;;;175    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;176    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;177    	*(__IO uint32_t *) RTC_ENABLE_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;178    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;179    	if(NewState != DISABLE){
;;;180    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_EN;
;;;181    	}
;;;182    	else{
;;;183    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_EN;
;;;184    	}
;;;185    #endif
;;;186    }
000004  4770              BX       lr
;;;187    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      0x43b00790

                          AREA ||i.BKP_RTC_GetCounter||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetCounter PROC
;;;263      */
;;;264    uint32_t BKP_RTC_GetCounter(void)
000000  4801              LDR      r0,|L6.8|
;;;265    {
;;;266      return MDR_BKP -> RTC_CNT;
000002  6c00              LDR      r0,[r0,#0x40]
;;;267    }
000004  4770              BX       lr
;;;268    
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_GetDivider||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetDivider PROC
;;;293      */
;;;294    uint32_t BKP_RTC_GetDivider(void)
000000  4801              LDR      r0,|L7.8|
;;;295    {
;;;296      return MDR_BKP -> RTC_DIV;
000002  6c40              LDR      r0,[r0,#0x44]
;;;297    }
000004  4770              BX       lr
;;;298    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  BKP_RTC_GetFlagStatus PROC
;;;339      */
;;;340    FlagStatus BKP_RTC_GetFlagStatus(uint32_t BKP_RTC_FLAG)
000000  4601              MOV      r1,r0
;;;341    {
;;;342      FlagStatus status;
;;;343    
;;;344      /* Check the parameters */
;;;345      assert_param(IS_BKP_RTC_GET_FLAG(BKP_RTC_FLAG));
;;;346    
;;;347      if ((MDR_BKP -> RTC_CS & BKP_RTC_FLAG) != 0)
000002  4a04              LDR      r2,|L8.20|
000004  6d12              LDR      r2,[r2,#0x50]
000006  400a              ANDS     r2,r2,r1
000008  b10a              CBZ      r2,|L8.14|
;;;348      {
;;;349        status = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L8.16|
                  |L8.14|
;;;350      }
;;;351      else
;;;352      {
;;;353        status = RESET;
00000e  2000              MOVS     r0,#0
                  |L8.16|
;;;354      }
;;;355      return status;
;;;356    }
000010  4770              BX       lr
;;;357    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  BKP_RTC_ITConfig PROC
;;;242      */
;;;243    void BKP_RTC_ITConfig(uint32_t BKP_RTC_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L9.14|
;;;244    {
;;;245      /* Check the parameters */
;;;246      assert_param(IS_RTC_CLK_IT(BKP_RTC_IT));
;;;247      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;248    
;;;249      if (NewState != DISABLE)
;;;250      {
;;;251        MDR_BKP->RTC_CS |= BKP_RTC_IT;
000002  4a06              LDR      r2,|L9.28|
000004  6d12              LDR      r2,[r2,#0x50]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L9.28|
00000a  651a              STR      r2,[r3,#0x50]
00000c  e004              B        |L9.24|
                  |L9.14|
;;;252      }
;;;253      else
;;;254      {
;;;255        MDR_BKP->RTC_CS &= (uint32_t)~BKP_RTC_IT;
00000e  4a03              LDR      r2,|L9.28|
000010  6d12              LDR      r2,[r2,#0x50]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L9.28|
000016  651a              STR      r2,[r3,#0x50]
                  |L9.24|
;;;256      }
;;;257    }
000018  4770              BX       lr
;;;258    
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_Reset||, CODE, READONLY, ALIGN=2

                  BKP_RTC_Reset PROC
;;;214      */
;;;215    void BKP_RTC_Reset ( FunctionalState NewState )
000000  4901              LDR      r1,|L10.8|
;;;216    {
;;;217    	/* Check the parameters */
;;;218    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;219    
;;;220    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;221    	*(__IO uint32_t *) RTC_RESET_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;222    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;223    	if(NewState != DISABLE){
;;;224    		MDR_BKP->REG_0F |= BKP_REG_0F_RTC_RESET;
;;;225    	}
;;;226    	else{
;;;227    		MDR_BKP->REG_0F &= ~BKP_REG_0F_RTC_RESET;
;;;228    	}
;;;229    #endif // #elif defined (USE_MDR1986VE3)
;;;230    }
000004  4770              BX       lr
;;;231    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x43b007fc

                          AREA ||i.BKP_RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetAlarm PROC
;;;283      */
;;;284    void  BKP_RTC_SetAlarm(uint32_t AlarmValue)
000000  4901              LDR      r1,|L11.8|
;;;285    {
;;;286      MDR_BKP -> RTC_ALRM = AlarmValue;
000002  64c8              STR      r0,[r1,#0x4c]
;;;287    }
000004  4770              BX       lr
;;;288    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_SetCounter||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetCounter PROC
;;;273      */
;;;274    void BKP_RTC_SetCounter(uint32_t CounterValue)
000000  4901              LDR      r1,|L12.8|
;;;275    {
;;;276      MDR_BKP -> RTC_CNT = CounterValue;
000002  6408              STR      r0,[r1,#0x40]
;;;277    }
000004  4770              BX       lr
;;;278    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  BKP_RTC_SetPrescaler PROC
;;;304      */
;;;305    void BKP_RTC_SetPrescaler(uint32_t PrescalerValue)
000000  4901              LDR      r1,|L13.8|
;;;306    {
;;;307      /* Check the parameter */
;;;308      assert_param(IS_BKP_PRESCALER_VALUE(PrescalerValue));
;;;309    
;;;310      MDR_BKP -> RTC_PRL = PrescalerValue;
000002  6488              STR      r0,[r1,#0x48]
;;;311    }
000004  4770              BX       lr
;;;312    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x400d8000

                          AREA ||i.BKP_RTC_WaitForUpdate||, CODE, READONLY, ALIGN=2

                  BKP_RTC_WaitForUpdate PROC
;;;318      */
;;;319    void BKP_RTC_WaitForUpdate ( void )
000000  bf00              NOP      
                  |L14.2|
;;;320    {
;;;321    	/* Loop until WEC flag is set */
;;;322    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;323    	while (*(__IO uint32_t *) RTC_WEC_BB != 0);
000002  4802              LDR      r0,|L14.12|
000004  6800              LDR      r0,[r0,#0]
000006  2800              CMP      r0,#0
000008  d1fb              BNE      |L14.2|
;;;324    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;325    	while((MDR_BKP->RTC_CS & BKP_RTC_CS_WEC) == BKP_RTC_CS_WEC);
;;;326    #endif
;;;327    
;;;328    }
00000a  4770              BX       lr
;;;329    
                          ENDP

                  |L14.12|
                          DCD      0x43b00a18

                          AREA ||i.BKP_RTCclkSource||, CODE, READONLY, ALIGN=2

                  BKP_RTCclkSource PROC
;;;149      */
;;;150    void BKP_RTCclkSource(uint32_t RTC_CLK)
000000  4a04              LDR      r2,|L15.20|
;;;151    {
;;;152    	uint32_t tmpreg;
;;;153    
;;;154    	/* Check the parameters */
;;;155    	assert_param(IS_RTC_CLK_SOURCE(RTC_CLK));
;;;156    	/* Clear BKP_REG0F[3:2] bits */
;;;157    	tmpreg = MDR_BKP ->REG_0F & (uint32_t) (~BKP_REG_0F_RTC_SEL_Msk );
000002  6bd2              LDR      r2,[r2,#0x3c]
000004  f022010c          BIC      r1,r2,#0xc
;;;158    	/* Set BKP_REG0F[3:2] bits according to RTC clock source*/
;;;159    	tmpreg |= BKP_REG_0F_RTC_SEL_Msk & RTC_CLK;
000008  f000020c          AND      r2,r0,#0xc
00000c  4311              ORRS     r1,r1,r2
;;;160    	MDR_BKP ->REG_0F = tmpreg;
00000e  4a01              LDR      r2,|L15.20|
000010  63d1              STR      r1,[r2,#0x3c]
;;;161    
;;;162    }
000012  4770              BX       lr
;;;163    
                          ENDP

                  |L15.20|
                          DCD      0x400d8000

;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_bkp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH|
#line 482
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_bkp_c_27a06cb8____RRX|
#line 669
|__asm___15_MDR32F9Qx_bkp_c_27a06cb8____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
