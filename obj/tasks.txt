; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\tasks.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\tasks.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\tasks.crf rtos\tasks.c]
                          THUMB

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2179   
;;;2180   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  4601              MOV      r1,r0
;;;2181   {
;;;2182   TCB_t *pxTCB;
;;;2183   
;;;2184   	/* If null is passed in here then the name of the calling task is being
;;;2185   	queried. */
;;;2186   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000002  b911              CBNZ     r1,|L1.10|
000004  4803              LDR      r0,|L1.20|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000008  e000              B        |L1.12|
                  |L1.10|
00000a  4608              MOV      r0,r1
                  |L1.12|
00000c  4602              MOV      r2,r0
;;;2187   	configASSERT( pxTCB );
;;;2188   	return &( pxTCB->pcTaskName[ 0 ] );
00000e  f1020034          ADD      r0,r2,#0x34
;;;2189   }
000012  4770              BX       lr
;;;2190   /*-----------------------------------------------------------*/
                          ENDP

                  |L1.20|
                          DCD      pxCurrentTCB

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4690   
;;;4691   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4692   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4693   TickType_t xTimeToWake;
;;;4694   const TickType_t xConstTickCount = xTickCount;
000008  4816              LDR      r0,|L2.100|
00000a  6807              LDR      r7,[r0,#0]  ; xTickCount
;;;4695   
;;;4696   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4697   	{
;;;4698   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4699   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4700   		when the task leaves the Blocked state. */
;;;4701   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4702   	}
;;;4703   	#endif
;;;4704   
;;;4705   	/* Remove the task from the ready list before adding it to the blocked list
;;;4706   	as the same list item is used for both lists. */
;;;4707   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000c  4816              LDR      r0,|L2.104|
00000e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000010  1d00              ADDS     r0,r0,#4
000012  f7fffffe          BL       uxListRemove
;;;4708   	{
;;;4709   		/* The current task must be in a ready list, so there is no need to
;;;4710   		check, and the port reset macro can be called directly. */
;;;4711   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;4712   	}
;;;4713   	else
;;;4714   	{
;;;4715   		mtCOVERAGE_TEST_MARKER();
;;;4716   	}
;;;4717   
;;;4718   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4719   	{
;;;4720   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000016  1c68              ADDS     r0,r5,#1
000018  b938              CBNZ     r0,|L2.42|
00001a  b136              CBZ      r6,|L2.42|
;;;4721   		{
;;;4722   			/* Add the task to the suspended task list instead of a delayed task
;;;4723   			list to ensure it is not woken by a timing event.  It will block
;;;4724   			indefinitely. */
;;;4725   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00001c  4812              LDR      r0,|L2.104|
00001e  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000020  1d09              ADDS     r1,r1,#4
000022  4812              LDR      r0,|L2.108|
000024  f7fffffe          BL       vListInsertEnd
000028  e01a              B        |L2.96|
                  |L2.42|
;;;4726   		}
;;;4727   		else
;;;4728   		{
;;;4729   			/* Calculate the time at which the task should be woken if the event
;;;4730   			does not occur.  This may overflow but this doesn't matter, the
;;;4731   			kernel will manage it correctly. */
;;;4732   			xTimeToWake = xConstTickCount + xTicksToWait;
00002a  197c              ADDS     r4,r7,r5
;;;4733   
;;;4734   			/* The list item will be inserted in wake time order. */
;;;4735   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
00002c  480e              LDR      r0,|L2.104|
00002e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000030  6044              STR      r4,[r0,#4]
;;;4736   
;;;4737   			if( xTimeToWake < xConstTickCount )
000032  42bc              CMP      r4,r7
000034  d207              BCS      |L2.70|
;;;4738   			{
;;;4739   				/* Wake time has overflowed.  Place this item in the overflow
;;;4740   				list. */
;;;4741   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000036  480c              LDR      r0,|L2.104|
000038  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00003a  1d09              ADDS     r1,r1,#4
00003c  480c              LDR      r0,|L2.112|
00003e  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000040  f7fffffe          BL       vListInsert
000044  e00c              B        |L2.96|
                  |L2.70|
;;;4742   			}
;;;4743   			else
;;;4744   			{
;;;4745   				/* The wake time has not overflowed, so the current block list
;;;4746   				is used. */
;;;4747   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000046  4808              LDR      r0,|L2.104|
000048  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00004a  1d09              ADDS     r1,r1,#4
00004c  4809              LDR      r0,|L2.116|
00004e  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000050  f7fffffe          BL       vListInsert
;;;4748   
;;;4749   				/* If the task entering the blocked state was placed at the
;;;4750   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4751   				needs to be updated too. */
;;;4752   				if( xTimeToWake < xNextTaskUnblockTime )
000054  4808              LDR      r0,|L2.120|
000056  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000058  4284              CMP      r4,r0
00005a  d201              BCS      |L2.96|
;;;4753   				{
;;;4754   					xNextTaskUnblockTime = xTimeToWake;
00005c  4806              LDR      r0,|L2.120|
00005e  6004              STR      r4,[r0,#0]  ; xNextTaskUnblockTime
                  |L2.96|
;;;4755   				}
;;;4756   				else
;;;4757   				{
;;;4758   					mtCOVERAGE_TEST_MARKER();
;;;4759   				}
;;;4760   			}
;;;4761   		}
;;;4762   	}
;;;4763   	#else /* INCLUDE_vTaskSuspend */
;;;4764   	{
;;;4765   		/* Calculate the time at which the task should be woken if the event
;;;4766   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4767   		will manage it correctly. */
;;;4768   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4769   
;;;4770   		/* The list item will be inserted in wake time order. */
;;;4771   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4772   
;;;4773   		if( xTimeToWake < xConstTickCount )
;;;4774   		{
;;;4775   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4776   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4777   		}
;;;4778   		else
;;;4779   		{
;;;4780   			/* The wake time has not overflowed, so the current block list is used. */
;;;4781   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4782   
;;;4783   			/* If the task entering the blocked state was placed at the head of the
;;;4784   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;4785   			too. */
;;;4786   			if( xTimeToWake < xNextTaskUnblockTime )
;;;4787   			{
;;;4788   				xNextTaskUnblockTime = xTimeToWake;
;;;4789   			}
;;;4790   			else
;;;4791   			{
;;;4792   				mtCOVERAGE_TEST_MARKER();
;;;4793   			}
;;;4794   		}
;;;4795   
;;;4796   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;4797   		( void ) xCanBlockIndefinitely;
;;;4798   	}
;;;4799   	#endif /* INCLUDE_vTaskSuspend */
;;;4800   }
000060  e8bd81f0          POP      {r4-r8,pc}
;;;4801   
                          ENDP

                  |L2.100|
                          DCD      xTickCount
                  |L2.104|
                          DCD      pxCurrentTCB
                  |L2.108|
                          DCD      xSuspendedTaskList
                  |L2.112|
                          DCD      pxOverflowDelayedTaskList
                  |L2.116|
                          DCD      pxDelayedTaskList
                  |L2.120|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;961    
;;;962    static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b510              PUSH     {r4,lr}
;;;963    {
000002  4604              MOV      r4,r0
;;;964    	/* Ensure interrupts don't access the task lists while the lists are being
;;;965    	updated. */
;;;966    	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;967    	{
;;;968    		uxCurrentNumberOfTasks++;
000008  4822              LDR      r0,|L3.148|
00000a  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  4921              LDR      r1,|L3.148|
000010  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;969    		if( pxCurrentTCB == NULL )
000012  4821              LDR      r0,|L3.152|
000014  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000016  b940              CBNZ     r0,|L3.42|
;;;970    		{
;;;971    			/* There are no other tasks, or all the other tasks are in
;;;972    			the suspended state - make this the current task. */
;;;973    			pxCurrentTCB = pxNewTCB;
000018  481f              LDR      r0,|L3.152|
00001a  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
;;;974    
;;;975    			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
00001c  4608              MOV      r0,r1
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2801              CMP      r0,#1
000022  d10d              BNE      |L3.64|
;;;976    			{
;;;977    				/* This is the first task to be created so do the preliminary
;;;978    				initialisation required.  We will not recover if this call
;;;979    				fails, but we will report the failure. */
;;;980    				prvInitialiseTaskLists();
000024  f7fffffe          BL       prvInitialiseTaskLists
000028  e00a              B        |L3.64|
                  |L3.42|
;;;981    			}
;;;982    			else
;;;983    			{
;;;984    				mtCOVERAGE_TEST_MARKER();
;;;985    			}
;;;986    		}
;;;987    		else
;;;988    		{
;;;989    			/* If the scheduler is not already running, make this task the
;;;990    			current task if it is the highest priority task to be created
;;;991    			so far. */
;;;992    			if( xSchedulerRunning == pdFALSE )
00002a  481c              LDR      r0,|L3.156|
00002c  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
00002e  b938              CBNZ     r0,|L3.64|
;;;993    			{
;;;994    				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
000030  4819              LDR      r0,|L3.152|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  6ac0              LDR      r0,[r0,#0x2c]
000036  6ae1              LDR      r1,[r4,#0x2c]
000038  4288              CMP      r0,r1
00003a  d801              BHI      |L3.64|
;;;995    				{
;;;996    					pxCurrentTCB = pxNewTCB;
00003c  4816              LDR      r0,|L3.152|
00003e  6004              STR      r4,[r0,#0]  ; pxCurrentTCB
                  |L3.64|
;;;997    				}
;;;998    				else
;;;999    				{
;;;1000   					mtCOVERAGE_TEST_MARKER();
;;;1001   				}
;;;1002   			}
;;;1003   			else
;;;1004   			{
;;;1005   				mtCOVERAGE_TEST_MARKER();
;;;1006   			}
;;;1007   		}
;;;1008   
;;;1009   		uxTaskNumber++;
000040  4817              LDR      r0,|L3.160|
000042  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
000044  1c40              ADDS     r0,r0,#1
000046  4916              LDR      r1,|L3.160|
000048  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1010   
;;;1011   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1012   		{
;;;1013   			/* Add a counter into the TCB for tracing only. */
;;;1014   			pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;1015   		}
;;;1016   		#endif /* configUSE_TRACE_FACILITY */
;;;1017   		traceTASK_CREATE( pxNewTCB );
;;;1018   
;;;1019   		prvAddTaskToReadyList( pxNewTCB );
00004a  4916              LDR      r1,|L3.164|
00004c  6ae0              LDR      r0,[r4,#0x2c]
00004e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000050  4288              CMP      r0,r1
000052  d902              BLS      |L3.90|
000054  4913              LDR      r1,|L3.164|
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L3.90|
00005a  6ae1              LDR      r1,[r4,#0x2c]
00005c  eb010181          ADD      r1,r1,r1,LSL #2
000060  4a11              LDR      r2,|L3.168|
000062  eb020081          ADD      r0,r2,r1,LSL #2
000066  1d21              ADDS     r1,r4,#4
000068  f7fffffe          BL       vListInsertEnd
;;;1020   
;;;1021   		portSETUP_TCB( pxNewTCB );
;;;1022   	}
;;;1023   	taskEXIT_CRITICAL();
00006c  f7fffffe          BL       vPortExitCritical
;;;1024   
;;;1025   	if( xSchedulerRunning != pdFALSE )
000070  480a              LDR      r0,|L3.156|
000072  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000074  b168              CBZ      r0,|L3.146|
;;;1026   	{
;;;1027   		/* If the created task is of a higher priority than the current task
;;;1028   		then it should run now. */
;;;1029   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
000076  4808              LDR      r0,|L3.152|
000078  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007a  6ac0              LDR      r0,[r0,#0x2c]
00007c  6ae1              LDR      r1,[r4,#0x2c]
00007e  4288              CMP      r0,r1
000080  d207              BCS      |L3.146|
;;;1030   		{
;;;1031   			taskYIELD_IF_USING_PREEMPTION();
000082  f04f5080          MOV      r0,#0x10000000
000086  4909              LDR      r1,|L3.172|
000088  6008              STR      r0,[r1,#0]
00008a  f3bf8f4f          DSB      
00008e  f3bf8f6f          ISB      
                  |L3.146|
;;;1032   		}
;;;1033   		else
;;;1034   		{
;;;1035   			mtCOVERAGE_TEST_MARKER();
;;;1036   		}
;;;1037   	}
;;;1038   	else
;;;1039   	{
;;;1040   		mtCOVERAGE_TEST_MARKER();
;;;1041   	}
;;;1042   }
000092  bd10              POP      {r4,pc}
;;;1043   /*-----------------------------------------------------------*/
                          ENDP

                  |L3.148|
                          DCD      uxCurrentNumberOfTasks
                  |L3.152|
                          DCD      pxCurrentTCB
                  |L3.156|
                          DCD      xSchedulerRunning
                  |L3.160|
                          DCD      uxTaskNumber
                  |L3.164|
                          DCD      uxTopReadyPriority
                  |L3.168|
                          DCD      pxReadyTasksLists
                  |L3.172|
                          DCD      0xe000ed04

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3363   
;;;3364   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3365   {
;;;3366   
;;;3367   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3368   
;;;3369   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3370   	{
;;;3371   		BaseType_t xListIsEmpty;
;;;3372   
;;;3373   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3374   		too often in the idle task. */
;;;3375   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
000002  e023              B        |L4.76|
                  |L4.4|
;;;3376   		{
;;;3377   			vTaskSuspendAll();
000004  f7fffffe          BL       vTaskSuspendAll
;;;3378   			{
;;;3379   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
000008  4813              LDR      r0,|L4.88|
00000a  6800              LDR      r0,[r0,#0]  ; xTasksWaitingTermination
00000c  b908              CBNZ     r0,|L4.18|
00000e  2001              MOVS     r0,#1
000010  e000              B        |L4.20|
                  |L4.18|
000012  2000              MOVS     r0,#0
                  |L4.20|
000014  4605              MOV      r5,r0
;;;3380   			}
;;;3381   			( void ) xTaskResumeAll();
000016  f7fffffe          BL       xTaskResumeAll
;;;3382   
;;;3383   			if( xListIsEmpty == pdFALSE )
00001a  b9bd              CBNZ     r5,|L4.76|
;;;3384   			{
;;;3385   				TCB_t *pxTCB;
;;;3386   
;;;3387   				taskENTER_CRITICAL();
00001c  f7fffffe          BL       vPortEnterCritical
;;;3388   				{
;;;3389   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
000020  480d              LDR      r0,|L4.88|
000022  68c0              LDR      r0,[r0,#0xc]
000024  68c4              LDR      r4,[r0,#0xc]
;;;3390   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000026  1d20              ADDS     r0,r4,#4
000028  f7fffffe          BL       uxListRemove
;;;3391   					--uxCurrentNumberOfTasks;
00002c  480b              LDR      r0,|L4.92|
00002e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000030  1e40              SUBS     r0,r0,#1
000032  490a              LDR      r1,|L4.92|
000034  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;3392   					--uxDeletedTasksWaitingCleanUp;
000036  480a              LDR      r0,|L4.96|
000038  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
00003a  1e40              SUBS     r0,r0,#1
00003c  4908              LDR      r1,|L4.96|
00003e  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
;;;3393   				}
;;;3394   				taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
;;;3395   
;;;3396   				prvDeleteTCB( pxTCB );
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       prvDeleteTCB
;;;3397   			}
00004a  bf00              NOP      
                  |L4.76|
00004c  4804              LDR      r0,|L4.96|
00004e  6800              LDR      r0,[r0,#0]            ;3375  ; uxDeletedTasksWaitingCleanUp
000050  2800              CMP      r0,#0                 ;3375
000052  d1d7              BNE      |L4.4|
;;;3398   			else
;;;3399   			{
;;;3400   				mtCOVERAGE_TEST_MARKER();
;;;3401   			}
;;;3402   		}
;;;3403   	}
;;;3404   	#endif /* INCLUDE_vTaskDelete */
;;;3405   }
000054  bd70              POP      {r4-r6,pc}
;;;3406   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L4.88|
                          DCD      xTasksWaitingTermination
                  |L4.92|
                          DCD      uxCurrentNumberOfTasks
                  |L4.96|
                          DCD      uxDeletedTasksWaitingCleanUp

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3579   
;;;3580   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3581   	{
000002  4604              MOV      r4,r0
;;;3582   		/* This call is required specifically for the TriCore port.  It must be
;;;3583   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3584   		want to allocate and clean RAM statically. */
;;;3585   		portCLEAN_UP_TCB( pxTCB );
;;;3586   
;;;3587   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3588   		to the task to free any memory allocated at the application level. */
;;;3589   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3590   		{
;;;3591   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3592   		}
;;;3593   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3594   
;;;3595   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3596   		{
;;;3597   			/* The task can only have been allocated dynamically - free both
;;;3598   			the stack and TCB. */
;;;3599   			vPortFree( pxTCB->pxStack );
000004  6b20              LDR      r0,[r4,#0x30]
000006  f7fffffe          BL       vPortFree
;;;3600   			vPortFree( pxTCB );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       vPortFree
;;;3601   		}
;;;3602   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
;;;3603   		{
;;;3604   			/* The task could have been allocated statically or dynamically, so
;;;3605   			check what was statically allocated before trying to free the
;;;3606   			memory. */
;;;3607   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3608   			{
;;;3609   				/* Both the stack and TCB were allocated dynamically, so both
;;;3610   				must be freed. */
;;;3611   				vPortFree( pxTCB->pxStack );
;;;3612   				vPortFree( pxTCB );
;;;3613   			}
;;;3614   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3615   			{
;;;3616   				/* Only the stack was statically allocated, so the TCB is the
;;;3617   				only memory that must be freed. */
;;;3618   				vPortFree( pxTCB );
;;;3619   			}
;;;3620   			else
;;;3621   			{
;;;3622   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3623   				nothing needs to be freed. */
;;;3624   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
;;;3625   				mtCOVERAGE_TEST_MARKER();
;;;3626   			}
;;;3627   		}
;;;3628   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3629   	}
000010  bd10              POP      {r4,pc}
;;;3630   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3129    */
;;;3130   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  bf00              NOP      
                  |L6.2|
;;;3131   {
;;;3132   	/* Stop warnings. */
;;;3133   	( void ) pvParameters;
;;;3134   
;;;3135   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3136   	SCHEDULER IS STARTED. **/
;;;3137   
;;;3138   	for( ;; )
;;;3139   	{
;;;3140   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3141   		is responsible for freeing the deleted task's TCB and stack. */
;;;3142   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3143   
;;;3144   		#if ( configUSE_PREEMPTION == 0 )
;;;3145   		{
;;;3146   			/* If we are not using preemption we keep forcing a task switch to
;;;3147   			see if any other task has become available.  If we are using
;;;3148   			preemption we don't need to do this as any task becoming available
;;;3149   			will automatically get the processor anyway. */
;;;3150   			taskYIELD();
;;;3151   		}
;;;3152   		#endif /* configUSE_PREEMPTION */
;;;3153   
;;;3154   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3155   		{
;;;3156   			/* When using preemption tasks of equal priority will be
;;;3157   			timesliced.  If a task that is sharing the idle priority is ready
;;;3158   			to run then the idle task should yield before the end of the
;;;3159   			timeslice.
;;;3160   
;;;3161   			A critical region is not required here as we are just reading from
;;;3162   			the list, and an occasional incorrect value will not matter.  If
;;;3163   			the ready list at the idle priority contains more than one task
;;;3164   			then a task other than the idle task is ready to execute. */
;;;3165   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  4807              LDR      r0,|L6.36|
000008  6800              LDR      r0,[r0,#0]  ; pxReadyTasksLists
00000a  2801              CMP      r0,#1
00000c  d907              BLS      |L6.30|
;;;3166   			{
;;;3167   				taskYIELD();
00000e  f04f5080          MOV      r0,#0x10000000
000012  4905              LDR      r1,|L6.40|
000014  6008              STR      r0,[r1,#0]
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
                  |L6.30|
;;;3168   			}
;;;3169   			else
;;;3170   			{
;;;3171   				mtCOVERAGE_TEST_MARKER();
;;;3172   			}
;;;3173   		}
;;;3174   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3175   
;;;3176   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3177   		{
;;;3178   			extern void vApplicationIdleHook( void );
;;;3179   
;;;3180   			/* Call the user defined function from within the idle task.  This
;;;3181   			allows the application designer to add background functionality
;;;3182   			without the overhead of a separate task.
;;;3183   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3184   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3185   			vApplicationIdleHook();
00001e  f7fffffe          BL       vApplicationIdleHook
000022  e7ee              B        |L6.2|
;;;3186   		}
;;;3187   		#endif /* configUSE_IDLE_HOOK */
;;;3188   
;;;3189   		/* This conditional compilation should use inequality to 0, not equality
;;;3190   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3191   		user defined low power mode	implementations require
;;;3192   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3193   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3194   		{
;;;3195   		TickType_t xExpectedIdleTime;
;;;3196   
;;;3197   			/* It is not desirable to suspend then resume the scheduler on
;;;3198   			each iteration of the idle task.  Therefore, a preliminary
;;;3199   			test of the expected idle time is performed without the
;;;3200   			scheduler suspended.  The result here is not necessarily
;;;3201   			valid. */
;;;3202   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3203   
;;;3204   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3205   			{
;;;3206   				vTaskSuspendAll();
;;;3207   				{
;;;3208   					/* Now the scheduler is suspended, the expected idle
;;;3209   					time can be sampled again, and this time its value can
;;;3210   					be used. */
;;;3211   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3212   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3213   
;;;3214   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3215   					{
;;;3216   						traceLOW_POWER_IDLE_BEGIN();
;;;3217   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3218   						traceLOW_POWER_IDLE_END();
;;;3219   					}
;;;3220   					else
;;;3221   					{
;;;3222   						mtCOVERAGE_TEST_MARKER();
;;;3223   					}
;;;3224   				}
;;;3225   				( void ) xTaskResumeAll();
;;;3226   			}
;;;3227   			else
;;;3228   			{
;;;3229   				mtCOVERAGE_TEST_MARKER();
;;;3230   			}
;;;3231   		}
;;;3232   		#endif /* configUSE_TICKLESS_IDLE */
;;;3233   	}
;;;3234   }
;;;3235   /*-----------------------------------------------------------*/
                          ENDP

                  |L6.36|
                          DCD      pxReadyTasksLists
                  |L6.40|
                          DCD      0xe000ed04

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;765    
;;;766    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;767    									const char * const pcName,
;;;768    									const uint32_t ulStackDepth,
;;;769    									void * const pvParameters,
;;;770    									UBaseType_t uxPriority,
;;;771    									TaskHandle_t * const pxCreatedTask,
;;;772    									TCB_t *pxNewTCB,
;;;773    									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;774    {
000004  4680              MOV      r8,r0
000006  460f              MOV      r7,r1
000008  4691              MOV      r9,r2
00000a  e9dd6a0e          LDRD     r6,r10,[sp,#0x38]
00000e  9c10              LDR      r4,[sp,#0x40]
;;;775    StackType_t *pxTopOfStack;
;;;776    UBaseType_t x;
;;;777    
;;;778    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;779    		/* Should the task be created in privileged mode? */
;;;780    		BaseType_t xRunPrivileged;
;;;781    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;782    		{
;;;783    			xRunPrivileged = pdTRUE;
;;;784    		}
;;;785    		else
;;;786    		{
;;;787    			xRunPrivileged = pdFALSE;
;;;788    		}
;;;789    		uxPriority &= ~portPRIVILEGE_BIT;
;;;790    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;791    
;;;792    	/* Avoid dependency on memset() if it is not required. */
;;;793    	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;794    	{
;;;795    		/* Fill the stack with a known value to assist debugging. */
;;;796    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
;;;797    	}
;;;798    	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;799    
;;;800    	/* Calculate the top of stack address.  This depends on whether the stack
;;;801    	grows from high memory to low (as per the 80x86) or vice versa.
;;;802    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;803    	by the port. */
;;;804    	#if( portSTACK_GROWTH < 0 )
;;;805    	{
;;;806    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
000010  f1a90001          SUB      r0,r9,#1
000014  6b21              LDR      r1,[r4,#0x30]
000016  eb010b80          ADD      r11,r1,r0,LSL #2
;;;807    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
00001a  f02b0b07          BIC      r11,r11,#7
;;;808    
;;;809    		/* Check the alignment of the calculated top of stack is correct. */
;;;810    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;811    	}
;;;812    	#else /* portSTACK_GROWTH */
;;;813    	{
;;;814    		pxTopOfStack = pxNewTCB->pxStack;
;;;815    
;;;816    		/* Check the alignment of the stack buffer is correct. */
;;;817    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;818    
;;;819    		/* The other extreme of the stack space is required if stack checking is
;;;820    		performed. */
;;;821    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;822    	}
;;;823    	#endif /* portSTACK_GROWTH */
;;;824    
;;;825    	/* Store the task name in the TCB. */
;;;826    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
00001e  2500              MOVS     r5,#0
000020  e007              B        |L7.50|
                  |L7.34|
;;;827    	{
;;;828    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000022  5d79              LDRB     r1,[r7,r5]
000024  f1040034          ADD      r0,r4,#0x34
000028  5541              STRB     r1,[r0,r5]
;;;829    
;;;830    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;831    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;832    		string is not accessible (extremely unlikely). */
;;;833    		if( pcName[ x ] == 0x00 )
00002a  5d78              LDRB     r0,[r7,r5]
00002c  b900              CBNZ     r0,|L7.48|
;;;834    		{
;;;835    			break;
00002e  e002              B        |L7.54|
                  |L7.48|
000030  1c6d              ADDS     r5,r5,#1              ;826
                  |L7.50|
000032  2d10              CMP      r5,#0x10              ;826
000034  d3f5              BCC      |L7.34|
                  |L7.54|
000036  bf00              NOP      
;;;836    		}
;;;837    		else
;;;838    		{
;;;839    			mtCOVERAGE_TEST_MARKER();
;;;840    		}
;;;841    	}
;;;842    
;;;843    	/* Ensure the name string is terminated in the case that the string length
;;;844    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;845    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000038  2100              MOVS     r1,#0
00003a  2043              MOVS     r0,#0x43
00003c  5501              STRB     r1,[r0,r4]
;;;846    
;;;847    	/* This is used as an array index so must ensure it's not too large.  First
;;;848    	remove the privilege bit if one is present. */
;;;849    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00003e  2e05              CMP      r6,#5
000040  d300              BCC      |L7.68|
;;;850    	{
;;;851    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000042  2604              MOVS     r6,#4
                  |L7.68|
;;;852    	}
;;;853    	else
;;;854    	{
;;;855    		mtCOVERAGE_TEST_MARKER();
;;;856    	}
;;;857    
;;;858    	pxNewTCB->uxPriority = uxPriority;
000044  62e6              STR      r6,[r4,#0x2c]
;;;859    	#if ( configUSE_MUTEXES == 1 )
;;;860    	{
;;;861    		pxNewTCB->uxBasePriority = uxPriority;
000046  6466              STR      r6,[r4,#0x44]
;;;862    		pxNewTCB->uxMutexesHeld = 0;
000048  2000              MOVS     r0,#0
00004a  64a0              STR      r0,[r4,#0x48]
;;;863    	}
;;;864    	#endif /* configUSE_MUTEXES */
;;;865    
;;;866    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
00004c  1d20              ADDS     r0,r4,#4
00004e  f7fffffe          BL       vListInitialiseItem
;;;867    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000052  f1040018          ADD      r0,r4,#0x18
000056  f7fffffe          BL       vListInitialiseItem
;;;868    
;;;869    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;870    	back to	the containing TCB from a generic item in a list. */
;;;871    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
00005a  6124              STR      r4,[r4,#0x10]
;;;872    
;;;873    	/* Event lists are always in priority order. */
;;;874    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00005c  f1c60005          RSB      r0,r6,#5
000060  61a0              STR      r0,[r4,#0x18]
;;;875    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000062  6264              STR      r4,[r4,#0x24]
;;;876    
;;;877    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;878    	{
;;;879    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;880    	}
;;;881    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;882    
;;;883    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;884    	{
;;;885    		pxNewTCB->pxTaskTag = NULL;
;;;886    	}
;;;887    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;888    
;;;889    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;890    	{
;;;891    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;892    	}
;;;893    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;894    
;;;895    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;896    	{
;;;897    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;898    	}
;;;899    	#else
;;;900    	{
;;;901    		/* Avoid compiler warning about unreferenced parameter. */
;;;902    		( void ) xRegions;
;;;903    	}
;;;904    	#endif
;;;905    
;;;906    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;907    	{
;;;908    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
000064  2500              MOVS     r5,#0
000066  e005              B        |L7.116|
                  |L7.104|
;;;909    		{
;;;910    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
000068  2100              MOVS     r1,#0
00006a  f104004c          ADD      r0,r4,#0x4c
00006e  f8401025          STR      r1,[r0,r5,LSL #2]
000072  1c6d              ADDS     r5,r5,#1              ;908
                  |L7.116|
000074  2d05              CMP      r5,#5                 ;908
000076  d3f7              BCC      |L7.104|
;;;911    		}
;;;912    	}
;;;913    	#endif
;;;914    
;;;915    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;916    	{
;;;917    		pxNewTCB->ulNotifiedValue = 0;
000078  2000              MOVS     r0,#0
00007a  6620              STR      r0,[r4,#0x60]
;;;918    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00007c  f8840064          STRB     r0,[r4,#0x64]
;;;919    	}
;;;920    	#endif
;;;921    
;;;922    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;923    	{
;;;924    		/* Initialise this task's Newlib reent structure. */
;;;925    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;926    	}
;;;927    	#endif
;;;928    
;;;929    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;930    	{
;;;931    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;932    	}
;;;933    	#endif
;;;934    
;;;935    	/* Initialize the TCB stack to look as if the task was already running,
;;;936    	but had been interrupted by the scheduler.  The return address is set
;;;937    	to the start of the task function. Once the stack has been initialised
;;;938    	the	top of stack variable is updated. */
;;;939    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;940    	{
;;;941    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;942    	}
;;;943    	#else /* portUSING_MPU_WRAPPERS */
;;;944    	{
;;;945    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000080  4641              MOV      r1,r8
000082  4658              MOV      r0,r11
000084  9a03              LDR      r2,[sp,#0xc]
000086  f7fffffe          BL       pxPortInitialiseStack
00008a  6020              STR      r0,[r4,#0]
;;;946    	}
;;;947    	#endif /* portUSING_MPU_WRAPPERS */
;;;948    
;;;949    	if( ( void * ) pxCreatedTask != NULL )
00008c  f1ba0f00          CMP      r10,#0
000090  d001              BEQ      |L7.150|
;;;950    	{
;;;951    		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;952    		change the created task's priority, delete the created task, etc.*/
;;;953    		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
000092  f8ca4000          STR      r4,[r10,#0]
                  |L7.150|
;;;954    	}
;;;955    	else
;;;956    	{
;;;957    		mtCOVERAGE_TEST_MARKER();
;;;958    	}
;;;959    }
000096  e8bd9fff          POP      {r0-r12,pc}
;;;960    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3331   
;;;3332   static void prvInitialiseTaskLists( void )
000000  b510              PUSH     {r4,lr}
;;;3333   {
;;;3334   UBaseType_t uxPriority;
;;;3335   
;;;3336   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
000004  e007              B        |L8.22|
                  |L8.6|
;;;3337   	{
;;;3338   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000006  eb040184          ADD      r1,r4,r4,LSL #2
00000a  4a0f              LDR      r2,|L8.72|
00000c  eb020081          ADD      r0,r2,r1,LSL #2
000010  f7fffffe          BL       vListInitialise
000014  1c64              ADDS     r4,r4,#1              ;3336
                  |L8.22|
000016  2c05              CMP      r4,#5                 ;3336
000018  d3f5              BCC      |L8.6|
;;;3339   	}
;;;3340   
;;;3341   	vListInitialise( &xDelayedTaskList1 );
00001a  480c              LDR      r0,|L8.76|
00001c  f7fffffe          BL       vListInitialise
;;;3342   	vListInitialise( &xDelayedTaskList2 );
000020  480b              LDR      r0,|L8.80|
000022  f7fffffe          BL       vListInitialise
;;;3343   	vListInitialise( &xPendingReadyList );
000026  480b              LDR      r0,|L8.84|
000028  f7fffffe          BL       vListInitialise
;;;3344   
;;;3345   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3346   	{
;;;3347   		vListInitialise( &xTasksWaitingTermination );
00002c  480a              LDR      r0,|L8.88|
00002e  f7fffffe          BL       vListInitialise
;;;3348   	}
;;;3349   	#endif /* INCLUDE_vTaskDelete */
;;;3350   
;;;3351   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3352   	{
;;;3353   		vListInitialise( &xSuspendedTaskList );
000032  480a              LDR      r0,|L8.92|
000034  f7fffffe          BL       vListInitialise
;;;3354   	}
;;;3355   	#endif /* INCLUDE_vTaskSuspend */
;;;3356   
;;;3357   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3358   	using list2. */
;;;3359   	pxDelayedTaskList = &xDelayedTaskList1;
000038  4804              LDR      r0,|L8.76|
00003a  4909              LDR      r1,|L8.96|
00003c  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
;;;3360   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
00003e  4804              LDR      r0,|L8.80|
000040  4908              LDR      r1,|L8.100|
000042  6008              STR      r0,[r1,#0]  ; pxOverflowDelayedTaskList
;;;3361   }
000044  bd10              POP      {r4,pc}
;;;3362   /*-----------------------------------------------------------*/
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      pxReadyTasksLists
                  |L8.76|
                          DCD      xDelayedTaskList1
                  |L8.80|
                          DCD      xDelayedTaskList2
                  |L8.84|
                          DCD      xPendingReadyList
                  |L8.88|
                          DCD      xTasksWaitingTermination
                  |L8.92|
                          DCD      xSuspendedTaskList
                  |L8.96|
                          DCD      pxDelayedTaskList
                  |L8.100|
                          DCD      pxOverflowDelayedTaskList

                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3633   
;;;3634   static void prvResetNextTaskUnblockTime( void )
000000  490a              LDR      r1,|L9.44|
;;;3635   {
;;;3636   TCB_t *pxTCB;
;;;3637   
;;;3638   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  b909              CBNZ     r1,|L9.12|
000008  2101              MOVS     r1,#1
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  2100              MOVS     r1,#0
                  |L9.14|
00000e  b121              CBZ      r1,|L9.26|
;;;3639   	{
;;;3640   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3641   		the maximum possible value so it is	extremely unlikely that the
;;;3642   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3643   		there is an item in the delayed list. */
;;;3644   		xNextTaskUnblockTime = portMAX_DELAY;
000010  f04f31ff          MOV      r1,#0xffffffff
000014  4a06              LDR      r2,|L9.48|
000016  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
000018  e006              B        |L9.40|
                  |L9.26|
;;;3645   	}
;;;3646   	else
;;;3647   	{
;;;3648   		/* The new current delayed list is not empty, get the value of
;;;3649   		the item at the head of the delayed list.  This is the time at
;;;3650   		which the task at the head of the delayed list should be removed
;;;3651   		from the Blocked state. */
;;;3652   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00001a  4904              LDR      r1,|L9.44|
00001c  6809              LDR      r1,[r1,#0]  ; pxDelayedTaskList
00001e  68c9              LDR      r1,[r1,#0xc]
000020  68c8              LDR      r0,[r1,#0xc]
;;;3653   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000022  4a03              LDR      r2,|L9.48|
000024  6841              LDR      r1,[r0,#4]
000026  6011              STR      r1,[r2,#0]  ; xNextTaskUnblockTime
                  |L9.40|
;;;3654   	}
;;;3655   }
000028  4770              BX       lr
;;;3656   /*-----------------------------------------------------------*/
                          ENDP

00002a  0000              DCW      0x0000
                  |L9.44|
                          DCD      pxDelayedTaskList
                  |L9.48|
                          DCD      xNextTaskUnblockTime

                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1654   
;;;1655   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1656   	{
000002  4601              MOV      r1,r0
;;;1657   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1658   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
000006  460a              MOV      r2,r1
;;;1659   
;;;1660   		/* Accesses xPendingReadyList so must be called from a critical
;;;1661   		section. */
;;;1662   
;;;1663   		/* It does not make sense to check if the calling task is suspended. */
;;;1664   		configASSERT( xTask );
;;;1665   
;;;1666   		/* Is the task being resumed actually in the suspended list? */
;;;1667   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000008  4c0b              LDR      r4,|L10.56|
00000a  6953              LDR      r3,[r2,#0x14]
00000c  42a3              CMP      r3,r4
00000e  d101              BNE      |L10.20|
000010  2301              MOVS     r3,#1
000012  e000              B        |L10.22|
                  |L10.20|
000014  2300              MOVS     r3,#0
                  |L10.22|
000016  b173              CBZ      r3,|L10.54|
;;;1668   		{
;;;1669   			/* Has the task already been resumed from within an ISR? */
;;;1670   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
000018  4c08              LDR      r4,|L10.60|
00001a  6a93              LDR      r3,[r2,#0x28]
00001c  42a3              CMP      r3,r4
00001e  d101              BNE      |L10.36|
000020  2301              MOVS     r3,#1
000022  e000              B        |L10.38|
                  |L10.36|
000024  2300              MOVS     r3,#0
                  |L10.38|
000026  b933              CBNZ     r3,|L10.54|
;;;1671   			{
;;;1672   				/* Is it in the suspended list because it is in the	Suspended
;;;1673   				state, or because is is blocked with no timeout? */
;;;1674   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
000028  6a93              LDR      r3,[r2,#0x28]
00002a  b90b              CBNZ     r3,|L10.48|
00002c  2301              MOVS     r3,#1
00002e  e000              B        |L10.50|
                  |L10.48|
000030  2300              MOVS     r3,#0
                  |L10.50|
000032  b103              CBZ      r3,|L10.54|
;;;1675   				{
;;;1676   					xReturn = pdTRUE;
000034  2001              MOVS     r0,#1
                  |L10.54|
;;;1677   				}
;;;1678   				else
;;;1679   				{
;;;1680   					mtCOVERAGE_TEST_MARKER();
;;;1681   				}
;;;1682   			}
;;;1683   			else
;;;1684   			{
;;;1685   				mtCOVERAGE_TEST_MARKER();
;;;1686   			}
;;;1687   		}
;;;1688   		else
;;;1689   		{
;;;1690   			mtCOVERAGE_TEST_MARKER();
;;;1691   		}
;;;1692   
;;;1693   		return xReturn;
;;;1694   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000036  bd10              POP      {r4,pc}
;;;1695   
                          ENDP

                  |L10.56|
                          DCD      xSuspendedTaskList
                  |L10.60|
                          DCD      xPendingReadyList

                          AREA ||i.pvTaskGetThreadLocalStoragePointer||, CODE, READONLY, ALIGN=2

                  pvTaskGetThreadLocalStoragePointer PROC
;;;3294   
;;;3295   	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex )
000000  b510              PUSH     {r4,lr}
;;;3296   	{
000002  4602              MOV      r2,r0
;;;3297   	void *pvReturn = NULL;
000004  2000              MOVS     r0,#0
;;;3298   	TCB_t *pxTCB;
;;;3299   
;;;3300   		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
000006  2905              CMP      r1,#5
000008  da0a              BGE      |L11.32|
;;;3301   		{
;;;3302   			pxTCB = prvGetTCBFromHandle( xTaskToQuery );
00000a  b912              CBNZ     r2,|L11.18|
00000c  4c05              LDR      r4,|L11.36|
00000e  6824              LDR      r4,[r4,#0]  ; pxCurrentTCB
000010  e000              B        |L11.20|
                  |L11.18|
000012  4614              MOV      r4,r2
                  |L11.20|
000014  4623              MOV      r3,r4
;;;3303   			pvReturn = pxTCB->pvThreadLocalStoragePointers[ xIndex ];
000016  f103044c          ADD      r4,r3,#0x4c
00001a  f8540021          LDR      r0,[r4,r1,LSL #2]
00001e  e000              B        |L11.34|
                  |L11.32|
;;;3304   		}
;;;3305   		else
;;;3306   		{
;;;3307   			pvReturn = NULL;
000020  2000              MOVS     r0,#0
                  |L11.34|
;;;3308   		}
;;;3309   
;;;3310   		return pvReturn;
;;;3311   	}
000022  bd10              POP      {r4,pc}
;;;3312   
                          ENDP

                  |L11.36|
                          DCD      pxCurrentTCB

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4176   
;;;4177   	void *pvTaskIncrementMutexHeldCount( void )
000000  4806              LDR      r0,|L12.28|
;;;4178   	{
;;;4179   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4180   		then pxCurrentTCB will be NULL. */
;;;4181   		if( pxCurrentTCB != NULL )
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000004  b130              CBZ      r0,|L12.20|
;;;4182   		{
;;;4183   			( pxCurrentTCB->uxMutexesHeld )++;
000006  4905              LDR      r1,|L12.28|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  f1010048          ADD      r0,r1,#0x48
00000e  6c89              LDR      r1,[r1,#0x48]
000010  1c49              ADDS     r1,r1,#1
000012  6001              STR      r1,[r0,#0]
                  |L12.20|
;;;4184   		}
;;;4185   
;;;4186   		return pxCurrentTCB;
000014  4801              LDR      r0,|L12.28|
000016  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;4187   	}
000018  4770              BX       lr
;;;4188   
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      pxCurrentTCB

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4193   
;;;4194   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4195   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;4196   	uint32_t ulReturn;
;;;4197   
;;;4198   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4199   		{
;;;4200   			/* Only block if the notification count is not already non-zero. */
;;;4201   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4818              LDR      r0,|L13.108|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  6e00              LDR      r0,[r0,#0x60]
000010  b988              CBNZ     r0,|L13.54|
;;;4202   			{
;;;4203   				/* Mark this task as waiting for a notification. */
;;;4204   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000012  2001              MOVS     r0,#1
000014  4915              LDR      r1,|L13.108|
000016  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000018  f8810064          STRB     r0,[r1,#0x64]
;;;4205   
;;;4206   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  b15d              CBZ      r5,|L13.54|
;;;4207   				{
;;;4208   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4209   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4210   
;;;4211   					/* All ports are written to allow a yield in a critical
;;;4212   					section (some will yield immediately, others wait until the
;;;4213   					critical section exits) - but it is not something that
;;;4214   					application code should ever do. */
;;;4215   					portYIELD_WITHIN_API();
000026  f04f5080          MOV      r0,#0x10000000
00002a  4911              LDR      r1,|L13.112|
00002c  6008              STR      r0,[r1,#0]
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
                  |L13.54|
;;;4216   				}
;;;4217   				else
;;;4218   				{
;;;4219   					mtCOVERAGE_TEST_MARKER();
;;;4220   				}
;;;4221   			}
;;;4222   			else
;;;4223   			{
;;;4224   				mtCOVERAGE_TEST_MARKER();
;;;4225   			}
;;;4226   		}
;;;4227   		taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;4228   
;;;4229   		taskENTER_CRITICAL();
00003a  f7fffffe          BL       vPortEnterCritical
;;;4230   		{
;;;4231   			traceTASK_NOTIFY_TAKE();
;;;4232   			ulReturn = pxCurrentTCB->ulNotifiedValue;
00003e  480b              LDR      r0,|L13.108|
000040  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000042  6e04              LDR      r4,[r0,#0x60]
;;;4233   
;;;4234   			if( ulReturn != 0UL )
000044  b14c              CBZ      r4,|L13.90|
;;;4235   			{
;;;4236   				if( xClearCountOnExit != pdFALSE )
000046  b126              CBZ      r6,|L13.82|
;;;4237   				{
;;;4238   					pxCurrentTCB->ulNotifiedValue = 0UL;
000048  2000              MOVS     r0,#0
00004a  4908              LDR      r1,|L13.108|
00004c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004e  6608              STR      r0,[r1,#0x60]
000050  e003              B        |L13.90|
                  |L13.82|
;;;4239   				}
;;;4240   				else
;;;4241   				{
;;;4242   					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
000052  1e60              SUBS     r0,r4,#1
000054  4905              LDR      r1,|L13.108|
000056  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000058  6608              STR      r0,[r1,#0x60]
                  |L13.90|
;;;4243   				}
;;;4244   			}
;;;4245   			else
;;;4246   			{
;;;4247   				mtCOVERAGE_TEST_MARKER();
;;;4248   			}
;;;4249   
;;;4250   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00005a  2000              MOVS     r0,#0
00005c  4903              LDR      r1,|L13.108|
00005e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000060  f8810064          STRB     r0,[r1,#0x64]
;;;4251   		}
;;;4252   		taskEXIT_CRITICAL();
000064  f7fffffe          BL       vPortExitCritical
;;;4253   
;;;4254   		return ulReturn;
000068  4620              MOV      r0,r4
;;;4255   	}
00006a  bd70              POP      {r4-r6,pc}
;;;4256   
                          ENDP

                  |L13.108|
                          DCD      pxCurrentTCB
                  |L13.112|
                          DCD      0xe000ed04

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2171   
;;;2172   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L14.8|
;;;2173   {
;;;2174   	/* A critical section is not required because the variables are of type
;;;2175   	BaseType_t. */
;;;2176   	return uxCurrentNumberOfTasks;
000002  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
;;;2177   }
000004  4770              BX       lr
;;;2178   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L14.8|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1338   
;;;1339   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1340   	{
000002  4604              MOV      r4,r0
;;;1341   	TCB_t *pxTCB;
;;;1342   	UBaseType_t uxReturn;
;;;1343   
;;;1344   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1345   		{
;;;1346   			/* If null is passed in here then it is the priority of the that
;;;1347   			called uxTaskPriorityGet() that is being queried. */
;;;1348   			pxTCB = prvGetTCBFromHandle( xTask );
000008  b914              CBNZ     r4,|L15.16|
00000a  4805              LDR      r0,|L15.32|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L15.18|
                  |L15.16|
000010  4620              MOV      r0,r4
                  |L15.18|
000012  4606              MOV      r6,r0
;;;1349   			uxReturn = pxTCB->uxPriority;
000014  6af5              LDR      r5,[r6,#0x2c]
;;;1350   		}
;;;1351   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;1352   
;;;1353   		return uxReturn;
00001a  4628              MOV      r0,r5
;;;1354   	}
00001c  bd70              POP      {r4-r6,pc}
;;;1355   
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1360   
;;;1361   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1362   	{
000002  4602              MOV      r2,r0
;;;1363   	TCB_t *pxTCB;
;;;1364   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1365   
;;;1366   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1367   		maximum	system call (or maximum API call) interrupt priority.
;;;1368   		Interrupts that are	above the maximum system call priority are keep
;;;1369   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1370   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1371   		is defined in FreeRTOSConfig.h then
;;;1372   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1373   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1374   		been assigned a priority above the configured maximum system call
;;;1375   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1376   		from interrupts	that have been assigned a priority at or (logically)
;;;1377   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1378   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1379   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1380   		provided on the following link:
;;;1381   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1382   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1383   
;;;1384   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000004  bf00              NOP      
000006  25bf              MOVS     r5,#0xbf
000008  f3ef8411          MRS      r4,BASEPRI
00000c  f3858811          MSR      BASEPRI,r5
000010  f3bf8f4f          DSB      
000014  f3bf8f6f          ISB      
000018  bf00              NOP      
00001a  4621              MOV      r1,r4
;;;1385   		{
;;;1386   			/* If null is passed in here then it is the priority of the calling
;;;1387   			task that is being queried. */
;;;1388   			pxTCB = prvGetTCBFromHandle( xTask );
00001c  b912              CBNZ     r2,|L16.36|
00001e  4c05              LDR      r4,|L16.52|
000020  6824              LDR      r4,[r4,#0]  ; pxCurrentTCB
000022  e000              B        |L16.38|
                  |L16.36|
000024  4614              MOV      r4,r2
                  |L16.38|
000026  4623              MOV      r3,r4
;;;1389   			uxReturn = pxTCB->uxPriority;
000028  6ad8              LDR      r0,[r3,#0x2c]
;;;1390   		}
;;;1391   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
00002a  bf00              NOP      
00002c  f3818811          MSR      BASEPRI,r1
000030  bf00              NOP      
;;;1392   
;;;1393   		return uxReturn;
;;;1394   	}
000032  bd70              POP      {r4-r6,pc}
;;;1395   
                          ENDP

                  |L16.52|
                          DCD      pxCurrentTCB

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4160   
;;;4161   TickType_t uxTaskResetEventItemValue( void )
000000  4905              LDR      r1,|L17.24|
;;;4162   {
;;;4163   TickType_t uxReturn;
;;;4164   
;;;4165   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000004  6988              LDR      r0,[r1,#0x18]
;;;4166   
;;;4167   	/* Reset the event list item to its normal value - so it can be used with
;;;4168   	queues and semaphores. */
;;;4169   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  4904              LDR      r1,|L17.24|
000008  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000a  6ac9              LDR      r1,[r1,#0x2c]
00000c  f1c10105          RSB      r1,r1,#5
000010  4a01              LDR      r2,|L17.24|
000012  6812              LDR      r2,[r2,#0]  ; pxCurrentTCB
000014  6191              STR      r1,[r2,#0x18]
;;;4170   
;;;4171   	return uxReturn;
;;;4172   }
000016  4770              BX       lr
;;;4173   /*-----------------------------------------------------------*/
                          ENDP

                  |L17.24|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=2

                  vTaskDelay PROC
;;;1222   
;;;1223   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b570              PUSH     {r4-r6,lr}
;;;1224   	{
000002  4604              MOV      r4,r0
;;;1225   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1226   
;;;1227   		/* A delay time of zero just forces a reschedule. */
;;;1228   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  b144              CBZ      r4,|L18.26|
;;;1229   		{
;;;1230   			configASSERT( uxSchedulerSuspended == 0 );
;;;1231   			vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;1232   			{
;;;1233   				traceTASK_DELAY();
;;;1234   
;;;1235   				/* A task that is removed from the event list while the
;;;1236   				scheduler is suspended will not get placed in the ready
;;;1237   				list or removed from the blocked list until the scheduler
;;;1238   				is resumed.
;;;1239   
;;;1240   				This task cannot be in an event list as it is the currently
;;;1241   				executing task. */
;;;1242   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
00000c  2100              MOVS     r1,#0
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1243   			}
;;;1244   			xAlreadyYielded = xTaskResumeAll();
000014  f7fffffe          BL       xTaskResumeAll
000018  4605              MOV      r5,r0
                  |L18.26|
;;;1245   		}
;;;1246   		else
;;;1247   		{
;;;1248   			mtCOVERAGE_TEST_MARKER();
;;;1249   		}
;;;1250   
;;;1251   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1252   		have put ourselves to sleep. */
;;;1253   		if( xAlreadyYielded == pdFALSE )
00001a  b93d              CBNZ     r5,|L18.44|
;;;1254   		{
;;;1255   			portYIELD_WITHIN_API();
00001c  f04f5080          MOV      r0,#0x10000000
000020  4903              LDR      r1,|L18.48|
000022  6008              STR      r0,[r1,#0]
000024  f3bf8f4f          DSB      
000028  f3bf8f6f          ISB      
                  |L18.44|
;;;1256   		}
;;;1257   		else
;;;1258   		{
;;;1259   			mtCOVERAGE_TEST_MARKER();
;;;1260   		}
;;;1261   	}
00002c  bd70              POP      {r4-r6,pc}
;;;1262   
                          ENDP

00002e  0000              DCW      0x0000
                  |L18.48|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1138   
;;;1139   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1140   	{
000004  4604              MOV      r4,r0
000006  4688              MOV      r8,r1
;;;1141   	TickType_t xTimeToWake;
;;;1142   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1143   
;;;1144   		configASSERT( pxPreviousWakeTime );
;;;1145   		configASSERT( ( xTimeIncrement > 0U ) );
;;;1146   		configASSERT( uxSchedulerSuspended == 0 );
;;;1147   
;;;1148   		vTaskSuspendAll();
00000c  f7fffffe          BL       vTaskSuspendAll
;;;1149   		{
;;;1150   			/* Minor optimisation.  The tick count cannot change in this
;;;1151   			block. */
;;;1152   			const TickType_t xConstTickCount = xTickCount;
000010  4816              LDR      r0,|L19.108|
000012  6806              LDR      r6,[r0,#0]  ; xTickCount
;;;1153   
;;;1154   			/* Generate the tick time at which the task wants to wake. */
;;;1155   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000014  6820              LDR      r0,[r4,#0]
000016  eb000508          ADD      r5,r0,r8
;;;1156   
;;;1157   			if( xConstTickCount < *pxPreviousWakeTime )
00001a  6820              LDR      r0,[r4,#0]
00001c  42b0              CMP      r0,r6
00001e  d907              BLS      |L19.48|
;;;1158   			{
;;;1159   				/* The tick count has overflowed since this function was
;;;1160   				lasted called.  In this case the only time we should ever
;;;1161   				actually delay is if the wake time has also	overflowed,
;;;1162   				and the wake time is greater than the tick time.  When this
;;;1163   				is the case it is as if neither time had overflowed. */
;;;1164   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000020  6820              LDR      r0,[r4,#0]
000022  42a8              CMP      r0,r5
000024  d90b              BLS      |L19.62|
000026  42b5              CMP      r5,r6
000028  d909              BLS      |L19.62|
;;;1165   				{
;;;1166   					xShouldDelay = pdTRUE;
00002a  f04f0901          MOV      r9,#1
00002e  e006              B        |L19.62|
                  |L19.48|
;;;1167   				}
;;;1168   				else
;;;1169   				{
;;;1170   					mtCOVERAGE_TEST_MARKER();
;;;1171   				}
;;;1172   			}
;;;1173   			else
;;;1174   			{
;;;1175   				/* The tick time has not overflowed.  In this case we will
;;;1176   				delay if either the wake time has overflowed, and/or the
;;;1177   				tick time is less than the wake time. */
;;;1178   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000030  6820              LDR      r0,[r4,#0]
000032  42a8              CMP      r0,r5
000034  d801              BHI      |L19.58|
000036  42b5              CMP      r5,r6
000038  d901              BLS      |L19.62|
                  |L19.58|
;;;1179   				{
;;;1180   					xShouldDelay = pdTRUE;
00003a  f04f0901          MOV      r9,#1
                  |L19.62|
;;;1181   				}
;;;1182   				else
;;;1183   				{
;;;1184   					mtCOVERAGE_TEST_MARKER();
;;;1185   				}
;;;1186   			}
;;;1187   
;;;1188   			/* Update the wake time ready for the next call. */
;;;1189   			*pxPreviousWakeTime = xTimeToWake;
00003e  6025              STR      r5,[r4,#0]
;;;1190   
;;;1191   			if( xShouldDelay != pdFALSE )
000040  f1b90f00          CMP      r9,#0
000044  d003              BEQ      |L19.78|
;;;1192   			{
;;;1193   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1194   
;;;1195   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1196   				the time to wake, so subtract the current tick count. */
;;;1197   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000046  1ba8              SUBS     r0,r5,r6
000048  2100              MOVS     r1,#0
00004a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L19.78|
;;;1198   			}
;;;1199   			else
;;;1200   			{
;;;1201   				mtCOVERAGE_TEST_MARKER();
;;;1202   			}
;;;1203   		}
;;;1204   		xAlreadyYielded = xTaskResumeAll();
00004e  f7fffffe          BL       xTaskResumeAll
000052  4607              MOV      r7,r0
;;;1205   
;;;1206   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1207   		have put ourselves to sleep. */
;;;1208   		if( xAlreadyYielded == pdFALSE )
000054  b93f              CBNZ     r7,|L19.102|
;;;1209   		{
;;;1210   			portYIELD_WITHIN_API();
000056  f04f5080          MOV      r0,#0x10000000
00005a  4905              LDR      r1,|L19.112|
00005c  6008              STR      r0,[r1,#0]
00005e  f3bf8f4f          DSB      
000062  f3bf8f6f          ISB      
                  |L19.102|
;;;1211   		}
;;;1212   		else
;;;1213   		{
;;;1214   			mtCOVERAGE_TEST_MARKER();
;;;1215   		}
;;;1216   	}
000066  e8bd87f0          POP      {r4-r10,pc}
;;;1217   
                          ENDP

00006a  0000              DCW      0x0000
                  |L19.108|
                          DCD      xTickCount
                  |L19.112|
                          DCD      0xe000ed04

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1046   
;;;1047   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1048   	{
000002  4605              MOV      r5,r0
;;;1049   	TCB_t *pxTCB;
;;;1050   
;;;1051   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1052   		{
;;;1053   			/* If null is passed in here then it is the calling task that is
;;;1054   			being deleted. */
;;;1055   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  b915              CBNZ     r5,|L20.16|
00000a  481e              LDR      r0,|L20.132|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L20.18|
                  |L20.16|
000010  4628              MOV      r0,r5
                  |L20.18|
000012  4604              MOV      r4,r0
;;;1056   
;;;1057   			/* Remove task from the ready list. */
;;;1058   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;1059   			{
;;;1060   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1061   			}
;;;1062   			else
;;;1063   			{
;;;1064   				mtCOVERAGE_TEST_MARKER();
;;;1065   			}
;;;1066   
;;;1067   			/* Is the task waiting on an event also? */
;;;1068   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L20.38|
;;;1069   			{
;;;1070   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L20.38|
;;;1071   			}
;;;1072   			else
;;;1073   			{
;;;1074   				mtCOVERAGE_TEST_MARKER();
;;;1075   			}
;;;1076   
;;;1077   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1078   			detect that the task lists need re-generating.  This is done before
;;;1079   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1080   			not return. */
;;;1081   			uxTaskNumber++;
000026  4818              LDR      r0,|L20.136|
000028  6800              LDR      r0,[r0,#0]  ; uxTaskNumber
00002a  1c40              ADDS     r0,r0,#1
00002c  4916              LDR      r1,|L20.136|
00002e  6008              STR      r0,[r1,#0]  ; uxTaskNumber
;;;1082   
;;;1083   			if( pxTCB == pxCurrentTCB )
000030  4814              LDR      r0,|L20.132|
000032  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000034  4284              CMP      r4,r0
000036  d109              BNE      |L20.76|
;;;1084   			{
;;;1085   				/* A task is deleting itself.  This cannot complete within the
;;;1086   				task itself, as a context switch to another task is required.
;;;1087   				Place the task in the termination list.  The idle task will
;;;1088   				check the termination list and free up any memory allocated by
;;;1089   				the scheduler for the TCB and stack of the deleted task. */
;;;1090   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000038  1d21              ADDS     r1,r4,#4
00003a  4814              LDR      r0,|L20.140|
00003c  f7fffffe          BL       vListInsertEnd
;;;1091   
;;;1092   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1093   				there is a task that has been deleted and that it should therefore
;;;1094   				check the xTasksWaitingTermination list. */
;;;1095   				++uxDeletedTasksWaitingCleanUp;
000040  4813              LDR      r0,|L20.144|
000042  6800              LDR      r0,[r0,#0]  ; uxDeletedTasksWaitingCleanUp
000044  1c40              ADDS     r0,r0,#1
000046  4912              LDR      r1,|L20.144|
000048  6008              STR      r0,[r1,#0]  ; uxDeletedTasksWaitingCleanUp
00004a  e009              B        |L20.96|
                  |L20.76|
;;;1096   
;;;1097   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1098   				in which Windows specific clean up operations are performed,
;;;1099   				after which it is not possible to yield away from this task -
;;;1100   				hence xYieldPending is used to latch that a context switch is
;;;1101   				required. */
;;;1102   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1103   			}
;;;1104   			else
;;;1105   			{
;;;1106   				--uxCurrentNumberOfTasks;
00004c  4811              LDR      r0,|L20.148|
00004e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000050  1e40              SUBS     r0,r0,#1
000052  4910              LDR      r1,|L20.148|
000054  6008              STR      r0,[r1,#0]  ; uxCurrentNumberOfTasks
;;;1107   				prvDeleteTCB( pxTCB );
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       prvDeleteTCB
;;;1108   
;;;1109   				/* Reset the next expected unblock time in case it referred to
;;;1110   				the task that has just been deleted. */
;;;1111   				prvResetNextTaskUnblockTime();
00005c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L20.96|
;;;1112   			}
;;;1113   
;;;1114   			traceTASK_DELETE( pxTCB );
;;;1115   		}
;;;1116   		taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
;;;1117   
;;;1118   		/* Force a reschedule if it is the currently running task that has just
;;;1119   		been deleted. */
;;;1120   		if( xSchedulerRunning != pdFALSE )
000064  480c              LDR      r0,|L20.152|
000066  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000068  b158              CBZ      r0,|L20.130|
;;;1121   		{
;;;1122   			if( pxTCB == pxCurrentTCB )
00006a  4806              LDR      r0,|L20.132|
00006c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00006e  4284              CMP      r4,r0
000070  d107              BNE      |L20.130|
;;;1123   			{
;;;1124   				configASSERT( uxSchedulerSuspended == 0 );
;;;1125   				portYIELD_WITHIN_API();
000072  f04f5080          MOV      r0,#0x10000000
000076  4909              LDR      r1,|L20.156|
000078  6008              STR      r0,[r1,#0]
00007a  f3bf8f4f          DSB      
00007e  f3bf8f6f          ISB      
                  |L20.130|
;;;1126   			}
;;;1127   			else
;;;1128   			{
;;;1129   				mtCOVERAGE_TEST_MARKER();
;;;1130   			}
;;;1131   		}
;;;1132   	}
000082  bd70              POP      {r4-r6,pc}
;;;1133   
                          ENDP

                  |L20.132|
                          DCD      pxCurrentTCB
                  |L20.136|
                          DCD      uxTaskNumber
                  |L20.140|
                          DCD      xTasksWaitingTermination
                  |L20.144|
                          DCD      uxDeletedTasksWaitingCleanUp
                  |L20.148|
                          DCD      uxCurrentNumberOfTasks
                  |L20.152|
                          DCD      xSchedulerRunning
                  |L20.156|
                          DCD      0xe000ed04

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;1931   
;;;1932   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1933   {
;;;1934   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1935   	routine so the original ISRs can be restored if necessary.  The port
;;;1936   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1937   	portDISABLE_INTERRUPTS();
000002  bf00              NOP      
000004  20bf              MOVS     r0,#0xbf
000006  f3808811          MSR      BASEPRI,r0
00000a  f3bf8f4f          DSB      
00000e  f3bf8f6f          ISB      
000012  bf00              NOP      
;;;1938   	xSchedulerRunning = pdFALSE;
000014  2000              MOVS     r0,#0
000016  4902              LDR      r1,|L21.32|
000018  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1939   	vPortEndScheduler();
00001a  f7fffffe          BL       vPortEndScheduler
;;;1940   }
00001e  bd10              POP      {r4,pc}
;;;1941   /*----------------------------------------------------------*/
                          ENDP

                  |L21.32|
                          DCD      xSchedulerRunning

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3074   
;;;3075   void vTaskMissedYield( void )
000000  2001              MOVS     r0,#1
;;;3076   {
;;;3077   	xYieldPending = pdTRUE;
000002  4901              LDR      r1,|L22.8|
000004  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;3078   }
000006  4770              BX       lr
;;;3079   /*-----------------------------------------------------------*/
                          ENDP

                  |L22.8|
                          DCD      xYieldPending

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4571   
;;;4572   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4573   	{
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;4574   	TCB_t * pxTCB;
;;;4575   	uint8_t ucOriginalNotifyState;
;;;4576   	UBaseType_t uxSavedInterruptStatus;
;;;4577   
;;;4578   		configASSERT( xTaskToNotify );
;;;4579   
;;;4580   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4581   		maximum	system call (or maximum API call) interrupt priority.
;;;4582   		Interrupts that are	above the maximum system call priority are keep
;;;4583   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4584   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4585   		is defined in FreeRTOSConfig.h then
;;;4586   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4587   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4588   		been assigned a priority above the configured maximum system call
;;;4589   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4590   		from interrupts	that have been assigned a priority at or (logically)
;;;4591   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4592   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4593   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4594   		provided on the following link:
;;;4595   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4596   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4597   
;;;4598   		pxTCB = ( TCB_t * ) xTaskToNotify;
000008  462c              MOV      r4,r5
;;;4599   
;;;4600   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4607              MOV      r7,r0
;;;4601   		{
;;;4602   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000022  f8948064          LDRB     r8,[r4,#0x64]
;;;4603   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000026  2002              MOVS     r0,#2
000028  f8840064          STRB     r0,[r4,#0x64]
;;;4604   
;;;4605   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4606   			semaphore. */
;;;4607   			( pxTCB->ulNotifiedValue )++;
00002c  6e20              LDR      r0,[r4,#0x60]
00002e  1c40              ADDS     r0,r0,#1
000030  6620              STR      r0,[r4,#0x60]
;;;4608   
;;;4609   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4610   
;;;4611   			/* If the task is in the blocked state specifically to wait for a
;;;4612   			notification then unblock it now. */
;;;4613   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000032  f1b80f01          CMP      r8,#1
000036  d129              BNE      |L23.140|
;;;4614   			{
;;;4615   				/* The task should not have been on an event list. */
;;;4616   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4617   
;;;4618   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000038  4817              LDR      r0,|L23.152|
00003a  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00003c  b9a0              CBNZ     r0,|L23.104|
;;;4619   				{
;;;4620   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00003e  1d20              ADDS     r0,r4,#4
000040  f7fffffe          BL       uxListRemove
;;;4621   					prvAddTaskToReadyList( pxTCB );
000044  4915              LDR      r1,|L23.156|
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00004a  4288              CMP      r0,r1
00004c  d902              BLS      |L23.84|
00004e  4913              LDR      r1,|L23.156|
000050  6ae0              LDR      r0,[r4,#0x2c]
000052  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L23.84|
000054  6ae1              LDR      r1,[r4,#0x2c]
000056  eb010181          ADD      r1,r1,r1,LSL #2
00005a  4a11              LDR      r2,|L23.160|
00005c  eb020081          ADD      r0,r2,r1,LSL #2
000060  1d21              ADDS     r1,r4,#4
000062  f7fffffe          BL       vListInsertEnd
000066  e004              B        |L23.114|
                  |L23.104|
;;;4622   				}
;;;4623   				else
;;;4624   				{
;;;4625   					/* The delayed and ready lists cannot be accessed, so hold
;;;4626   					this task pending until the scheduler is resumed. */
;;;4627   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000068  f1040118          ADD      r1,r4,#0x18
00006c  480d              LDR      r0,|L23.164|
00006e  f7fffffe          BL       vListInsertEnd
                  |L23.114|
;;;4628   				}
;;;4629   
;;;4630   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000072  490d              LDR      r1,|L23.168|
000074  6ae0              LDR      r0,[r4,#0x2c]
000076  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000078  6ac9              LDR      r1,[r1,#0x2c]
00007a  4288              CMP      r0,r1
00007c  d906              BLS      |L23.140|
;;;4631   				{
;;;4632   					/* The notified task has a priority above the currently
;;;4633   					executing task so a yield is required. */
;;;4634   					if( pxHigherPriorityTaskWoken != NULL )
00007e  b116              CBZ      r6,|L23.134|
;;;4635   					{
;;;4636   						*pxHigherPriorityTaskWoken = pdTRUE;
000080  2001              MOVS     r0,#1
000082  6030              STR      r0,[r6,#0]
000084  e002              B        |L23.140|
                  |L23.134|
;;;4637   					}
;;;4638   					else
;;;4639   					{
;;;4640   						/* Mark that a yield is pending in case the user is not
;;;4641   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4642   						safe FreeRTOS function. */
;;;4643   						xYieldPending = pdTRUE;
000086  2001              MOVS     r0,#1
000088  4908              LDR      r1,|L23.172|
00008a  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L23.140|
;;;4644   					}
;;;4645   				}
;;;4646   				else
;;;4647   				{
;;;4648   					mtCOVERAGE_TEST_MARKER();
;;;4649   				}
;;;4650   			}
;;;4651   		}
;;;4652   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00008c  bf00              NOP      
00008e  f3878811          MSR      BASEPRI,r7
000092  bf00              NOP      
;;;4653   	}
000094  e8bd81f0          POP      {r4-r8,pc}
;;;4654   
                          ENDP

                  |L23.152|
                          DCD      uxSchedulerSuspended
                  |L23.156|
                          DCD      uxTopReadyPriority
                  |L23.160|
                          DCD      pxReadyTasksLists
                  |L23.164|
                          DCD      xPendingReadyList
                  |L23.168|
                          DCD      pxCurrentTCB
                  |L23.172|
                          DCD      xYieldPending

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2818   
;;;2819   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2820   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;2821   	configASSERT( pxEventList );
;;;2822   
;;;2823   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2824   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2825   
;;;2826   	/* Place the event list item of the TCB in the appropriate event list.
;;;2827   	This is placed in the list in priority order so the highest priority task
;;;2828   	is the first to be woken by the event.  The queue that contains the event
;;;2829   	list is locked, preventing simultaneous access from interrupts. */
;;;2830   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000006  4805              LDR      r0,|L24.28|
000008  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00000a  3118              ADDS     r1,r1,#0x18
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       vListInsert
;;;2831   
;;;2832   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000012  2101              MOVS     r1,#1
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2833   }
00001a  bd70              POP      {r4-r6,pc}
;;;2834   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.28|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnEventListRestricted||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventListRestricted PROC
;;;2861   
;;;2862   	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
000000  b570              PUSH     {r4-r6,lr}
;;;2863   	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;2864   		configASSERT( pxEventList );
;;;2865   
;;;2866   		/* This function should not be called by application code hence the
;;;2867   		'Restricted' in its name.  It is not part of the public API.  It is
;;;2868   		designed for use by kernel code, and has special calling requirements -
;;;2869   		it should be called with the scheduler suspended. */
;;;2870   
;;;2871   
;;;2872   		/* Place the event list item of the TCB in the appropriate event list.
;;;2873   		In this case it is assume that this is the only task that is going to
;;;2874   		be waiting on this event list, so the faster vListInsertEnd() function
;;;2875   		can be used in place of vListInsert. */
;;;2876   		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000008  4806              LDR      r0,|L25.36|
00000a  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
00000c  3118              ADDS     r1,r1,#0x18
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       vListInsertEnd
;;;2877   
;;;2878   		/* If the task should block indefinitely then set the block time to a
;;;2879   		value that will be recognised as an indefinite delay inside the
;;;2880   		prvAddCurrentTaskToDelayedList() function. */
;;;2881   		if( xWaitIndefinitely != pdFALSE )
000014  b10c              CBZ      r4,|L25.26|
;;;2882   		{
;;;2883   			xTicksToWait = portMAX_DELAY;
000016  f04f35ff          MOV      r5,#0xffffffff
                  |L25.26|
;;;2884   		}
;;;2885   
;;;2886   		traceTASK_DELAY_UNTIL( ( xTickCount + xTicksToWait ) );
;;;2887   		prvAddCurrentTaskToDelayedList( xTicksToWait, xWaitIndefinitely );
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2888   	}
000022  bd70              POP      {r4-r6,pc}
;;;2889   
                          ENDP

                  |L25.36|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2835   
;;;2836   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;2837   {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;2838   	configASSERT( pxEventList );
;;;2839   
;;;2840   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2841   	the event groups implementation. */
;;;2842   	configASSERT( uxSchedulerSuspended != 0 );
;;;2843   
;;;2844   	/* Store the item value in the event list item.  It is safe to access the
;;;2845   	event list item here as interrupts won't access the event list item of a
;;;2846   	task that is not in the Blocked state. */
;;;2847   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000008  f0444000          ORR      r0,r4,#0x80000000
00000c  4906              LDR      r1,|L26.40|
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6188              STR      r0,[r1,#0x18]
;;;2848   
;;;2849   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2850   	list.  It is safe to access the event list here because it is part of an
;;;2851   	event group implementation - and interrupts don't access event groups
;;;2852   	directly (instead they access them indirectly by pending function calls to
;;;2853   	the task level). */
;;;2854   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000012  4805              LDR      r0,|L26.40|
000014  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
000016  3118              ADDS     r1,r1,#0x18
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       vListInsertEnd
;;;2855   
;;;2856   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00001e  2101              MOVS     r1,#1
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2857   }
000026  bd70              POP      {r4-r6,pc}
;;;2858   /*-----------------------------------------------------------*/
                          ENDP

                  |L26.40|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  vTaskPriorityInherit PROC
;;;3704   
;;;3705   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3706   	{
000002  4605              MOV      r5,r0
;;;3707   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3708   
;;;3709   		/* If the mutex was given back by an interrupt while the queue was
;;;3710   		locked then the mutex holder might now be NULL. */
;;;3711   		if( pxMutexHolder != NULL )
000006  2d00              CMP      r5,#0
000008  d039              BEQ      |L27.126|
;;;3712   		{
;;;3713   			/* If the holder of the mutex has a priority below the priority of
;;;3714   			the task attempting to obtain the mutex then it will temporarily
;;;3715   			inherit the priority of the task attempting to obtain the mutex. */
;;;3716   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  491d              LDR      r1,|L27.128|
00000c  6ae0              LDR      r0,[r4,#0x2c]
00000e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000010  6ac9              LDR      r1,[r1,#0x2c]
000012  4288              CMP      r0,r1
000014  d233              BCS      |L27.126|
;;;3717   			{
;;;3718   				/* Adjust the mutex holder state to account for its new
;;;3719   				priority.  Only reset the event list item value if the value is
;;;3720   				not	being used for anything else. */
;;;3721   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  f0004000          AND      r0,r0,#0x80000000
00001c  b928              CBNZ     r0,|L27.42|
;;;3722   				{
;;;3723   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001e  4818              LDR      r0,|L27.128|
000020  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000022  6ac0              LDR      r0,[r0,#0x2c]
000024  f1c00005          RSB      r0,r0,#5
000028  61a0              STR      r0,[r4,#0x18]
                  |L27.42|
;;;3724   				}
;;;3725   				else
;;;3726   				{
;;;3727   					mtCOVERAGE_TEST_MARKER();
;;;3728   				}
;;;3729   
;;;3730   				/* If the task being modified is in the ready state it will need
;;;3731   				to be moved into a new list. */
;;;3732   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00002a  6ae1              LDR      r1,[r4,#0x2c]
00002c  eb010181          ADD      r1,r1,r1,LSL #2
000030  4a14              LDR      r2,|L27.132|
000032  eb020181          ADD      r1,r2,r1,LSL #2
000036  6960              LDR      r0,[r4,#0x14]
000038  4288              CMP      r0,r1
00003a  d101              BNE      |L27.64|
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L27.66|
                  |L27.64|
000040  2000              MOVS     r0,#0
                  |L27.66|
000042  b1c0              CBZ      r0,|L27.118|
;;;3733   				{
;;;3734   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000044  1d20              ADDS     r0,r4,#4
000046  f7fffffe          BL       uxListRemove
;;;3735   					{
;;;3736   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3737   					}
;;;3738   					else
;;;3739   					{
;;;3740   						mtCOVERAGE_TEST_MARKER();
;;;3741   					}
;;;3742   
;;;3743   					/* Inherit the priority before being moved into the new list. */
;;;3744   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
00004a  480d              LDR      r0,|L27.128|
00004c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00004e  6ac0              LDR      r0,[r0,#0x2c]
000050  62e0              STR      r0,[r4,#0x2c]
;;;3745   					prvAddTaskToReadyList( pxTCB );
000052  490d              LDR      r1,|L27.136|
000054  6ae0              LDR      r0,[r4,#0x2c]
000056  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000058  4288              CMP      r0,r1
00005a  d902              BLS      |L27.98|
00005c  490a              LDR      r1,|L27.136|
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L27.98|
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  4a06              LDR      r2,|L27.132|
00006a  eb020081          ADD      r0,r2,r1,LSL #2
00006e  1d21              ADDS     r1,r4,#4
000070  f7fffffe          BL       vListInsertEnd
000074  e003              B        |L27.126|
                  |L27.118|
;;;3746   				}
;;;3747   				else
;;;3748   				{
;;;3749   					/* Just inherit the priority. */
;;;3750   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000076  4802              LDR      r0,|L27.128|
000078  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00007a  6ac0              LDR      r0,[r0,#0x2c]
00007c  62e0              STR      r0,[r4,#0x2c]
                  |L27.126|
;;;3751   				}
;;;3752   
;;;3753   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3754   			}
;;;3755   			else
;;;3756   			{
;;;3757   				mtCOVERAGE_TEST_MARKER();
;;;3758   			}
;;;3759   		}
;;;3760   		else
;;;3761   		{
;;;3762   			mtCOVERAGE_TEST_MARKER();
;;;3763   		}
;;;3764   	}
00007e  bd70              POP      {r4-r6,pc}
;;;3765   
                          ENDP

                  |L27.128|
                          DCD      pxCurrentTCB
                  |L27.132|
                          DCD      pxReadyTasksLists
                  |L27.136|
                          DCD      uxTopReadyPriority

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1400   
;;;1401   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1402   	{
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
;;;1403   	TCB_t *pxTCB;
;;;1404   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1405   	BaseType_t xYieldRequired = pdFALSE;
000008  f04f0900          MOV      r9,#0
;;;1406   
;;;1407   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1408   
;;;1409   		/* Ensure the new priority is valid. */
;;;1410   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
00000c  2d05              CMP      r5,#5
00000e  d300              BCC      |L28.18|
;;;1411   		{
;;;1412   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000010  2504              MOVS     r5,#4
                  |L28.18|
;;;1413   		}
;;;1414   		else
;;;1415   		{
;;;1416   			mtCOVERAGE_TEST_MARKER();
;;;1417   		}
;;;1418   
;;;1419   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;1420   		{
;;;1421   			/* If null is passed in here then it is the priority of the calling
;;;1422   			task that is being changed. */
;;;1423   			pxTCB = prvGetTCBFromHandle( xTask );
000016  b917              CBNZ     r7,|L28.30|
000018  482d              LDR      r0,|L28.208|
00001a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00001c  e000              B        |L28.32|
                  |L28.30|
00001e  4638              MOV      r0,r7
                  |L28.32|
000020  4604              MOV      r4,r0
;;;1424   
;;;1425   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1426   
;;;1427   			#if ( configUSE_MUTEXES == 1 )
;;;1428   			{
;;;1429   				uxCurrentBasePriority = pxTCB->uxBasePriority;
000022  6c66              LDR      r6,[r4,#0x44]
;;;1430   			}
;;;1431   			#else
;;;1432   			{
;;;1433   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1434   			}
;;;1435   			#endif
;;;1436   
;;;1437   			if( uxCurrentBasePriority != uxNewPriority )
000024  42ae              CMP      r6,r5
000026  d04e              BEQ      |L28.198|
;;;1438   			{
;;;1439   				/* The priority change may have readied a task of higher
;;;1440   				priority than the calling task. */
;;;1441   				if( uxNewPriority > uxCurrentBasePriority )
000028  42b5              CMP      r5,r6
00002a  d90b              BLS      |L28.68|
;;;1442   				{
;;;1443   					if( pxTCB != pxCurrentTCB )
00002c  4828              LDR      r0,|L28.208|
00002e  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000030  4284              CMP      r4,r0
000032  d00d              BEQ      |L28.80|
;;;1444   					{
;;;1445   						/* The priority of a task other than the currently
;;;1446   						running task is being raised.  Is the priority being
;;;1447   						raised above that of the running task? */
;;;1448   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
000034  4826              LDR      r0,|L28.208|
000036  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000038  6ac0              LDR      r0,[r0,#0x2c]
00003a  42a8              CMP      r0,r5
00003c  d808              BHI      |L28.80|
;;;1449   						{
;;;1450   							xYieldRequired = pdTRUE;
00003e  f04f0901          MOV      r9,#1
000042  e005              B        |L28.80|
                  |L28.68|
;;;1451   						}
;;;1452   						else
;;;1453   						{
;;;1454   							mtCOVERAGE_TEST_MARKER();
;;;1455   						}
;;;1456   					}
;;;1457   					else
;;;1458   					{
;;;1459   						/* The priority of the running task is being raised,
;;;1460   						but the running task must already be the highest
;;;1461   						priority task able to run so no yield is required. */
;;;1462   					}
;;;1463   				}
;;;1464   				else if( pxTCB == pxCurrentTCB )
000044  4822              LDR      r0,|L28.208|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  4284              CMP      r4,r0
00004a  d101              BNE      |L28.80|
;;;1465   				{
;;;1466   					/* Setting the priority of the running task down means
;;;1467   					there may now be another task of higher priority that
;;;1468   					is ready to execute. */
;;;1469   					xYieldRequired = pdTRUE;
00004c  f04f0901          MOV      r9,#1
                  |L28.80|
;;;1470   				}
;;;1471   				else
;;;1472   				{
;;;1473   					/* Setting the priority of any other task down does not
;;;1474   					require a yield as the running task must be above the
;;;1475   					new priority of the task being modified. */
;;;1476   				}
;;;1477   
;;;1478   				/* Remember the ready list the task might be referenced from
;;;1479   				before its uxPriority member is changed so the
;;;1480   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1481   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000050  f8d4802c          LDR      r8,[r4,#0x2c]
;;;1482   
;;;1483   				#if ( configUSE_MUTEXES == 1 )
;;;1484   				{
;;;1485   					/* Only change the priority being used if the task is not
;;;1486   					currently using an inherited priority. */
;;;1487   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000054  6ae1              LDR      r1,[r4,#0x2c]
000056  6c60              LDR      r0,[r4,#0x44]
000058  4288              CMP      r0,r1
00005a  d100              BNE      |L28.94|
;;;1488   					{
;;;1489   						pxTCB->uxPriority = uxNewPriority;
00005c  62e5              STR      r5,[r4,#0x2c]
                  |L28.94|
;;;1490   					}
;;;1491   					else
;;;1492   					{
;;;1493   						mtCOVERAGE_TEST_MARKER();
;;;1494   					}
;;;1495   
;;;1496   					/* The base priority gets set whatever. */
;;;1497   					pxTCB->uxBasePriority = uxNewPriority;
00005e  6465              STR      r5,[r4,#0x44]
;;;1498   				}
;;;1499   				#else
;;;1500   				{
;;;1501   					pxTCB->uxPriority = uxNewPriority;
;;;1502   				}
;;;1503   				#endif
;;;1504   
;;;1505   				/* Only reset the event list item value if the value is not
;;;1506   				being used for anything else. */
;;;1507   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000060  69a0              LDR      r0,[r4,#0x18]
000062  f0004000          AND      r0,r0,#0x80000000
000066  b910              CBNZ     r0,|L28.110|
;;;1508   				{
;;;1509   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000068  f1c50005          RSB      r0,r5,#5
00006c  61a0              STR      r0,[r4,#0x18]
                  |L28.110|
;;;1510   				}
;;;1511   				else
;;;1512   				{
;;;1513   					mtCOVERAGE_TEST_MARKER();
;;;1514   				}
;;;1515   
;;;1516   				/* If the task is in the blocked or suspended list we need do
;;;1517   				nothing more than change it's priority variable. However, if
;;;1518   				the task is in a ready list it needs to be removed and placed
;;;1519   				in the list appropriate to its new priority. */
;;;1520   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00006e  eb080188          ADD      r1,r8,r8,LSL #2
000072  4a18              LDR      r2,|L28.212|
000074  eb020181          ADD      r1,r2,r1,LSL #2
000078  6960              LDR      r0,[r4,#0x14]
00007a  4288              CMP      r0,r1
00007c  d101              BNE      |L28.130|
00007e  2001              MOVS     r0,#1
000080  e000              B        |L28.132|
                  |L28.130|
000082  2000              MOVS     r0,#0
                  |L28.132|
000084  b198              CBZ      r0,|L28.174|
;;;1521   				{
;;;1522   					/* The task is currently in its ready list - remove before adding
;;;1523   					it to it's new ready list.  As we are in a critical section we
;;;1524   					can do this even if the scheduler is suspended. */
;;;1525   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000086  1d20              ADDS     r0,r4,#4
000088  f7fffffe          BL       uxListRemove
;;;1526   					{
;;;1527   						/* It is known that the task is in its ready list so
;;;1528   						there is no need to check again and the port level
;;;1529   						reset macro can be called directly. */
;;;1530   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1531   					}
;;;1532   					else
;;;1533   					{
;;;1534   						mtCOVERAGE_TEST_MARKER();
;;;1535   					}
;;;1536   					prvAddTaskToReadyList( pxTCB );
00008c  4912              LDR      r1,|L28.216|
00008e  6ae0              LDR      r0,[r4,#0x2c]
000090  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000092  4288              CMP      r0,r1
000094  d902              BLS      |L28.156|
000096  4910              LDR      r1,|L28.216|
000098  6ae0              LDR      r0,[r4,#0x2c]
00009a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L28.156|
00009c  6ae1              LDR      r1,[r4,#0x2c]
00009e  eb010181          ADD      r1,r1,r1,LSL #2
0000a2  4a0c              LDR      r2,|L28.212|
0000a4  eb020081          ADD      r0,r2,r1,LSL #2
0000a8  1d21              ADDS     r1,r4,#4
0000aa  f7fffffe          BL       vListInsertEnd
                  |L28.174|
;;;1537   				}
;;;1538   				else
;;;1539   				{
;;;1540   					mtCOVERAGE_TEST_MARKER();
;;;1541   				}
;;;1542   
;;;1543   				if( xYieldRequired != pdFALSE )
0000ae  f1b90f00          CMP      r9,#0
0000b2  d007              BEQ      |L28.196|
;;;1544   				{
;;;1545   					taskYIELD_IF_USING_PREEMPTION();
0000b4  f04f5080          MOV      r0,#0x10000000
0000b8  4908              LDR      r1,|L28.220|
0000ba  6008              STR      r0,[r1,#0]
0000bc  f3bf8f4f          DSB      
0000c0  f3bf8f6f          ISB      
                  |L28.196|
;;;1546   				}
;;;1547   				else
;;;1548   				{
;;;1549   					mtCOVERAGE_TEST_MARKER();
;;;1550   				}
;;;1551   
;;;1552   				/* Remove compiler warning about unused variables when the port
;;;1553   				optimised task selection is not being used. */
;;;1554   				( void ) uxPriorityUsedOnEntry;
0000c4  bf00              NOP      
                  |L28.198|
;;;1555   			}
;;;1556   		}
;;;1557   		taskEXIT_CRITICAL();
0000c6  f7fffffe          BL       vPortExitCritical
;;;1558   	}
0000ca  e8bd87f0          POP      {r4-r10,pc}
;;;1559   
                          ENDP

0000ce  0000              DCW      0x0000
                  |L28.208|
                          DCD      pxCurrentTCB
                  |L28.212|
                          DCD      pxReadyTasksLists
                  |L28.216|
                          DCD      uxTopReadyPriority
                  |L28.220|
                          DCD      0xe000ed04

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1700   
;;;1701   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1702   	{
000002  4605              MOV      r5,r0
;;;1703   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000004  462c              MOV      r4,r5
;;;1704   
;;;1705   		/* It does not make sense to resume the calling task. */
;;;1706   		configASSERT( xTaskToResume );
;;;1707   
;;;1708   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1709   		currently executing task. */
;;;1710   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000006  b36c              CBZ      r4,|L29.100|
000008  4817              LDR      r0,|L29.104|
00000a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000c  4284              CMP      r4,r0
00000e  d029              BEQ      |L29.100|
;;;1711   		{
;;;1712   			taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1713   			{
;;;1714   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvTaskIsTaskSuspended
00001a  b308              CBZ      r0,|L29.96|
;;;1715   				{
;;;1716   					traceTASK_RESUME( pxTCB );
;;;1717   
;;;1718   					/* As we are in a critical section we can access the ready
;;;1719   					lists even if the scheduler is suspended. */
;;;1720   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;1721   					prvAddTaskToReadyList( pxTCB );
000022  4912              LDR      r1,|L29.108|
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000028  4288              CMP      r0,r1
00002a  d902              BLS      |L29.50|
00002c  490f              LDR      r1,|L29.108|
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L29.50|
000032  6ae1              LDR      r1,[r4,#0x2c]
000034  eb010181          ADD      r1,r1,r1,LSL #2
000038  4a0d              LDR      r2,|L29.112|
00003a  eb020081          ADD      r0,r2,r1,LSL #2
00003e  1d21              ADDS     r1,r4,#4
000040  f7fffffe          BL       vListInsertEnd
;;;1722   
;;;1723   					/* We may have just resumed a higher priority task. */
;;;1724   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000044  4908              LDR      r1,|L29.104|
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00004a  6ac9              LDR      r1,[r1,#0x2c]
00004c  4288              CMP      r0,r1
00004e  d307              BCC      |L29.96|
;;;1725   					{
;;;1726   						/* This yield may not cause the task just resumed to run,
;;;1727   						but will leave the lists in the correct state for the
;;;1728   						next yield. */
;;;1729   						taskYIELD_IF_USING_PREEMPTION();
000050  f04f5080          MOV      r0,#0x10000000
000054  4907              LDR      r1,|L29.116|
000056  6008              STR      r0,[r1,#0]
000058  f3bf8f4f          DSB      
00005c  f3bf8f6f          ISB      
                  |L29.96|
;;;1730   					}
;;;1731   					else
;;;1732   					{
;;;1733   						mtCOVERAGE_TEST_MARKER();
;;;1734   					}
;;;1735   				}
;;;1736   				else
;;;1737   				{
;;;1738   					mtCOVERAGE_TEST_MARKER();
;;;1739   				}
;;;1740   			}
;;;1741   			taskEXIT_CRITICAL();
000060  f7fffffe          BL       vPortExitCritical
                  |L29.100|
;;;1742   		}
;;;1743   		else
;;;1744   		{
;;;1745   			mtCOVERAGE_TEST_MARKER();
;;;1746   		}
;;;1747   	}
000064  bd70              POP      {r4-r6,pc}
;;;1748   
                          ENDP

000066  0000              DCW      0x0000
                  |L29.104|
                          DCD      pxCurrentTCB
                  |L29.108|
                          DCD      uxTopReadyPriority
                  |L29.112|
                          DCD      pxReadyTasksLists
                  |L29.116|
                          DCD      0xe000ed04

                          AREA ||i.vTaskSetThreadLocalStoragePointer||, CODE, READONLY, ALIGN=2

                  vTaskSetThreadLocalStoragePointer PROC
;;;3278   
;;;3279   	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue )
000000  b510              PUSH     {r4,lr}
;;;3280   	{
;;;3281   	TCB_t *pxTCB;
;;;3282   
;;;3283   		if( xIndex < configNUM_THREAD_LOCAL_STORAGE_POINTERS )
000002  2905              CMP      r1,#5
000004  da09              BGE      |L30.26|
;;;3284   		{
;;;3285   			pxTCB = prvGetTCBFromHandle( xTaskToSet );
000006  b910              CBNZ     r0,|L30.14|
000008  4c04              LDR      r4,|L30.28|
00000a  6824              LDR      r4,[r4,#0]  ; pxCurrentTCB
00000c  e000              B        |L30.16|
                  |L30.14|
00000e  4604              MOV      r4,r0
                  |L30.16|
000010  4623              MOV      r3,r4
;;;3286   			pxTCB->pvThreadLocalStoragePointers[ xIndex ] = pvValue;
000012  f103044c          ADD      r4,r3,#0x4c
000016  f8442021          STR      r2,[r4,r1,LSL #2]
                  |L30.26|
;;;3287   		}
;;;3288   	}
00001a  bd10              POP      {r4,pc}
;;;3289   
                          ENDP

                  |L30.28|
                          DCD      pxCurrentTCB

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3005   
;;;3006   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4903              LDR      r1,|L31.16|
;;;3007   {
;;;3008   	configASSERT( pxTimeOut );
;;;3009   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
000004  6001              STR      r1,[r0,#0]
;;;3010   	pxTimeOut->xTimeOnEntering = xTickCount;
000006  4903              LDR      r1,|L31.20|
000008  6809              LDR      r1,[r1,#0]  ; xTickCount
00000a  6041              STR      r1,[r0,#4]
;;;3011   }
00000c  4770              BX       lr
;;;3012   /*-----------------------------------------------------------*/
                          ENDP

00000e  0000              DCW      0x0000
                  |L31.16|
                          DCD      xNumOfOverflows
                  |L31.20|
                          DCD      xTickCount

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1824   
;;;1825   void vTaskStartScheduler( void )
000000  b51c              PUSH     {r2-r4,lr}
;;;1826   {
;;;1827   BaseType_t xReturn;
;;;1828   
;;;1829   	/* Add the idle task at the lowest priority. */
;;;1830   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1831   	{
;;;1832   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1833   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1834   		uint32_t ulIdleTaskStackSize;
;;;1835   
;;;1836   		/* The Idle task is created using user provided RAM - obtain the
;;;1837   		address of the RAM then create the idle task. */
;;;1838   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1839   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1840   												"IDLE",
;;;1841   												ulIdleTaskStackSize,
;;;1842   												( void * ) NULL,
;;;1843   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1844   												pxIdleTaskStackBuffer,
;;;1845   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1846   
;;;1847   		if( xIdleTaskHandle != NULL )
;;;1848   		{
;;;1849   			xReturn = pdPASS;
;;;1850   		}
;;;1851   		else
;;;1852   		{
;;;1853   			xReturn = pdFAIL;
;;;1854   		}
;;;1855   	}
;;;1856   	#else
;;;1857   	{
;;;1858   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1859   		xReturn = xTaskCreate(	prvIdleTask,
000002  4814              LDR      r0,|L32.84|
000004  2100              MOVS     r1,#0
000006  460b              MOV      r3,r1
000008  2280              MOVS     r2,#0x80
00000a  e9cd1000          STRD     r1,r0,[sp,#0]
00000e  a112              ADR      r1,|L32.88|
000010  4813              LDR      r0,|L32.96|
000012  f7fffffe          BL       xTaskCreate
000016  4604              MOV      r4,r0
;;;1860   								"IDLE", configMINIMAL_STACK_SIZE,
;;;1861   								( void * ) NULL,
;;;1862   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1863   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1864   	}
;;;1865   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1866   
;;;1867   	#if ( configUSE_TIMERS == 1 )
;;;1868   	{
;;;1869   		if( xReturn == pdPASS )
000018  2c01              CMP      r4,#1
00001a  d102              BNE      |L32.34|
;;;1870   		{
;;;1871   			xReturn = xTimerCreateTimerTask();
00001c  f7fffffe          BL       xTimerCreateTimerTask
000020  4604              MOV      r4,r0
                  |L32.34|
;;;1872   		}
;;;1873   		else
;;;1874   		{
;;;1875   			mtCOVERAGE_TEST_MARKER();
;;;1876   		}
;;;1877   	}
;;;1878   	#endif /* configUSE_TIMERS */
;;;1879   
;;;1880   	if( xReturn == pdPASS )
000022  2c01              CMP      r4,#1
000024  d114              BNE      |L32.80|
;;;1881   	{
;;;1882   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1883   		before or during the call to xPortStartScheduler().  The stacks of
;;;1884   		the created tasks contain a status word with interrupts switched on
;;;1885   		so interrupts will automatically get re-enabled when the first task
;;;1886   		starts to run. */
;;;1887   		portDISABLE_INTERRUPTS();
000026  bf00              NOP      
000028  20bf              MOVS     r0,#0xbf
00002a  f3808811          MSR      BASEPRI,r0
00002e  f3bf8f4f          DSB      
000032  f3bf8f6f          ISB      
000036  bf00              NOP      
;;;1888   
;;;1889   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1890   		{
;;;1891   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1892   			structure specific to the task that will run first. */
;;;1893   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1894   		}
;;;1895   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1896   
;;;1897   		xNextTaskUnblockTime = portMAX_DELAY;
000038  f04f30ff          MOV      r0,#0xffffffff
00003c  4909              LDR      r1,|L32.100|
00003e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;1898   		xSchedulerRunning = pdTRUE;
000040  2001              MOVS     r0,#1
000042  4909              LDR      r1,|L32.104|
000044  6008              STR      r0,[r1,#0]  ; xSchedulerRunning
;;;1899   		xTickCount = ( TickType_t ) 0U;
000046  2000              MOVS     r0,#0
000048  4908              LDR      r1,|L32.108|
00004a  6008              STR      r0,[r1,#0]  ; xTickCount
;;;1900   
;;;1901   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1902   		macro must be defined to configure the timer/counter used to generate
;;;1903   		the run time counter time base. */
;;;1904   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1905   
;;;1906   		/* Setting up the timer tick is hardware specific and thus in the
;;;1907   		portable interface. */
;;;1908   		if( xPortStartScheduler() != pdFALSE )
00004c  f7fffffe          BL       xPortStartScheduler
                  |L32.80|
;;;1909   		{
;;;1910   			/* Should not reach here as if the scheduler is running the
;;;1911   			function will not return. */
;;;1912   		}
;;;1913   		else
;;;1914   		{
;;;1915   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1916   		}
;;;1917   	}
;;;1918   	else
;;;1919   	{
;;;1920   		/* This line will only be reached if the kernel could not be started,
;;;1921   		because there was not enough FreeRTOS heap to create the idle task
;;;1922   		or the timer task. */
;;;1923   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
;;;1924   	}
;;;1925   
;;;1926   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;1927   	meaning xIdleTaskHandle is not used anywhere else. */
;;;1928   	( void ) xIdleTaskHandle;
;;;1929   }
000050  bd1c              POP      {r2-r4,pc}
;;;1930   /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L32.84|
                          DCD      xIdleTaskHandle
                  |L32.88|
000058  49444c45          DCB      "IDLE",0
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L32.96|
                          DCD      prvIdleTask
                  |L32.100|
                          DCD      xNextTaskUnblockTime
                  |L32.104|
                          DCD      xSchedulerRunning
                  |L32.108|
                          DCD      xTickCount

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1564   
;;;1565   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1566   	{
000002  4605              MOV      r5,r0
;;;1567   	TCB_t *pxTCB;
;;;1568   
;;;1569   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1570   		{
;;;1571   			/* If null is passed in here then it is the running task that is
;;;1572   			being suspended. */
;;;1573   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  b915              CBNZ     r5,|L33.16|
00000a  481d              LDR      r0,|L33.128|
00000c  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000e  e000              B        |L33.18|
                  |L33.16|
000010  4628              MOV      r0,r5
                  |L33.18|
000012  4604              MOV      r4,r0
;;;1574   
;;;1575   			traceTASK_SUSPEND( pxTCB );
;;;1576   
;;;1577   			/* Remove task from the ready/delayed list and place in the
;;;1578   			suspended list. */
;;;1579   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000014  1d20              ADDS     r0,r4,#4
000016  f7fffffe          BL       uxListRemove
;;;1580   			{
;;;1581   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1582   			}
;;;1583   			else
;;;1584   			{
;;;1585   				mtCOVERAGE_TEST_MARKER();
;;;1586   			}
;;;1587   
;;;1588   			/* Is the task waiting on an event also? */
;;;1589   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00001a  6aa0              LDR      r0,[r4,#0x28]
00001c  b118              CBZ      r0,|L33.38|
;;;1590   			{
;;;1591   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001e  f1040018          ADD      r0,r4,#0x18
000022  f7fffffe          BL       uxListRemove
                  |L33.38|
;;;1592   			}
;;;1593   			else
;;;1594   			{
;;;1595   				mtCOVERAGE_TEST_MARKER();
;;;1596   			}
;;;1597   
;;;1598   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000026  1d21              ADDS     r1,r4,#4
000028  4816              LDR      r0,|L33.132|
00002a  f7fffffe          BL       vListInsertEnd
;;;1599   		}
;;;1600   		taskEXIT_CRITICAL();
00002e  f7fffffe          BL       vPortExitCritical
;;;1601   
;;;1602   		if( xSchedulerRunning != pdFALSE )
000032  4815              LDR      r0,|L33.136|
000034  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000036  b128              CBZ      r0,|L33.68|
;;;1603   		{
;;;1604   			/* Reset the next expected unblock time in case it referred to the
;;;1605   			task that is now in the Suspended state. */
;;;1606   			taskENTER_CRITICAL();
000038  f7fffffe          BL       vPortEnterCritical
;;;1607   			{
;;;1608   				prvResetNextTaskUnblockTime();
00003c  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1609   			}
;;;1610   			taskEXIT_CRITICAL();
000040  f7fffffe          BL       vPortExitCritical
                  |L33.68|
;;;1611   		}
;;;1612   		else
;;;1613   		{
;;;1614   			mtCOVERAGE_TEST_MARKER();
;;;1615   		}
;;;1616   
;;;1617   		if( pxTCB == pxCurrentTCB )
000044  480e              LDR      r0,|L33.128|
000046  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000048  4284              CMP      r4,r0
00004a  d117              BNE      |L33.124|
;;;1618   		{
;;;1619   			if( xSchedulerRunning != pdFALSE )
00004c  480e              LDR      r0,|L33.136|
00004e  6800              LDR      r0,[r0,#0]  ; xSchedulerRunning
000050  b140              CBZ      r0,|L33.100|
;;;1620   			{
;;;1621   				/* The current task has just been suspended. */
;;;1622   				configASSERT( uxSchedulerSuspended == 0 );
;;;1623   				portYIELD_WITHIN_API();
000052  f04f5080          MOV      r0,#0x10000000
000056  490d              LDR      r1,|L33.140|
000058  6008              STR      r0,[r1,#0]
00005a  f3bf8f4f          DSB      
00005e  f3bf8f6f          ISB      
000062  e00b              B        |L33.124|
                  |L33.100|
;;;1624   			}
;;;1625   			else
;;;1626   			{
;;;1627   				/* The scheduler is not running, but the task that was pointed
;;;1628   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1629   				must be adjusted to point to a different task. */
;;;1630   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
000064  4807              LDR      r0,|L33.132|
000066  6800              LDR      r0,[r0,#0]  ; xSuspendedTaskList
000068  4909              LDR      r1,|L33.144|
00006a  6809              LDR      r1,[r1,#0]  ; uxCurrentNumberOfTasks
00006c  4288              CMP      r0,r1
00006e  d103              BNE      |L33.120|
;;;1631   				{
;;;1632   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1633   					NULL so when the next task is created pxCurrentTCB will
;;;1634   					be set to point to it no matter what its relative priority
;;;1635   					is. */
;;;1636   					pxCurrentTCB = NULL;
000070  2000              MOVS     r0,#0
000072  4903              LDR      r1,|L33.128|
000074  6008              STR      r0,[r1,#0]  ; pxCurrentTCB
000076  e001              B        |L33.124|
                  |L33.120|
;;;1637   				}
;;;1638   				else
;;;1639   				{
;;;1640   					vTaskSwitchContext();
000078  f7fffffe          BL       vTaskSwitchContext
                  |L33.124|
;;;1641   				}
;;;1642   			}
;;;1643   		}
;;;1644   		else
;;;1645   		{
;;;1646   			mtCOVERAGE_TEST_MARKER();
;;;1647   		}
;;;1648   	}
00007c  bd70              POP      {r4-r6,pc}
;;;1649   
                          ENDP

00007e  0000              DCW      0x0000
                  |L33.128|
                          DCD      pxCurrentTCB
                  |L33.132|
                          DCD      xSuspendedTaskList
                  |L33.136|
                          DCD      xSchedulerRunning
                  |L33.140|
                          DCD      0xe000ed04
                  |L33.144|
                          DCD      uxCurrentNumberOfTasks

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;1942   
;;;1943   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L34.12|
;;;1944   {
;;;1945   	/* A critical section is not required as the variable is of type
;;;1946   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1947   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1948   	http://goo.gl/wu4acr */
;;;1949   	++uxSchedulerSuspended;
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  1c40              ADDS     r0,r0,#1
000006  4901              LDR      r1,|L34.12|
000008  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;1950   }
00000a  4770              BX       lr
;;;1951   /*----------------------------------------------------------*/
                          ENDP

                  |L34.12|
                          DCD      uxSchedulerSuspended

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2759   
;;;2760   void vTaskSwitchContext( void )
000000  4818              LDR      r0,|L35.100|
;;;2761   {
;;;2762   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000004  b118              CBZ      r0,|L35.14|
;;;2763   	{
;;;2764   		/* The scheduler is currently suspended - do not allow a context
;;;2765   		switch. */
;;;2766   		xYieldPending = pdTRUE;
000006  2001              MOVS     r0,#1
000008  4917              LDR      r1,|L35.104|
00000a  6008              STR      r0,[r1,#0]  ; xYieldPending
00000c  e028              B        |L35.96|
                  |L35.14|
;;;2767   	}
;;;2768   	else
;;;2769   	{
;;;2770   		xYieldPending = pdFALSE;
00000e  2000              MOVS     r0,#0
000010  4915              LDR      r1,|L35.104|
000012  6008              STR      r0,[r1,#0]  ; xYieldPending
;;;2771   		traceTASK_SWITCHED_OUT();
;;;2772   
;;;2773   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2774   		{
;;;2775   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2776   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2777   				#else
;;;2778   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2779   				#endif
;;;2780   
;;;2781   				/* Add the amount of time the task has been running to the
;;;2782   				accumulated time so far.  The time the task started running was
;;;2783   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2784   				protection here so count values are only valid until the timer
;;;2785   				overflows.  The guard against negative values is to protect
;;;2786   				against suspect run time stat counter implementations - which
;;;2787   				are provided by the application, not the kernel. */
;;;2788   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2789   				{
;;;2790   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2791   				}
;;;2792   				else
;;;2793   				{
;;;2794   					mtCOVERAGE_TEST_MARKER();
;;;2795   				}
;;;2796   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2797   		}
;;;2798   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2799   
;;;2800   		/* Check for stack overflow, if configured. */
;;;2801   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2802   
;;;2803   		/* Select a new task to run using either the generic C or port
;;;2804   		optimised asm code. */
;;;2805   		taskSELECT_HIGHEST_PRIORITY_TASK();
000014  4815              LDR      r0,|L35.108|
000016  6801              LDR      r1,[r0,#0]  ; uxTopReadyPriority
000018  e000              B        |L35.28|
                  |L35.26|
00001a  1e49              SUBS     r1,r1,#1
                  |L35.28|
00001c  eb010081          ADD      r0,r1,r1,LSL #2
000020  4a13              LDR      r2,|L35.112|
000022  f8520020          LDR      r0,[r2,r0,LSL #2]
000026  b908              CBNZ     r0,|L35.44|
000028  2001              MOVS     r0,#1
00002a  e000              B        |L35.46|
                  |L35.44|
00002c  2000              MOVS     r0,#0
                  |L35.46|
00002e  2800              CMP      r0,#0
000030  d1f3              BNE      |L35.26|
000032  eb010281          ADD      r2,r1,r1,LSL #2
000036  4b0e              LDR      r3,|L35.112|
000038  eb030082          ADD      r0,r3,r2,LSL #2
00003c  6842              LDR      r2,[r0,#4]
00003e  6852              LDR      r2,[r2,#4]
000040  6042              STR      r2,[r0,#4]
000042  f1000208          ADD      r2,r0,#8
000046  6843              LDR      r3,[r0,#4]
000048  4293              CMP      r3,r2
00004a  d102              BNE      |L35.82|
00004c  6842              LDR      r2,[r0,#4]
00004e  6852              LDR      r2,[r2,#4]
000050  6042              STR      r2,[r0,#4]
                  |L35.82|
000052  6842              LDR      r2,[r0,#4]
000054  68d2              LDR      r2,[r2,#0xc]
000056  4b07              LDR      r3,|L35.116|
000058  601a              STR      r2,[r3,#0]  ; pxCurrentTCB
00005a  4804              LDR      r0,|L35.108|
00005c  6001              STR      r1,[r0,#0]  ; uxTopReadyPriority
00005e  bf00              NOP      
                  |L35.96|
;;;2806   		traceTASK_SWITCHED_IN();
;;;2807   
;;;2808   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2809   		{
;;;2810   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2811   			structure specific to this task. */
;;;2812   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2813   		}
;;;2814   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2815   	}
;;;2816   }
000060  4770              BX       lr
;;;2817   /*-----------------------------------------------------------*/
                          ENDP

000062  0000              DCW      0x0000
                  |L35.100|
                          DCD      uxSchedulerSuspended
                  |L35.104|
                          DCD      xYieldPending
                  |L35.108|
                          DCD      uxTopReadyPriority
                  |L35.112|
                          DCD      pxReadyTasksLists
                  |L35.116|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3013   
;;;3014   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;3015   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;3016   BaseType_t xReturn;
;;;3017   
;;;3018   	configASSERT( pxTimeOut );
;;;3019   	configASSERT( pxTicksToWait );
;;;3020   
;;;3021   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;3022   	{
;;;3023   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3024   		const TickType_t xConstTickCount = xTickCount;
00000a  4812              LDR      r0,|L36.84|
00000c  6802              LDR      r2,[r0,#0]  ; xTickCount
;;;3025   
;;;3026   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3027   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3028   			{
;;;3029   				/* The delay was aborted, which is not the same as a time out,
;;;3030   				but has the same result. */
;;;3031   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3032   				xReturn = pdTRUE;
;;;3033   			}
;;;3034   			else
;;;3035   		#endif
;;;3036   
;;;3037   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3038   			if( *pxTicksToWait == portMAX_DELAY )
00000e  6828              LDR      r0,[r5,#0]
000010  1c40              ADDS     r0,r0,#1
000012  b908              CBNZ     r0,|L36.24|
;;;3039   			{
;;;3040   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3041   				specified is the maximum block time then the task should block
;;;3042   				indefinitely, and therefore never time out. */
;;;3043   				xReturn = pdFALSE;
000014  2600              MOVS     r6,#0
000016  e019              B        |L36.76|
                  |L36.24|
;;;3044   			}
;;;3045   			else
;;;3046   		#endif
;;;3047   
;;;3048   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000018  490f              LDR      r1,|L36.88|
00001a  6820              LDR      r0,[r4,#0]
00001c  6809              LDR      r1,[r1,#0]  ; xNumOfOverflows
00001e  4288              CMP      r0,r1
000020  d004              BEQ      |L36.44|
000022  6860              LDR      r0,[r4,#4]
000024  4290              CMP      r0,r2
000026  d801              BHI      |L36.44|
;;;3049   		{
;;;3050   			/* The tick count is greater than the time at which
;;;3051   			vTaskSetTimeout() was called, but has also overflowed since
;;;3052   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3053   			around and gone past again. This passed since vTaskSetTimeout()
;;;3054   			was called. */
;;;3055   			xReturn = pdTRUE;
000028  2601              MOVS     r6,#1
00002a  e00f              B        |L36.76|
                  |L36.44|
;;;3056   		}
;;;3057   		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
00002c  6860              LDR      r0,[r4,#4]
00002e  1a10              SUBS     r0,r2,r0
000030  6829              LDR      r1,[r5,#0]
000032  4288              CMP      r0,r1
000034  d209              BCS      |L36.74|
;;;3058   		{
;;;3059   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3060   			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
000036  6828              LDR      r0,[r5,#0]
000038  6861              LDR      r1,[r4,#4]
00003a  1a51              SUBS     r1,r2,r1
00003c  1a40              SUBS     r0,r0,r1
00003e  6028              STR      r0,[r5,#0]
;;;3061   			vTaskSetTimeOutState( pxTimeOut );
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       vTaskSetTimeOutState
;;;3062   			xReturn = pdFALSE;
000046  2600              MOVS     r6,#0
000048  e000              B        |L36.76|
                  |L36.74|
;;;3063   		}
;;;3064   		else
;;;3065   		{
;;;3066   			xReturn = pdTRUE;
00004a  2601              MOVS     r6,#1
                  |L36.76|
;;;3067   		}
;;;3068   	}
;;;3069   	taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;3070   
;;;3071   	return xReturn;
000050  4630              MOV      r0,r6
;;;3072   }
000052  bd70              POP      {r4-r6,pc}
;;;3073   /*-----------------------------------------------------------*/
                          ENDP

                  |L36.84|
                          DCD      xTickCount
                  |L36.88|
                          DCD      xNumOfOverflows

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;674    
;;;675    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;676    							const char * const pcName,
;;;677    							const uint16_t usStackDepth,
;;;678    							void * const pvParameters,
;;;679    							UBaseType_t uxPriority,
;;;680    							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;681    	{
000004  b085              SUB      sp,sp,#0x14
000006  4680              MOV      r8,r0
000008  4689              MOV      r9,r1
00000a  4617              MOV      r7,r2
00000c  e9ddab12          LDRD     r10,r11,[sp,#0x48]
;;;682    	TCB_t *pxNewTCB;
;;;683    	BaseType_t xReturn;
;;;684    
;;;685    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;686    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;687    		the TCB then the stack. */
;;;688    		#if( portSTACK_GROWTH > 0 )
;;;689    		{
;;;690    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;691    			the implementation of the port malloc function and whether or not static
;;;692    			allocation is being used. */
;;;693    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;694    
;;;695    			if( pxNewTCB != NULL )
;;;696    			{
;;;697    				/* Allocate space for the stack used by the task being created.
;;;698    				The base of the stack memory stored in the TCB so the task can
;;;699    				be deleted later if required. */
;;;700    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;701    
;;;702    				if( pxNewTCB->pxStack == NULL )
;;;703    				{
;;;704    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;705    					vPortFree( pxNewTCB );
;;;706    					pxNewTCB = NULL;
;;;707    				}
;;;708    			}
;;;709    		}
;;;710    		#else /* portSTACK_GROWTH */
;;;711    		{
;;;712    		StackType_t *pxStack;
;;;713    
;;;714    			/* Allocate space for the stack used by the task being created. */
;;;715    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000010  00b8              LSLS     r0,r7,#2
000012  f7fffffe          BL       pvPortMalloc
000016  4606              MOV      r6,r0
;;;716    
;;;717    			if( pxStack != NULL )
000018  b156              CBZ      r6,|L37.48|
;;;718    			{
;;;719    				/* Allocate space for the TCB. */
;;;720    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
00001a  2068              MOVS     r0,#0x68
00001c  f7fffffe          BL       pvPortMalloc
000020  4604              MOV      r4,r0
;;;721    
;;;722    				if( pxNewTCB != NULL )
000022  b10c              CBZ      r4,|L37.40|
;;;723    				{
;;;724    					/* Store the stack location in the TCB. */
;;;725    					pxNewTCB->pxStack = pxStack;
000024  6326              STR      r6,[r4,#0x30]
000026  e004              B        |L37.50|
                  |L37.40|
;;;726    				}
;;;727    				else
;;;728    				{
;;;729    					/* The stack cannot be used as the TCB was not created.  Free
;;;730    					it again. */
;;;731    					vPortFree( pxStack );
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       vPortFree
00002e  e000              B        |L37.50|
                  |L37.48|
;;;732    				}
;;;733    			}
;;;734    			else
;;;735    			{
;;;736    				pxNewTCB = NULL;
000030  2400              MOVS     r4,#0
                  |L37.50|
;;;737    			}
;;;738    		}
;;;739    		#endif /* portSTACK_GROWTH */
;;;740    
;;;741    		if( pxNewTCB != NULL )
000032  b17c              CBZ      r4,|L37.84|
;;;742    		{
;;;743    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;;;744    			{
;;;745    				/* Tasks can be created statically or dynamically, so note this
;;;746    				task was created dynamically in case it is later deleted. */
;;;747    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;748    			}
;;;749    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;750    
;;;751    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000034  2000              MOVS     r0,#0
000036  e9cdab00          STRD     r10,r11,[sp,#0]
00003a  e9cd4002          STRD     r4,r0,[sp,#8]
00003e  463a              MOV      r2,r7
000040  4649              MOV      r1,r9
000042  4640              MOV      r0,r8
000044  9b08              LDR      r3,[sp,#0x20]
000046  f7fffffe          BL       prvInitialiseNewTask
;;;752    			prvAddNewTaskToReadyList( pxNewTCB );
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       prvAddNewTaskToReadyList
;;;753    			xReturn = pdPASS;
000050  2501              MOVS     r5,#1
000052  e001              B        |L37.88|
                  |L37.84|
;;;754    		}
;;;755    		else
;;;756    		{
;;;757    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
000054  f04f35ff          MOV      r5,#0xffffffff
                  |L37.88|
;;;758    		}
;;;759    
;;;760    		return xReturn;
000058  4628              MOV      r0,r5
;;;761    	}
00005a  b009              ADD      sp,sp,#0x24
00005c  e8bd8ff0          POP      {r4-r11,pc}
;;;762    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4341   
;;;4342   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;4343   	{
000004  4681              MOV      r9,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;4344   	TCB_t * pxTCB;
;;;4345   	BaseType_t xReturn = pdPASS;
00000c  f04f0a01          MOV      r10,#1
;;;4346   	uint8_t ucOriginalNotifyState;
;;;4347   
;;;4348   		configASSERT( xTaskToNotify );
;;;4349   		pxTCB = ( TCB_t * ) xTaskToNotify;
000010  464c              MOV      r4,r9
;;;4350   
;;;4351   		taskENTER_CRITICAL();
000012  f7fffffe          BL       vPortEnterCritical
;;;4352   		{
;;;4353   			if( pulPreviousNotificationValue != NULL )
000016  b10f              CBZ      r7,|L38.28|
;;;4354   			{
;;;4355   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000018  6e20              LDR      r0,[r4,#0x60]
00001a  6038              STR      r0,[r7,#0]
                  |L38.28|
;;;4356   			}
;;;4357   
;;;4358   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001c  f8948064          LDRB     r8,[r4,#0x64]
;;;4359   
;;;4360   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000020  2002              MOVS     r0,#2
000022  f8840064          STRB     r0,[r4,#0x64]
;;;4361   
;;;4362   			switch( eAction )
000026  2e05              CMP      r6,#5
000028  d217              BCS      |L38.90|
00002a  e8dff006          TBB      [pc,r6]
00002e  1503              DCB      0x15,0x03
000030  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4363   			{
;;;4364   				case eSetBits	:
;;;4365   					pxTCB->ulNotifiedValue |= ulValue;
000034  6e20              LDR      r0,[r4,#0x60]
000036  4328              ORRS     r0,r0,r5
000038  6620              STR      r0,[r4,#0x60]
;;;4366   					break;
00003a  e00e              B        |L38.90|
;;;4367   
;;;4368   				case eIncrement	:
;;;4369   					( pxTCB->ulNotifiedValue )++;
00003c  6e20              LDR      r0,[r4,#0x60]
00003e  1c40              ADDS     r0,r0,#1
000040  6620              STR      r0,[r4,#0x60]
;;;4370   					break;
000042  e00a              B        |L38.90|
;;;4371   
;;;4372   				case eSetValueWithOverwrite	:
;;;4373   					pxTCB->ulNotifiedValue = ulValue;
000044  6625              STR      r5,[r4,#0x60]
;;;4374   					break;
000046  e008              B        |L38.90|
;;;4375   
;;;4376   				case eSetValueWithoutOverwrite :
;;;4377   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000048  f1b80f02          CMP      r8,#2
00004c  d001              BEQ      |L38.82|
;;;4378   					{
;;;4379   						pxTCB->ulNotifiedValue = ulValue;
00004e  6625              STR      r5,[r4,#0x60]
000050  e001              B        |L38.86|
                  |L38.82|
;;;4380   					}
;;;4381   					else
;;;4382   					{
;;;4383   						/* The value could not be written to the task. */
;;;4384   						xReturn = pdFAIL;
000052  f04f0a00          MOV      r10,#0
                  |L38.86|
;;;4385   					}
;;;4386   					break;
000056  e000              B        |L38.90|
;;;4387   
;;;4388   				case eNoAction:
;;;4389   					/* The task is being notified without its notify value being
;;;4390   					updated. */
;;;4391   					break;
000058  bf00              NOP      
                  |L38.90|
00005a  bf00              NOP                            ;4366
;;;4392   			}
;;;4393   
;;;4394   			traceTASK_NOTIFY();
;;;4395   
;;;4396   			/* If the task is in the blocked state specifically to wait for a
;;;4397   			notification then unblock it now. */
;;;4398   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00005c  f1b80f01          CMP      r8,#1
000060  d121              BNE      |L38.166|
;;;4399   			{
;;;4400   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       uxListRemove
;;;4401   				prvAddTaskToReadyList( pxTCB );
000068  4911              LDR      r1,|L38.176|
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00006e  4288              CMP      r0,r1
000070  d902              BLS      |L38.120|
000072  490f              LDR      r1,|L38.176|
000074  6ae0              LDR      r0,[r4,#0x2c]
000076  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L38.120|
000078  6ae1              LDR      r1,[r4,#0x2c]
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  4a0d              LDR      r2,|L38.180|
000080  eb020081          ADD      r0,r2,r1,LSL #2
000084  1d21              ADDS     r1,r4,#4
000086  f7fffffe          BL       vListInsertEnd
;;;4402   
;;;4403   				/* The task should not have been on an event list. */
;;;4404   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4405   
;;;4406   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4407   				{
;;;4408   					/* If a task is blocked waiting for a notification then
;;;4409   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4410   					out time.  If the task is unblocked for a reason other than
;;;4411   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4412   					because it will automatically get reset to a new value when
;;;4413   					the tick count equals xNextTaskUnblockTime.  However if
;;;4414   					tickless idling is used it might be more important to enter
;;;4415   					sleep mode at the earliest possible time - so reset
;;;4416   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4417   					earliest possible time. */
;;;4418   					prvResetNextTaskUnblockTime();
;;;4419   				}
;;;4420   				#endif
;;;4421   
;;;4422   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00008a  490b              LDR      r1,|L38.184|
00008c  6ae0              LDR      r0,[r4,#0x2c]
00008e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000090  6ac9              LDR      r1,[r1,#0x2c]
000092  4288              CMP      r0,r1
000094  d907              BLS      |L38.166|
;;;4423   				{
;;;4424   					/* The notified task has a priority above the currently
;;;4425   					executing task so a yield is required. */
;;;4426   					taskYIELD_IF_USING_PREEMPTION();
000096  f04f5080          MOV      r0,#0x10000000
00009a  4908              LDR      r1,|L38.188|
00009c  6008              STR      r0,[r1,#0]
00009e  f3bf8f4f          DSB      
0000a2  f3bf8f6f          ISB      
                  |L38.166|
;;;4427   				}
;;;4428   				else
;;;4429   				{
;;;4430   					mtCOVERAGE_TEST_MARKER();
;;;4431   				}
;;;4432   			}
;;;4433   			else
;;;4434   			{
;;;4435   				mtCOVERAGE_TEST_MARKER();
;;;4436   			}
;;;4437   		}
;;;4438   		taskEXIT_CRITICAL();
0000a6  f7fffffe          BL       vPortExitCritical
;;;4439   
;;;4440   		return xReturn;
0000aa  4650              MOV      r0,r10
;;;4441   	}
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;4442   
                          ENDP

                  |L38.176|
                          DCD      uxTopReadyPriority
                  |L38.180|
                          DCD      pxReadyTasksLists
                  |L38.184|
                          DCD      pxCurrentTCB
                  |L38.188|
                          DCD      0xe000ed04

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4447   
;;;4448   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;4449   	{
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
00000c  f8ddb028          LDR      r11,[sp,#0x28]
;;;4450   	TCB_t * pxTCB;
;;;4451   	uint8_t ucOriginalNotifyState;
;;;4452   	BaseType_t xReturn = pdPASS;
000010  2001              MOVS     r0,#1
000012  9000              STR      r0,[sp,#0]
;;;4453   	UBaseType_t uxSavedInterruptStatus;
;;;4454   
;;;4455   		configASSERT( xTaskToNotify );
;;;4456   
;;;4457   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4458   		maximum	system call (or maximum API call) interrupt priority.
;;;4459   		Interrupts that are	above the maximum system call priority are keep
;;;4460   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4461   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4462   		is defined in FreeRTOSConfig.h then
;;;4463   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4464   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4465   		been assigned a priority above the configured maximum system call
;;;4466   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4467   		from interrupts	that have been assigned a priority at or (logically)
;;;4468   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4469   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4470   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4471   		provided on the following link:
;;;4472   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4473   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4474   
;;;4475   		pxTCB = ( TCB_t * ) xTaskToNotify;
000014  4654              MOV      r4,r10
;;;4476   
;;;4477   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000016  bf00              NOP      
000018  21bf              MOVS     r1,#0xbf
00001a  f3ef8011          MRS      r0,BASEPRI
00001e  f3818811          MSR      BASEPRI,r1
000022  f3bf8f4f          DSB      
000026  f3bf8f6f          ISB      
00002a  bf00              NOP      
00002c  4681              MOV      r9,r0
;;;4478   		{
;;;4479   			if( pulPreviousNotificationValue != NULL )
00002e  b10f              CBZ      r7,|L39.52|
;;;4480   			{
;;;4481   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000030  6e20              LDR      r0,[r4,#0x60]
000032  6038              STR      r0,[r7,#0]
                  |L39.52|
;;;4482   			}
;;;4483   
;;;4484   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000034  f8948064          LDRB     r8,[r4,#0x64]
;;;4485   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000038  2002              MOVS     r0,#2
00003a  f8840064          STRB     r0,[r4,#0x64]
;;;4486   
;;;4487   			switch( eAction )
00003e  2e05              CMP      r6,#5
000040  d217              BCS      |L39.114|
000042  e8dff006          TBB      [pc,r6]
000046  1503              DCB      0x15,0x03
000048  070b0d00          DCB      0x07,0x0b,0x0d,0x00
;;;4488   			{
;;;4489   				case eSetBits	:
;;;4490   					pxTCB->ulNotifiedValue |= ulValue;
00004c  6e20              LDR      r0,[r4,#0x60]
00004e  4328              ORRS     r0,r0,r5
000050  6620              STR      r0,[r4,#0x60]
;;;4491   					break;
000052  e00e              B        |L39.114|
;;;4492   
;;;4493   				case eIncrement	:
;;;4494   					( pxTCB->ulNotifiedValue )++;
000054  6e20              LDR      r0,[r4,#0x60]
000056  1c40              ADDS     r0,r0,#1
000058  6620              STR      r0,[r4,#0x60]
;;;4495   					break;
00005a  e00a              B        |L39.114|
;;;4496   
;;;4497   				case eSetValueWithOverwrite	:
;;;4498   					pxTCB->ulNotifiedValue = ulValue;
00005c  6625              STR      r5,[r4,#0x60]
;;;4499   					break;
00005e  e008              B        |L39.114|
;;;4500   
;;;4501   				case eSetValueWithoutOverwrite :
;;;4502   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000060  f1b80f02          CMP      r8,#2
000064  d001              BEQ      |L39.106|
;;;4503   					{
;;;4504   						pxTCB->ulNotifiedValue = ulValue;
000066  6625              STR      r5,[r4,#0x60]
000068  e001              B        |L39.110|
                  |L39.106|
;;;4505   					}
;;;4506   					else
;;;4507   					{
;;;4508   						/* The value could not be written to the task. */
;;;4509   						xReturn = pdFAIL;
00006a  2000              MOVS     r0,#0
00006c  9000              STR      r0,[sp,#0]
                  |L39.110|
;;;4510   					}
;;;4511   					break;
00006e  e000              B        |L39.114|
;;;4512   
;;;4513   				case eNoAction :
;;;4514   					/* The task is being notified without its notify value being
;;;4515   					updated. */
;;;4516   					break;
000070  bf00              NOP      
                  |L39.114|
000072  bf00              NOP                            ;4491
;;;4517   			}
;;;4518   
;;;4519   			traceTASK_NOTIFY_FROM_ISR();
;;;4520   
;;;4521   			/* If the task is in the blocked state specifically to wait for a
;;;4522   			notification then unblock it now. */
;;;4523   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000074  f1b80f01          CMP      r8,#1
000078  d12c              BNE      |L39.212|
;;;4524   			{
;;;4525   				/* The task should not have been on an event list. */
;;;4526   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4527   
;;;4528   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00007a  481a              LDR      r0,|L39.228|
00007c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00007e  b9a0              CBNZ     r0,|L39.170|
;;;4529   				{
;;;4530   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000080  1d20              ADDS     r0,r4,#4
000082  f7fffffe          BL       uxListRemove
;;;4531   					prvAddTaskToReadyList( pxTCB );
000086  4918              LDR      r1,|L39.232|
000088  6ae0              LDR      r0,[r4,#0x2c]
00008a  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008c  4288              CMP      r0,r1
00008e  d902              BLS      |L39.150|
000090  4915              LDR      r1,|L39.232|
000092  6ae0              LDR      r0,[r4,#0x2c]
000094  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L39.150|
000096  6ae1              LDR      r1,[r4,#0x2c]
000098  eb010181          ADD      r1,r1,r1,LSL #2
00009c  4a13              LDR      r2,|L39.236|
00009e  eb020081          ADD      r0,r2,r1,LSL #2
0000a2  1d21              ADDS     r1,r4,#4
0000a4  f7fffffe          BL       vListInsertEnd
0000a8  e004              B        |L39.180|
                  |L39.170|
;;;4532   				}
;;;4533   				else
;;;4534   				{
;;;4535   					/* The delayed and ready lists cannot be accessed, so hold
;;;4536   					this task pending until the scheduler is resumed. */
;;;4537   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0000aa  f1040118          ADD      r1,r4,#0x18
0000ae  4810              LDR      r0,|L39.240|
0000b0  f7fffffe          BL       vListInsertEnd
                  |L39.180|
;;;4538   				}
;;;4539   
;;;4540   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
0000b4  490f              LDR      r1,|L39.244|
0000b6  6ae0              LDR      r0,[r4,#0x2c]
0000b8  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000ba  6ac9              LDR      r1,[r1,#0x2c]
0000bc  4288              CMP      r0,r1
0000be  d909              BLS      |L39.212|
;;;4541   				{
;;;4542   					/* The notified task has a priority above the currently
;;;4543   					executing task so a yield is required. */
;;;4544   					if( pxHigherPriorityTaskWoken != NULL )
0000c0  f1bb0f00          CMP      r11,#0
0000c4  d003              BEQ      |L39.206|
;;;4545   					{
;;;4546   						*pxHigherPriorityTaskWoken = pdTRUE;
0000c6  2001              MOVS     r0,#1
0000c8  f8cb0000          STR      r0,[r11,#0]
0000cc  e002              B        |L39.212|
                  |L39.206|
;;;4547   					}
;;;4548   					else
;;;4549   					{
;;;4550   						/* Mark that a yield is pending in case the user is not
;;;4551   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4552   						safe FreeRTOS function. */
;;;4553   						xYieldPending = pdTRUE;
0000ce  2001              MOVS     r0,#1
0000d0  4909              LDR      r1,|L39.248|
0000d2  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L39.212|
;;;4554   					}
;;;4555   				}
;;;4556   				else
;;;4557   				{
;;;4558   					mtCOVERAGE_TEST_MARKER();
;;;4559   				}
;;;4560   			}
;;;4561   		}
;;;4562   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000d4  bf00              NOP      
0000d6  f3898811          MSR      BASEPRI,r9
0000da  bf00              NOP      
;;;4563   
;;;4564   		return xReturn;
0000dc  9800              LDR      r0,[sp,#0]
;;;4565   	}
0000de  e8bd8ff8          POP      {r3-r11,pc}
;;;4566   
                          ENDP

0000e2  0000              DCW      0x0000
                  |L39.228|
                          DCD      uxSchedulerSuspended
                  |L39.232|
                          DCD      uxTopReadyPriority
                  |L39.236|
                          DCD      pxReadyTasksLists
                  |L39.240|
                          DCD      xPendingReadyList
                  |L39.244|
                          DCD      pxCurrentTCB
                  |L39.248|
                          DCD      xYieldPending

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3659   
;;;3660   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4901              LDR      r1,|L40.8|
;;;3661   	{
;;;3662   	TaskHandle_t xReturn;
;;;3663   
;;;3664   		/* A critical section is not required as this is not called from
;;;3665   		an interrupt and the current TCB will always be the same for any
;;;3666   		individual execution thread. */
;;;3667   		xReturn = pxCurrentTCB;
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;3668   
;;;3669   		return xReturn;
;;;3670   	}
000004  4770              BX       lr
;;;3671   
                          ENDP

000006  0000              DCW      0x0000
                  |L40.8|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3676   
;;;3677   	BaseType_t xTaskGetSchedulerState( void )
000000  4905              LDR      r1,|L41.24|
;;;3678   	{
;;;3679   	BaseType_t xReturn;
;;;3680   
;;;3681   		if( xSchedulerRunning == pdFALSE )
000002  6809              LDR      r1,[r1,#0]  ; xSchedulerRunning
000004  b909              CBNZ     r1,|L41.10|
;;;3682   		{
;;;3683   			xReturn = taskSCHEDULER_NOT_STARTED;
000006  2001              MOVS     r0,#1
000008  e005              B        |L41.22|
                  |L41.10|
;;;3684   		}
;;;3685   		else
;;;3686   		{
;;;3687   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00000a  4904              LDR      r1,|L41.28|
00000c  6809              LDR      r1,[r1,#0]  ; uxSchedulerSuspended
00000e  b909              CBNZ     r1,|L41.20|
;;;3688   			{
;;;3689   				xReturn = taskSCHEDULER_RUNNING;
000010  2002              MOVS     r0,#2
000012  e000              B        |L41.22|
                  |L41.20|
;;;3690   			}
;;;3691   			else
;;;3692   			{
;;;3693   				xReturn = taskSCHEDULER_SUSPENDED;
000014  2000              MOVS     r0,#0
                  |L41.22|
;;;3694   			}
;;;3695   		}
;;;3696   
;;;3697   		return xReturn;
;;;3698   	}
000016  4770              BX       lr
;;;3699   
                          ENDP

                  |L41.24|
                          DCD      xSchedulerRunning
                  |L41.28|
                          DCD      uxSchedulerSuspended

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2125   
;;;2126   TickType_t xTaskGetTickCount( void )
000000  4901              LDR      r1,|L42.8|
;;;2127   {
;;;2128   TickType_t xTicks;
;;;2129   
;;;2130   	/* Critical section required if running on a 16 bit processor. */
;;;2131   	portTICK_TYPE_ENTER_CRITICAL();
;;;2132   	{
;;;2133   		xTicks = xTickCount;
000002  6808              LDR      r0,[r1,#0]  ; xTickCount
;;;2134   	}
;;;2135   	portTICK_TYPE_EXIT_CRITICAL();
;;;2136   
;;;2137   	return xTicks;
;;;2138   }
000004  4770              BX       lr
;;;2139   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L42.8|
                          DCD      xTickCount

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2140   
;;;2141   TickType_t xTaskGetTickCountFromISR( void )
000000  2100              MOVS     r1,#0
;;;2142   {
;;;2143   TickType_t xReturn;
;;;2144   UBaseType_t uxSavedInterruptStatus;
;;;2145   
;;;2146   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2147   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2148   	above the maximum system call priority are kept permanently enabled, even
;;;2149   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2150   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2151   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2152   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2153   	assigned a priority above the configured maximum system call priority.
;;;2154   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2155   	that have been assigned a priority at or (logically) below the maximum
;;;2156   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2157   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2158   	More information (albeit Cortex-M specific) is provided on the following
;;;2159   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2160   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;2161   
;;;2162   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2163   	{
;;;2164   		xReturn = xTickCount;
000002  4a01              LDR      r2,|L43.8|
000004  6810              LDR      r0,[r2,#0]  ; xTickCount
;;;2165   	}
;;;2166   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2167   
;;;2168   	return xReturn;
;;;2169   }
000006  4770              BX       lr
;;;2170   /*-----------------------------------------------------------*/
                          ENDP

                  |L43.8|
                          DCD      xTickCount

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2497   
;;;2498   BaseType_t xTaskIncrementTick( void )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2499   {
;;;2500   TCB_t * pxTCB;
;;;2501   TickType_t xItemValue;
;;;2502   BaseType_t xSwitchRequired = pdFALSE;
000004  2700              MOVS     r7,#0
;;;2503   
;;;2504   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2505   	Increments the tick then checks to see if the new tick value will cause any
;;;2506   	tasks to be unblocked. */
;;;2507   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2508   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000006  4834              LDR      r0,|L44.216|
000008  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000a  2800              CMP      r0,#0
00000c  d157              BNE      |L44.190|
;;;2509   	{
;;;2510   		/* Minor optimisation.  The tick count cannot change in this
;;;2511   		block. */
;;;2512   		const TickType_t xConstTickCount = xTickCount + 1;
00000e  4833              LDR      r0,|L44.220|
000010  6800              LDR      r0,[r0,#0]  ; xTickCount
000012  1c45              ADDS     r5,r0,#1
;;;2513   
;;;2514   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2515   		delayed lists if it wraps to 0. */
;;;2516   		xTickCount = xConstTickCount;
000014  4831              LDR      r0,|L44.220|
000016  6005              STR      r5,[r0,#0]  ; xTickCount
;;;2517   
;;;2518   		if( xConstTickCount == ( TickType_t ) 0U )
000018  b98d              CBNZ     r5,|L44.62|
;;;2519   		{
;;;2520   			taskSWITCH_DELAYED_LISTS();
00001a  4831              LDR      r0,|L44.224|
00001c  f8d08000          LDR      r8,[r0,#0]  ; pxDelayedTaskList
000020  4830              LDR      r0,|L44.228|
000022  6800              LDR      r0,[r0,#0]  ; pxOverflowDelayedTaskList
000024  492e              LDR      r1,|L44.224|
000026  6008              STR      r0,[r1,#0]  ; pxDelayedTaskList
000028  482e              LDR      r0,|L44.228|
00002a  f8c08000          STR      r8,[r0,#0]  ; pxOverflowDelayedTaskList
00002e  482e              LDR      r0,|L44.232|
000030  6800              LDR      r0,[r0,#0]  ; xNumOfOverflows
000032  1c40              ADDS     r0,r0,#1
000034  492c              LDR      r1,|L44.232|
000036  6008              STR      r0,[r1,#0]  ; xNumOfOverflows
000038  f7fffffe          BL       prvResetNextTaskUnblockTime
00003c  bf00              NOP      
                  |L44.62|
;;;2521   		}
;;;2522   		else
;;;2523   		{
;;;2524   			mtCOVERAGE_TEST_MARKER();
;;;2525   		}
;;;2526   
;;;2527   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2528   		the	queue in the order of their wake time - meaning once one task
;;;2529   		has been found whose block time has not expired there is no need to
;;;2530   		look any further down the list. */
;;;2531   		if( xConstTickCount >= xNextTaskUnblockTime )
00003e  482b              LDR      r0,|L44.236|
000040  6800              LDR      r0,[r0,#0]  ; xNextTaskUnblockTime
000042  4285              CMP      r5,r0
000044  d33a              BCC      |L44.188|
;;;2532   		{
;;;2533   			for( ;; )
000046  bf00              NOP      
                  |L44.72|
;;;2534   			{
;;;2535   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000048  4825              LDR      r0,|L44.224|
00004a  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
00004c  6800              LDR      r0,[r0,#0]
00004e  b908              CBNZ     r0,|L44.84|
000050  2001              MOVS     r0,#1
000052  e000              B        |L44.86|
                  |L44.84|
000054  2000              MOVS     r0,#0
                  |L44.86|
000056  b120              CBZ      r0,|L44.98|
;;;2536   				{
;;;2537   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2538   					to the maximum possible value so it is extremely
;;;2539   					unlikely that the
;;;2540   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2541   					next time through. */
;;;2542   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000058  f04f30ff          MOV      r0,#0xffffffff
00005c  4923              LDR      r1,|L44.236|
00005e  6008              STR      r0,[r1,#0]  ; xNextTaskUnblockTime
;;;2543   					break;
000060  e02b              B        |L44.186|
                  |L44.98|
;;;2544   				}
;;;2545   				else
;;;2546   				{
;;;2547   					/* The delayed list is not empty, get the value of the
;;;2548   					item at the head of the delayed list.  This is the time
;;;2549   					at which the task at the head of the delayed list must
;;;2550   					be removed from the Blocked state. */
;;;2551   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
000062  481f              LDR      r0,|L44.224|
000064  6800              LDR      r0,[r0,#0]  ; pxDelayedTaskList
000066  68c0              LDR      r0,[r0,#0xc]
000068  68c4              LDR      r4,[r0,#0xc]
;;;2552   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
00006a  6866              LDR      r6,[r4,#4]
;;;2553   
;;;2554   					if( xConstTickCount < xItemValue )
00006c  42b5              CMP      r5,r6
00006e  d202              BCS      |L44.118|
;;;2555   					{
;;;2556   						/* It is not time to unblock this item yet, but the
;;;2557   						item value is the time at which the task at the head
;;;2558   						of the blocked list must be removed from the Blocked
;;;2559   						state -	so record the item value in
;;;2560   						xNextTaskUnblockTime. */
;;;2561   						xNextTaskUnblockTime = xItemValue;
000070  481e              LDR      r0,|L44.236|
000072  6006              STR      r6,[r0,#0]  ; xNextTaskUnblockTime
;;;2562   						break;
000074  e021              B        |L44.186|
                  |L44.118|
;;;2563   					}
;;;2564   					else
;;;2565   					{
;;;2566   						mtCOVERAGE_TEST_MARKER();
;;;2567   					}
;;;2568   
;;;2569   					/* It is time to remove the item from the Blocked state. */
;;;2570   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000076  1d20              ADDS     r0,r4,#4
000078  f7fffffe          BL       uxListRemove
;;;2571   
;;;2572   					/* Is the task waiting on an event also?  If so remove
;;;2573   					it from the event list. */
;;;2574   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
00007c  6aa0              LDR      r0,[r4,#0x28]
00007e  b118              CBZ      r0,|L44.136|
;;;2575   					{
;;;2576   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000080  f1040018          ADD      r0,r4,#0x18
000084  f7fffffe          BL       uxListRemove
                  |L44.136|
;;;2577   					}
;;;2578   					else
;;;2579   					{
;;;2580   						mtCOVERAGE_TEST_MARKER();
;;;2581   					}
;;;2582   
;;;2583   					/* Place the unblocked task into the appropriate ready
;;;2584   					list. */
;;;2585   					prvAddTaskToReadyList( pxTCB );
000088  4919              LDR      r1,|L44.240|
00008a  6ae0              LDR      r0,[r4,#0x2c]
00008c  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00008e  4288              CMP      r0,r1
000090  d902              BLS      |L44.152|
000092  4917              LDR      r1,|L44.240|
000094  6ae0              LDR      r0,[r4,#0x2c]
000096  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L44.152|
000098  6ae1              LDR      r1,[r4,#0x2c]
00009a  eb010181          ADD      r1,r1,r1,LSL #2
00009e  4a15              LDR      r2,|L44.244|
0000a0  eb020081          ADD      r0,r2,r1,LSL #2
0000a4  1d21              ADDS     r1,r4,#4
0000a6  f7fffffe          BL       vListInsertEnd
;;;2586   
;;;2587   					/* A task being unblocked cannot cause an immediate
;;;2588   					context switch if preemption is turned off. */
;;;2589   					#if (  configUSE_PREEMPTION == 1 )
;;;2590   					{
;;;2591   						/* Preemption is on, but a context switch should
;;;2592   						only be performed if the unblocked task has a
;;;2593   						priority that is equal to or higher than the
;;;2594   						currently executing task. */
;;;2595   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0000aa  4913              LDR      r1,|L44.248|
0000ac  6ae0              LDR      r0,[r4,#0x2c]
0000ae  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
0000b0  6ac9              LDR      r1,[r1,#0x2c]
0000b2  4288              CMP      r0,r1
0000b4  d3c8              BCC      |L44.72|
;;;2596   						{
;;;2597   							xSwitchRequired = pdTRUE;
0000b6  2701              MOVS     r7,#1
0000b8  e7c6              B        |L44.72|
                  |L44.186|
0000ba  bf00              NOP                            ;2543
                  |L44.188|
;;;2598   						}
;;;2599   						else
;;;2600   						{
;;;2601   							mtCOVERAGE_TEST_MARKER();
;;;2602   						}
;;;2603   					}
;;;2604   					#endif /* configUSE_PREEMPTION */
;;;2605   				}
;;;2606   			}
;;;2607   		}
;;;2608   
;;;2609   		/* Tasks of equal priority to the currently running task will share
;;;2610   		processing time (time slice) if preemption is on, and the application
;;;2611   		writer has not explicitly turned time slicing off. */
;;;2612   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2613   		{
;;;2614   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2615   			{
;;;2616   				xSwitchRequired = pdTRUE;
;;;2617   			}
;;;2618   			else
;;;2619   			{
;;;2620   				mtCOVERAGE_TEST_MARKER();
;;;2621   			}
;;;2622   		}
;;;2623   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2624   
;;;2625   		#if ( configUSE_TICK_HOOK == 1 )
;;;2626   		{
;;;2627   			/* Guard against the tick hook being called when the pended tick
;;;2628   			count is being unwound (when the scheduler is being unlocked). */
;;;2629   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2630   			{
;;;2631   				vApplicationTickHook();
;;;2632   			}
;;;2633   			else
;;;2634   			{
;;;2635   				mtCOVERAGE_TEST_MARKER();
;;;2636   			}
;;;2637   		}
;;;2638   		#endif /* configUSE_TICK_HOOK */
;;;2639   	}
0000bc  e004              B        |L44.200|
                  |L44.190|
;;;2640   	else
;;;2641   	{
;;;2642   		++uxPendedTicks;
0000be  480f              LDR      r0,|L44.252|
0000c0  6800              LDR      r0,[r0,#0]  ; uxPendedTicks
0000c2  1c40              ADDS     r0,r0,#1
0000c4  490d              LDR      r1,|L44.252|
0000c6  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L44.200|
;;;2643   
;;;2644   		/* The tick hook gets called at regular intervals, even if the
;;;2645   		scheduler is locked. */
;;;2646   		#if ( configUSE_TICK_HOOK == 1 )
;;;2647   		{
;;;2648   			vApplicationTickHook();
;;;2649   		}
;;;2650   		#endif
;;;2651   	}
;;;2652   
;;;2653   	#if ( configUSE_PREEMPTION == 1 )
;;;2654   	{
;;;2655   		if( xYieldPending != pdFALSE )
0000c8  480d              LDR      r0,|L44.256|
0000ca  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000cc  b100              CBZ      r0,|L44.208|
;;;2656   		{
;;;2657   			xSwitchRequired = pdTRUE;
0000ce  2701              MOVS     r7,#1
                  |L44.208|
;;;2658   		}
;;;2659   		else
;;;2660   		{
;;;2661   			mtCOVERAGE_TEST_MARKER();
;;;2662   		}
;;;2663   	}
;;;2664   	#endif /* configUSE_PREEMPTION */
;;;2665   
;;;2666   	return xSwitchRequired;
0000d0  4638              MOV      r0,r7
;;;2667   }
0000d2  e8bd81f0          POP      {r4-r8,pc}
;;;2668   /*-----------------------------------------------------------*/
                          ENDP

0000d6  0000              DCW      0x0000
                  |L44.216|
                          DCD      uxSchedulerSuspended
                  |L44.220|
                          DCD      xTickCount
                  |L44.224|
                          DCD      pxDelayedTaskList
                  |L44.228|
                          DCD      pxOverflowDelayedTaskList
                  |L44.232|
                          DCD      xNumOfOverflows
                  |L44.236|
                          DCD      xNextTaskUnblockTime
                  |L44.240|
                          DCD      uxTopReadyPriority
                  |L44.244|
                          DCD      pxReadyTasksLists
                  |L44.248|
                          DCD      pxCurrentTCB
                  |L44.252|
                          DCD      uxPendedTicks
                  |L44.256|
                          DCD      xYieldPending

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4660   
;;;4661   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;4662   	{
000002  4605              MOV      r5,r0
;;;4663   	TCB_t *pxTCB;
;;;4664   	BaseType_t xReturn;
;;;4665   
;;;4666   		/* If null is passed in here then it is the calling task that is having
;;;4667   		its notification state cleared. */
;;;4668   		pxTCB = prvGetTCBFromHandle( xTask );
000004  b915              CBNZ     r5,|L45.12|
000006  480a              LDR      r0,|L45.48|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00000a  e000              B        |L45.14|
                  |L45.12|
00000c  4628              MOV      r0,r5
                  |L45.14|
00000e  4606              MOV      r6,r0
;;;4669   
;;;4670   		taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;4671   		{
;;;4672   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000014  f8960064          LDRB     r0,[r6,#0x64]
000018  2802              CMP      r0,#2
00001a  d104              BNE      |L45.38|
;;;4673   			{
;;;4674   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00001c  2000              MOVS     r0,#0
00001e  f8860064          STRB     r0,[r6,#0x64]
;;;4675   				xReturn = pdPASS;
000022  2401              MOVS     r4,#1
000024  e000              B        |L45.40|
                  |L45.38|
;;;4676   			}
;;;4677   			else
;;;4678   			{
;;;4679   				xReturn = pdFAIL;
000026  2400              MOVS     r4,#0
                  |L45.40|
;;;4680   			}
;;;4681   		}
;;;4682   		taskEXIT_CRITICAL();
000028  f7fffffe          BL       vPortExitCritical
;;;4683   
;;;4684   		return xReturn;
00002c  4620              MOV      r0,r4
;;;4685   	}
00002e  bd70              POP      {r4-r6,pc}
;;;4686   
                          ENDP

                  |L45.48|
                          DCD      pxCurrentTCB

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4261   
;;;4262   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;4263   	{
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
;;;4264   	BaseType_t xReturn;
;;;4265   
;;;4266   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4267   		{
;;;4268   			/* Only block if a notification is not already pending. */
;;;4269   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000010  4821              LDR      r0,|L46.152|
000012  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000014  f8900064          LDRB     r0,[r0,#0x64]
000018  2802              CMP      r0,#2
00001a  d018              BEQ      |L46.78|
;;;4270   			{
;;;4271   				/* Clear bits in the task's notification value as bits may get
;;;4272   				set	by the notifying task or interrupt.  This can be used to
;;;4273   				clear the value to zero. */
;;;4274   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001c  491e              LDR      r1,|L46.152|
00001e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000020  f1010060          ADD      r0,r1,#0x60
000024  6e09              LDR      r1,[r1,#0x60]
000026  43b9              BICS     r1,r1,r7
000028  6001              STR      r1,[r0,#0]
;;;4275   
;;;4276   				/* Mark this task as waiting for a notification. */
;;;4277   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
00002a  2001              MOVS     r0,#1
00002c  491a              LDR      r1,|L46.152|
00002e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000030  f8810064          STRB     r0,[r1,#0x64]
;;;4278   
;;;4279   				if( xTicksToWait > ( TickType_t ) 0 )
000034  b15d              CBZ      r5,|L46.78|
;;;4280   				{
;;;4281   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000036  2101              MOVS     r1,#1
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4282   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4283   
;;;4284   					/* All ports are written to allow a yield in a critical
;;;4285   					section (some will yield immediately, others wait until the
;;;4286   					critical section exits) - but it is not something that
;;;4287   					application code should ever do. */
;;;4288   					portYIELD_WITHIN_API();
00003e  f04f5080          MOV      r0,#0x10000000
000042  4916              LDR      r1,|L46.156|
000044  6008              STR      r0,[r1,#0]
000046  f3bf8f4f          DSB      
00004a  f3bf8f6f          ISB      
                  |L46.78|
;;;4289   				}
;;;4290   				else
;;;4291   				{
;;;4292   					mtCOVERAGE_TEST_MARKER();
;;;4293   				}
;;;4294   			}
;;;4295   			else
;;;4296   			{
;;;4297   				mtCOVERAGE_TEST_MARKER();
;;;4298   			}
;;;4299   		}
;;;4300   		taskEXIT_CRITICAL();
00004e  f7fffffe          BL       vPortExitCritical
;;;4301   
;;;4302   		taskENTER_CRITICAL();
000052  f7fffffe          BL       vPortEnterCritical
;;;4303   		{
;;;4304   			traceTASK_NOTIFY_WAIT();
;;;4305   
;;;4306   			if( pulNotificationValue != NULL )
000056  b11c              CBZ      r4,|L46.96|
;;;4307   			{
;;;4308   				/* Output the current notification value, which may or may not
;;;4309   				have changed. */
;;;4310   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000058  480f              LDR      r0,|L46.152|
00005a  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
00005c  6e00              LDR      r0,[r0,#0x60]
00005e  6020              STR      r0,[r4,#0]
                  |L46.96|
;;;4311   			}
;;;4312   
;;;4313   			/* If ucNotifyValue is set then either the task never entered the
;;;4314   			blocked state (because a notification was already pending) or the
;;;4315   			task unblocked because of a notification.  Otherwise the task
;;;4316   			unblocked because of a timeout. */
;;;4317   			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000060  480d              LDR      r0,|L46.152|
000062  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
000064  f8900064          LDRB     r0,[r0,#0x64]
000068  2801              CMP      r0,#1
00006a  d101              BNE      |L46.112|
;;;4318   			{
;;;4319   				/* A notification was not received. */
;;;4320   				xReturn = pdFALSE;
00006c  2600              MOVS     r6,#0
00006e  e008              B        |L46.130|
                  |L46.112|
;;;4321   			}
;;;4322   			else
;;;4323   			{
;;;4324   				/* A notification was already pending or a notification was
;;;4325   				received while the task was waiting. */
;;;4326   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000070  4909              LDR      r1,|L46.152|
000072  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000074  f1010060          ADD      r0,r1,#0x60
000078  6e09              LDR      r1,[r1,#0x60]
00007a  ea210108          BIC      r1,r1,r8
00007e  6001              STR      r1,[r0,#0]
;;;4327   				xReturn = pdTRUE;
000080  2601              MOVS     r6,#1
                  |L46.130|
;;;4328   			}
;;;4329   
;;;4330   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000082  2000              MOVS     r0,#0
000084  4904              LDR      r1,|L46.152|
000086  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000088  f8810064          STRB     r0,[r1,#0x64]
;;;4331   		}
;;;4332   		taskEXIT_CRITICAL();
00008c  f7fffffe          BL       vPortExitCritical
;;;4333   
;;;4334   		return xReturn;
000090  4630              MOV      r0,r6
;;;4335   	}
000092  e8bd81f0          POP      {r4-r8,pc}
;;;4336   
                          ENDP

000096  0000              DCW      0x0000
                  |L46.152|
                          DCD      pxCurrentTCB
                  |L46.156|
                          DCD      0xe000ed04

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3770   
;;;3771   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3772   	{
000002  4605              MOV      r5,r0
;;;3773   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  462c              MOV      r4,r5
;;;3774   	BaseType_t xReturn = pdFALSE;
000006  2600              MOVS     r6,#0
;;;3775   
;;;3776   		if( pxMutexHolder != NULL )
000008  b31d              CBZ      r5,|L47.82|
;;;3777   		{
;;;3778   			/* A task can only have an inherited priority if it holds the mutex.
;;;3779   			If the mutex is held by a task then it cannot be given from an
;;;3780   			interrupt, and if a mutex is given by the holding task then it must
;;;3781   			be the running state task. */
;;;3782   			configASSERT( pxTCB == pxCurrentTCB );
;;;3783   
;;;3784   			configASSERT( pxTCB->uxMutexesHeld );
;;;3785   			( pxTCB->uxMutexesHeld )--;
00000a  6ca0              LDR      r0,[r4,#0x48]
00000c  1e40              SUBS     r0,r0,#1
00000e  64a0              STR      r0,[r4,#0x48]
;;;3786   
;;;3787   			/* Has the holder of the mutex inherited the priority of another
;;;3788   			task? */
;;;3789   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000010  6c61              LDR      r1,[r4,#0x44]
000012  6ae0              LDR      r0,[r4,#0x2c]
000014  4288              CMP      r0,r1
000016  d01c              BEQ      |L47.82|
;;;3790   			{
;;;3791   				/* Only disinherit if no other mutexes are held. */
;;;3792   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000018  6ca0              LDR      r0,[r4,#0x48]
00001a  b9d0              CBNZ     r0,|L47.82|
;;;3793   				{
;;;3794   					/* A task can only have an inherited priority if it holds
;;;3795   					the mutex.  If the mutex is held by a task then it cannot be
;;;3796   					given from an interrupt, and if a mutex is given by the
;;;3797   					holding	task then it must be the running state task.  Remove
;;;3798   					the	holding task from the ready	list. */
;;;3799   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;3800   					{
;;;3801   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3802   					}
;;;3803   					else
;;;3804   					{
;;;3805   						mtCOVERAGE_TEST_MARKER();
;;;3806   					}
;;;3807   
;;;3808   					/* Disinherit the priority before adding the task into the
;;;3809   					new	ready list. */
;;;3810   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3811   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000022  6c60              LDR      r0,[r4,#0x44]
000024  62e0              STR      r0,[r4,#0x2c]
;;;3812   
;;;3813   					/* Reset the event list item value.  It cannot be in use for
;;;3814   					any other purpose if this task is running, and it must be
;;;3815   					running to give back the mutex. */
;;;3816   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000026  6ae0              LDR      r0,[r4,#0x2c]
000028  f1c00005          RSB      r0,r0,#5
00002c  61a0              STR      r0,[r4,#0x18]
;;;3817   					prvAddTaskToReadyList( pxTCB );
00002e  490a              LDR      r1,|L47.88|
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000034  4288              CMP      r0,r1
000036  d902              BLS      |L47.62|
000038  4907              LDR      r1,|L47.88|
00003a  6ae0              LDR      r0,[r4,#0x2c]
00003c  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L47.62|
00003e  6ae1              LDR      r1,[r4,#0x2c]
000040  eb010181          ADD      r1,r1,r1,LSL #2
000044  4a05              LDR      r2,|L47.92|
000046  eb020081          ADD      r0,r2,r1,LSL #2
00004a  1d21              ADDS     r1,r4,#4
00004c  f7fffffe          BL       vListInsertEnd
;;;3818   
;;;3819   					/* Return true to indicate that a context switch is required.
;;;3820   					This is only actually required in the corner case whereby
;;;3821   					multiple mutexes were held and the mutexes were given back
;;;3822   					in an order different to that in which they were taken.
;;;3823   					If a context switch did not occur when the first mutex was
;;;3824   					returned, even if a task was waiting on it, then a context
;;;3825   					switch should occur when the last mutex is returned whether
;;;3826   					a task is waiting on it or not. */
;;;3827   					xReturn = pdTRUE;
000050  2601              MOVS     r6,#1
                  |L47.82|
;;;3828   				}
;;;3829   				else
;;;3830   				{
;;;3831   					mtCOVERAGE_TEST_MARKER();
;;;3832   				}
;;;3833   			}
;;;3834   			else
;;;3835   			{
;;;3836   				mtCOVERAGE_TEST_MARKER();
;;;3837   			}
;;;3838   		}
;;;3839   		else
;;;3840   		{
;;;3841   			mtCOVERAGE_TEST_MARKER();
;;;3842   		}
;;;3843   
;;;3844   		return xReturn;
000052  4630              MOV      r0,r6
;;;3845   	}
000054  bd70              POP      {r4-r6,pc}
;;;3846   
                          ENDP

000056  0000              DCW      0x0000
                  |L47.88|
                          DCD      uxTopReadyPriority
                  |L47.92|
                          DCD      pxReadyTasksLists

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2892   
;;;2893   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;2894   {
000002  4606              MOV      r6,r0
;;;2895   TCB_t *pxUnblockedTCB;
;;;2896   BaseType_t xReturn;
;;;2897   
;;;2898   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2899   	called from a critical section within an ISR. */
;;;2900   
;;;2901   	/* The event list is sorted in priority order, so the first in the list can
;;;2902   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2903   	the delayed list, and add it to the ready list.
;;;2904   
;;;2905   	If an event is for a queue that is locked then this function will never
;;;2906   	get called - the lock count on the queue will get modified instead.  This
;;;2907   	means exclusive access to the event list is guaranteed here.
;;;2908   
;;;2909   	This function assumes that a check has already been made to ensure that
;;;2910   	pxEventList is not empty. */
;;;2911   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000004  68f0              LDR      r0,[r6,#0xc]
000006  68c4              LDR      r4,[r0,#0xc]
;;;2912   	configASSERT( pxUnblockedTCB );
;;;2913   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000008  f1040018          ADD      r0,r4,#0x18
00000c  f7fffffe          BL       uxListRemove
;;;2914   
;;;2915   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000010  4815              LDR      r0,|L48.104|
000012  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000014  b9a0              CBNZ     r0,|L48.64|
;;;2916   	{
;;;2917   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;2918   		prvAddTaskToReadyList( pxUnblockedTCB );
00001c  4913              LDR      r1,|L48.108|
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000022  4288              CMP      r0,r1
000024  d902              BLS      |L48.44|
000026  4911              LDR      r1,|L48.108|
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L48.44|
00002c  6ae1              LDR      r1,[r4,#0x2c]
00002e  eb010181          ADD      r1,r1,r1,LSL #2
000032  4a0f              LDR      r2,|L48.112|
000034  eb020081          ADD      r0,r2,r1,LSL #2
000038  1d21              ADDS     r1,r4,#4
00003a  f7fffffe          BL       vListInsertEnd
00003e  e004              B        |L48.74|
                  |L48.64|
;;;2919   	}
;;;2920   	else
;;;2921   	{
;;;2922   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2923   		pending until the scheduler is resumed. */
;;;2924   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000040  f1040118          ADD      r1,r4,#0x18
000044  480b              LDR      r0,|L48.116|
000046  f7fffffe          BL       vListInsertEnd
                  |L48.74|
;;;2925   	}
;;;2926   
;;;2927   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00004a  490b              LDR      r1,|L48.120|
00004c  6ae0              LDR      r0,[r4,#0x2c]
00004e  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000050  6ac9              LDR      r1,[r1,#0x2c]
000052  4288              CMP      r0,r1
000054  d904              BLS      |L48.96|
;;;2928   	{
;;;2929   		/* Return true if the task removed from the event list has a higher
;;;2930   		priority than the calling task.  This allows the calling task to know if
;;;2931   		it should force a context switch now. */
;;;2932   		xReturn = pdTRUE;
000056  2501              MOVS     r5,#1
;;;2933   
;;;2934   		/* Mark that a yield is pending in case the user is not using the
;;;2935   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2936   		xYieldPending = pdTRUE;
000058  2001              MOVS     r0,#1
00005a  4908              LDR      r1,|L48.124|
00005c  6008              STR      r0,[r1,#0]  ; xYieldPending
00005e  e000              B        |L48.98|
                  |L48.96|
;;;2937   	}
;;;2938   	else
;;;2939   	{
;;;2940   		xReturn = pdFALSE;
000060  2500              MOVS     r5,#0
                  |L48.98|
;;;2941   	}
;;;2942   
;;;2943   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2944   	{
;;;2945   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2946   		might be set to the blocked task's time out time.  If the task is
;;;2947   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2948   		normally left unchanged, because it is automatically reset to a new
;;;2949   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2950   		tickless idling is used it might be more important to enter sleep mode
;;;2951   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2952   		ensure it is updated at the earliest possible time. */
;;;2953   		prvResetNextTaskUnblockTime();
;;;2954   	}
;;;2955   	#endif
;;;2956   
;;;2957   	return xReturn;
000062  4628              MOV      r0,r5
;;;2958   }
000064  bd70              POP      {r4-r6,pc}
;;;2959   /*-----------------------------------------------------------*/
                          ENDP

000066  0000              DCW      0x0000
                  |L48.104|
                          DCD      uxSchedulerSuspended
                  |L48.108|
                          DCD      uxTopReadyPriority
                  |L48.112|
                          DCD      pxReadyTasksLists
                  |L48.116|
                          DCD      xPendingReadyList
                  |L48.120|
                          DCD      pxCurrentTCB
                  |L48.124|
                          DCD      xYieldPending

                          AREA ||i.xTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromUnorderedEventList PROC
;;;2960   
;;;2961   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2962   {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;2963   TCB_t *pxUnblockedTCB;
;;;2964   BaseType_t xReturn;
;;;2965   
;;;2966   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2967   	the event flags implementation. */
;;;2968   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;2969   
;;;2970   	/* Store the new item value in the event list. */
;;;2971   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000008  f0474000          ORR      r0,r7,#0x80000000
00000c  6028              STR      r0,[r5,#0]
;;;2972   
;;;2973   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2974   	event flags. */
;;;2975   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
00000e  68ec              LDR      r4,[r5,#0xc]
;;;2976   	configASSERT( pxUnblockedTCB );
;;;2977   	( void ) uxListRemove( pxEventListItem );
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       uxListRemove
;;;2978   
;;;2979   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2980   	scheduler is suspended so interrupts will not be accessing the ready
;;;2981   	lists. */
;;;2982   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000016  1d20              ADDS     r0,r4,#4
000018  f7fffffe          BL       uxListRemove
;;;2983   	prvAddTaskToReadyList( pxUnblockedTCB );
00001c  490f              LDR      r1,|L49.92|
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000022  4288              CMP      r0,r1
000024  d902              BLS      |L49.44|
000026  490d              LDR      r1,|L49.92|
000028  6ae0              LDR      r0,[r4,#0x2c]
00002a  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L49.44|
00002c  6ae1              LDR      r1,[r4,#0x2c]
00002e  eb010181          ADD      r1,r1,r1,LSL #2
000032  4a0b              LDR      r2,|L49.96|
000034  eb020081          ADD      r0,r2,r1,LSL #2
000038  1d21              ADDS     r1,r4,#4
00003a  f7fffffe          BL       vListInsertEnd
;;;2984   
;;;2985   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
00003e  4909              LDR      r1,|L49.100|
000040  6ae0              LDR      r0,[r4,#0x2c]
000042  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000044  6ac9              LDR      r1,[r1,#0x2c]
000046  4288              CMP      r0,r1
000048  d904              BLS      |L49.84|
;;;2986   	{
;;;2987   		/* Return true if the task removed from the event list has
;;;2988   		a higher priority than the calling task.  This allows
;;;2989   		the calling task to know if it should force a context
;;;2990   		switch now. */
;;;2991   		xReturn = pdTRUE;
00004a  2601              MOVS     r6,#1
;;;2992   
;;;2993   		/* Mark that a yield is pending in case the user is not using the
;;;2994   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2995   		xYieldPending = pdTRUE;
00004c  2001              MOVS     r0,#1
00004e  4906              LDR      r1,|L49.104|
000050  6008              STR      r0,[r1,#0]  ; xYieldPending
000052  e000              B        |L49.86|
                  |L49.84|
;;;2996   	}
;;;2997   	else
;;;2998   	{
;;;2999   		xReturn = pdFALSE;
000054  2600              MOVS     r6,#0
                  |L49.86|
;;;3000   	}
;;;3001   
;;;3002   	return xReturn;
000056  4630              MOV      r0,r6
;;;3003   }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;3004   /*-----------------------------------------------------------*/
                          ENDP

                  |L49.92|
                          DCD      uxTopReadyPriority
                  |L49.96|
                          DCD      pxReadyTasksLists
                  |L49.100|
                          DCD      pxCurrentTCB
                  |L49.104|
                          DCD      xYieldPending

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2015   
;;;2016   BaseType_t xTaskResumeAll( void )
000000  b570              PUSH     {r4-r6,lr}
;;;2017   {
;;;2018   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2019   BaseType_t xAlreadyYielded = pdFALSE;
000004  2600              MOVS     r6,#0
;;;2020   
;;;2021   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2022   	previous call to vTaskSuspendAll(). */
;;;2023   	configASSERT( uxSchedulerSuspended );
;;;2024   
;;;2025   	/* It is possible that an ISR caused a task to be removed from an event
;;;2026   	list while the scheduler was suspended.  If this was the case then the
;;;2027   	removed task will have been added to the xPendingReadyList.  Once the
;;;2028   	scheduler has been resumed it is safe to move all the pending ready
;;;2029   	tasks from this list into their appropriate ready list. */
;;;2030   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2031   	{
;;;2032   		--uxSchedulerSuspended;
00000a  482e              LDR      r0,|L50.196|
00000c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00000e  1e40              SUBS     r0,r0,#1
000010  492c              LDR      r1,|L50.196|
000012  6008              STR      r0,[r1,#0]  ; uxSchedulerSuspended
;;;2033   
;;;2034   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000014  4608              MOV      r0,r1
000016  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
000018  2800              CMP      r0,#0
00001a  d14e              BNE      |L50.186|
;;;2035   		{
;;;2036   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
00001c  482a              LDR      r0,|L50.200|
00001e  6800              LDR      r0,[r0,#0]  ; uxCurrentNumberOfTasks
000020  2800              CMP      r0,#0
000022  d04a              BEQ      |L50.186|
;;;2037   			{
;;;2038   				/* Move any readied tasks from the pending list into the
;;;2039   				appropriate ready list. */
;;;2040   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
000024  e023              B        |L50.110|
                  |L50.38|
;;;2041   				{
;;;2042   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000026  4829              LDR      r0,|L50.204|
000028  68c0              LDR      r0,[r0,#0xc]
00002a  68c4              LDR      r4,[r0,#0xc]
;;;2043   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00002c  f1040018          ADD      r0,r4,#0x18
000030  f7fffffe          BL       uxListRemove
;;;2044   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000034  1d20              ADDS     r0,r4,#4
000036  f7fffffe          BL       uxListRemove
;;;2045   					prvAddTaskToReadyList( pxTCB );
00003a  4925              LDR      r1,|L50.208|
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
000040  4288              CMP      r0,r1
000042  d902              BLS      |L50.74|
000044  4922              LDR      r1,|L50.208|
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L50.74|
00004a  6ae1              LDR      r1,[r4,#0x2c]
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  4a20              LDR      r2,|L50.212|
000052  eb020081          ADD      r0,r2,r1,LSL #2
000056  1d21              ADDS     r1,r4,#4
000058  f7fffffe          BL       vListInsertEnd
;;;2046   
;;;2047   					/* If the moved task has a priority higher than the current
;;;2048   					task then a yield must be performed. */
;;;2049   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00005c  491e              LDR      r1,|L50.216|
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000062  6ac9              LDR      r1,[r1,#0x2c]
000064  4288              CMP      r0,r1
000066  d302              BCC      |L50.110|
;;;2050   					{
;;;2051   						xYieldPending = pdTRUE;
000068  2001              MOVS     r0,#1
00006a  491c              LDR      r1,|L50.220|
00006c  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L50.110|
00006e  4817              LDR      r0,|L50.204|
000070  6800              LDR      r0,[r0,#0]            ;2040  ; xPendingReadyList
000072  b908              CBNZ     r0,|L50.120|
000074  2001              MOVS     r0,#1                 ;2040
000076  e000              B        |L50.122|
                  |L50.120|
000078  2000              MOVS     r0,#0                 ;2040
                  |L50.122|
00007a  2800              CMP      r0,#0                 ;2040
00007c  d0d3              BEQ      |L50.38|
;;;2052   					}
;;;2053   					else
;;;2054   					{
;;;2055   						mtCOVERAGE_TEST_MARKER();
;;;2056   					}
;;;2057   				}
;;;2058   
;;;2059   				if( pxTCB != NULL )
00007e  b10c              CBZ      r4,|L50.132|
;;;2060   				{
;;;2061   					/* A task was unblocked while the scheduler was suspended,
;;;2062   					which may have prevented the next unblock time from being
;;;2063   					re-calculated, in which case re-calculate it now.  Mainly
;;;2064   					important for low power tickless implementations, where
;;;2065   					this can prevent an unnecessary exit from low power
;;;2066   					state. */
;;;2067   					prvResetNextTaskUnblockTime();
000080  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L50.132|
;;;2068   				}
;;;2069   
;;;2070   				/* If any ticks occurred while the scheduler was suspended then
;;;2071   				they should be processed now.  This ensures the tick count does
;;;2072   				not	slip, and that any delayed tasks are resumed at the correct
;;;2073   				time. */
;;;2074   				{
;;;2075   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000084  4816              LDR      r0,|L50.224|
000086  6805              LDR      r5,[r0,#0]  ; uxPendedTicks
;;;2076   
;;;2077   					if( uxPendedCounts > ( UBaseType_t ) 0U )
000088  b165              CBZ      r5,|L50.164|
;;;2078   					{
;;;2079   						do
00008a  bf00              NOP      
                  |L50.140|
;;;2080   						{
;;;2081   							if( xTaskIncrementTick() != pdFALSE )
00008c  f7fffffe          BL       xTaskIncrementTick
000090  b110              CBZ      r0,|L50.152|
;;;2082   							{
;;;2083   								xYieldPending = pdTRUE;
000092  2001              MOVS     r0,#1
000094  4911              LDR      r1,|L50.220|
000096  6008              STR      r0,[r1,#0]  ; xYieldPending
                  |L50.152|
;;;2084   							}
;;;2085   							else
;;;2086   							{
;;;2087   								mtCOVERAGE_TEST_MARKER();
;;;2088   							}
;;;2089   							--uxPendedCounts;
000098  1e6d              SUBS     r5,r5,#1
;;;2090   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
00009a  2d00              CMP      r5,#0
00009c  d1f6              BNE      |L50.140|
;;;2091   
;;;2092   						uxPendedTicks = 0;
00009e  2000              MOVS     r0,#0
0000a0  490f              LDR      r1,|L50.224|
0000a2  6008              STR      r0,[r1,#0]  ; uxPendedTicks
                  |L50.164|
;;;2093   					}
;;;2094   					else
;;;2095   					{
;;;2096   						mtCOVERAGE_TEST_MARKER();
;;;2097   					}
;;;2098   				}
;;;2099   
;;;2100   				if( xYieldPending != pdFALSE )
0000a4  480d              LDR      r0,|L50.220|
0000a6  6800              LDR      r0,[r0,#0]  ; xYieldPending
0000a8  b138              CBZ      r0,|L50.186|
;;;2101   				{
;;;2102   					#if( configUSE_PREEMPTION != 0 )
;;;2103   					{
;;;2104   						xAlreadyYielded = pdTRUE;
0000aa  2601              MOVS     r6,#1
;;;2105   					}
;;;2106   					#endif
;;;2107   					taskYIELD_IF_USING_PREEMPTION();
0000ac  0730              LSLS     r0,r6,#28
0000ae  490d              LDR      r1,|L50.228|
0000b0  6008              STR      r0,[r1,#0]
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
                  |L50.186|
;;;2108   				}
;;;2109   				else
;;;2110   				{
;;;2111   					mtCOVERAGE_TEST_MARKER();
;;;2112   				}
;;;2113   			}
;;;2114   		}
;;;2115   		else
;;;2116   		{
;;;2117   			mtCOVERAGE_TEST_MARKER();
;;;2118   		}
;;;2119   	}
;;;2120   	taskEXIT_CRITICAL();
0000ba  f7fffffe          BL       vPortExitCritical
;;;2121   
;;;2122   	return xAlreadyYielded;
0000be  4630              MOV      r0,r6
;;;2123   }
0000c0  bd70              POP      {r4-r6,pc}
;;;2124   /*-----------------------------------------------------------*/
                          ENDP

0000c2  0000              DCW      0x0000
                  |L50.196|
                          DCD      uxSchedulerSuspended
                  |L50.200|
                          DCD      uxCurrentNumberOfTasks
                  |L50.204|
                          DCD      xPendingReadyList
                  |L50.208|
                          DCD      uxTopReadyPriority
                  |L50.212|
                          DCD      pxReadyTasksLists
                  |L50.216|
                          DCD      pxCurrentTCB
                  |L50.220|
                          DCD      xYieldPending
                  |L50.224|
                          DCD      uxPendedTicks
                  |L50.228|
                          DCD      0xe000ed04

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1754   
;;;1755   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1756   	{
000004  4606              MOV      r6,r0
;;;1757   	BaseType_t xYieldRequired = pdFALSE;
000006  2700              MOVS     r7,#0
;;;1758   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000008  4634              MOV      r4,r6
;;;1759   	UBaseType_t uxSavedInterruptStatus;
;;;1760   
;;;1761   		configASSERT( xTaskToResume );
;;;1762   
;;;1763   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1764   		maximum	system call (or maximum API call) interrupt priority.
;;;1765   		Interrupts that are	above the maximum system call priority are keep
;;;1766   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1767   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1768   		is defined in FreeRTOSConfig.h then
;;;1769   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1770   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1771   		been assigned a priority above the configured maximum system call
;;;1772   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1773   		from interrupts	that have been assigned a priority at or (logically)
;;;1774   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1775   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1776   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1777   		provided on the following link:
;;;1778   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1779   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1780   
;;;1781   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000a  bf00              NOP      
00000c  21bf              MOVS     r1,#0xbf
00000e  f3ef8011          MRS      r0,BASEPRI
000012  f3818811          MSR      BASEPRI,r1
000016  f3bf8f4f          DSB      
00001a  f3bf8f6f          ISB      
00001e  bf00              NOP      
000020  4605              MOV      r5,r0
;;;1782   		{
;;;1783   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       prvTaskIsTaskSuspended
000028  b318              CBZ      r0,|L51.114|
;;;1784   			{
;;;1785   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1786   
;;;1787   				/* Check the ready lists can be accessed. */
;;;1788   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00002a  4815              LDR      r0,|L51.128|
00002c  6800              LDR      r0,[r0,#0]  ; uxSchedulerSuspended
00002e  b9d8              CBNZ     r0,|L51.104|
;;;1789   				{
;;;1790   					/* Ready lists can be accessed so move the task from the
;;;1791   					suspended list to the ready list directly. */
;;;1792   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
000030  4914              LDR      r1,|L51.132|
000032  6ae0              LDR      r0,[r4,#0x2c]
000034  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000036  6ac9              LDR      r1,[r1,#0x2c]
000038  4288              CMP      r0,r1
00003a  d300              BCC      |L51.62|
;;;1793   					{
;;;1794   						xYieldRequired = pdTRUE;
00003c  2701              MOVS     r7,#1
                  |L51.62|
;;;1795   					}
;;;1796   					else
;;;1797   					{
;;;1798   						mtCOVERAGE_TEST_MARKER();
;;;1799   					}
;;;1800   
;;;1801   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
00003e  1d20              ADDS     r0,r4,#4
000040  f7fffffe          BL       uxListRemove
;;;1802   					prvAddTaskToReadyList( pxTCB );
000044  4910              LDR      r1,|L51.136|
000046  6ae0              LDR      r0,[r4,#0x2c]
000048  6809              LDR      r1,[r1,#0]  ; uxTopReadyPriority
00004a  4288              CMP      r0,r1
00004c  d902              BLS      |L51.84|
00004e  490e              LDR      r1,|L51.136|
000050  6ae0              LDR      r0,[r4,#0x2c]
000052  6008              STR      r0,[r1,#0]  ; uxTopReadyPriority
                  |L51.84|
000054  6ae1              LDR      r1,[r4,#0x2c]
000056  eb010181          ADD      r1,r1,r1,LSL #2
00005a  4a0c              LDR      r2,|L51.140|
00005c  eb020081          ADD      r0,r2,r1,LSL #2
000060  1d21              ADDS     r1,r4,#4
000062  f7fffffe          BL       vListInsertEnd
000066  e004              B        |L51.114|
                  |L51.104|
;;;1803   				}
;;;1804   				else
;;;1805   				{
;;;1806   					/* The delayed or ready lists cannot be accessed so the task
;;;1807   					is held in the pending ready list until the scheduler is
;;;1808   					unsuspended. */
;;;1809   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000068  f1040118          ADD      r1,r4,#0x18
00006c  4808              LDR      r0,|L51.144|
00006e  f7fffffe          BL       vListInsertEnd
                  |L51.114|
;;;1810   				}
;;;1811   			}
;;;1812   			else
;;;1813   			{
;;;1814   				mtCOVERAGE_TEST_MARKER();
;;;1815   			}
;;;1816   		}
;;;1817   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000072  bf00              NOP      
000074  f3858811          MSR      BASEPRI,r5
000078  bf00              NOP      
;;;1818   
;;;1819   		return xYieldRequired;
00007a  4638              MOV      r0,r7
;;;1820   	}
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;1821   
                          ENDP

                  |L51.128|
                          DCD      uxSchedulerSuspended
                  |L51.132|
                          DCD      pxCurrentTCB
                  |L51.136|
                          DCD      uxTopReadyPriority
                  |L51.140|
                          DCD      pxReadyTasksLists
                  |L51.144|
                          DCD      xPendingReadyList

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        100
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
