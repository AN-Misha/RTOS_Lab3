; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_can.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_can.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_can.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_can.c]
                          THUMB

                          AREA ||i.CAN_BRGInit||, CODE, READONLY, ALIGN=2

                  CAN_BRGInit PROC
;;;856      */
;;;857    void CAN_BRGInit(MDR_CAN_TypeDef* CANx, uint32_t CAN_BRG)
000000  4602              MOV      r2,r0
;;;858    {
;;;859      uint32_t tmpreg;
;;;860    
;;;861      /* Check the parameters */
;;;862      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;863      assert_param(IS_CAN_CLOCK_BRG(CAN_BRG));
;;;864    
;;;865      tmpreg = MDR_RST_CLK->CAN_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6a18              LDR      r0,[r3,#0x20]
;;;866    
;;;867      if (CANx == MDR_CAN1)
000006  f1b24f80          CMP      r2,#0x40000000
00000a  d105              BNE      |L1.24|
;;;868      {
;;;869        tmpreg |= RST_CLK_CAN_CLOCK_CAN1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;870        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;871        tmpreg |= CAN_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;872      }
;;;873      else if (CANx == MDR_CAN2)
000018  4b06              LDR      r3,|L1.52|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;874      {
;;;875        tmpreg |= RST_CLK_CAN_CLOCK_CAN2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;876        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;877        tmpreg |= (CAN_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;878      }
;;;879    
;;;880      MDR_RST_CLK->CAN_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  6218              STR      r0,[r3,#0x20]
;;;881    }
00002e  4770              BX       lr
;;;882    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40008000

                          AREA ||i.CAN_BufferRelease||, CODE, READONLY, ALIGN=1

                  CAN_BufferRelease PROC
;;;529      */
;;;530    void CAN_BufferRelease(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  f1000340          ADD      r3,r0,#0x40
;;;531    {
;;;532      uint32_t tmpreg;
;;;533    
;;;534      /* Check the parameters */
;;;535      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;536      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;537    
;;;538      tmpreg = CANx->BUF_CON[BufferNumber];
000004  f8532021          LDR      r2,[r3,r1,LSL #2]
;;;539      tmpreg &= ~CAN_STATUS_EN;
000008  f0220201          BIC      r2,r2,#1
;;;540      CANx->BUF_CON[BufferNumber] = tmpreg;
00000c  f8432021          STR      r2,[r3,r1,LSL #2]
;;;541    }
000010  4770              BX       lr
;;;542    
                          ENDP


                          AREA ||i.CAN_Cmd||, CODE, READONLY, ALIGN=1

                  CAN_Cmd PROC
;;;551      */
;;;552    void CAN_Cmd(MDR_CAN_TypeDef* CANx, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;553    {
;;;554      uint32_t tmpreg_CONTROL;
;;;555    
;;;556      /* Check the parameters */
;;;557      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;558      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;559    
;;;560      tmpreg_CONTROL = CANx->CONTROL;
000002  6801              LDR      r1,[r0,#0]
;;;561    
;;;562      /* Form new value */
;;;563      if (NewState != DISABLE)
000004  b112              CBZ      r2,|L3.12|
;;;564      {
;;;565        /* Enable CANx by setting the CAN_EN bit in the CONTROL register */
;;;566        tmpreg_CONTROL |= CAN_CONTROL_CAN_EN;
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L3.16|
                  |L3.12|
;;;567      }
;;;568      else
;;;569      {
;;;570        /* Disable CANx by resetting the CAN_EN bit in the CONTROL register */
;;;571        tmpreg_CONTROL &= ~CAN_CONTROL_CAN_EN;
00000c  f0210101          BIC      r1,r1,#1
                  |L3.16|
;;;572      }
;;;573    
;;;574      /* Configure CONTROL register with new value */
;;;575      CANx->CONTROL = tmpreg_CONTROL;
000010  6001              STR      r1,[r0,#0]
;;;576    }
000012  4770              BX       lr
;;;577    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=1

                  CAN_DeInit PROC
;;;52       */
;;;53     void CAN_DeInit(MDR_CAN_TypeDef* CANx)
000000  2200              MOVS     r2,#0
;;;54     {
;;;55       uint32_t i;
;;;56     
;;;57       /* Check the parameters */
;;;58       assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;59     
;;;60       CANx->CONTROL = 0;
000002  6002              STR      r2,[r0,#0]
;;;61       CANx->STATUS = 0;
000004  6042              STR      r2,[r0,#4]
;;;62       CANx->BITTMNG = 0;
000006  6082              STR      r2,[r0,#8]
;;;63       CANx->INT_EN = 0;
000008  6102              STR      r2,[r0,#0x10]
;;;64       CANx->OVER = 0;
00000a  61c2              STR      r2,[r0,#0x1c]
;;;65       CANx->INT_RX = 0;
00000c  f8c020c0          STR      r2,[r0,#0xc0]
;;;66       CANx->INT_TX = 0;
000010  f8c020c8          STR      r2,[r0,#0xc8]
;;;67     
;;;68       for (i = 0; i < 32; i++)
000014  2100              MOVS     r1,#0
000016  e005              B        |L4.36|
                  |L4.24|
;;;69       {
;;;70         CANx->BUF_CON[i] = 0;
000018  2300              MOVS     r3,#0
00001a  f1000240          ADD      r2,r0,#0x40
00001e  f8423021          STR      r3,[r2,r1,LSL #2]
000022  1c49              ADDS     r1,r1,#1              ;68
                  |L4.36|
000024  2920              CMP      r1,#0x20              ;68
000026  d3f7              BCC      |L4.24|
;;;71       }
;;;72     }
000028  4770              BX       lr
;;;73     
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=1

                  CAN_FilterInit PROC
;;;184      */
;;;185    void CAN_FilterInit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;186    {
;;;187      /* Check the parameters */
;;;188      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;189      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;190      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Filter_ID));
;;;191      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Mask_ID));
;;;192    
;;;193      CANx->CAN_BUF_FILTER[BufferNumber].FILTER  = CAN_FilterInitStruct->Filter_ID;
000002  f50063a0          ADD      r3,r0,#0x500
000006  eb0303c1          ADD      r3,r3,r1,LSL #3
00000a  6814              LDR      r4,[r2,#0]
00000c  605c              STR      r4,[r3,#4]
;;;194      CANx->CAN_BUF_FILTER[BufferNumber].MASK    = CAN_FilterInitStruct->Mask_ID;
00000e  f50063a0          ADD      r3,r0,#0x500
000012  6854              LDR      r4,[r2,#4]
000014  f8434031          STR      r4,[r3,r1,LSL #3]
;;;195    }
000018  bd10              POP      {r4,pc}
;;;196    
                          ENDP


                          AREA ||i.CAN_GetBufferStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetBufferStatus PROC
;;;600      */
;;;601    uint32_t CAN_GetBufferStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  4602              MOV      r2,r0
;;;602    {
;;;603      /* Check the parameters */
;;;604      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;605      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;606    
;;;607      return CANx->BUF_CON[BufferNumber];
000002  f1020040          ADD      r0,r2,#0x40
000006  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;608    }
00000a  4770              BX       lr
;;;609    
                          ENDP


                          AREA ||i.CAN_GetDisabledBuffer||, CODE, READONLY, ALIGN=1

                  CAN_GetDisabledBuffer PROC
;;;234      */
;;;235    uint32_t CAN_GetDisabledBuffer(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;236    {
;;;237      uint32_t buffer_number;
;;;238    
;;;239      /* Check the parameters */
;;;240      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;241    
;;;242      for (buffer_number = 0;
000002  2000              MOVS     r0,#0
000004  e000              B        |L7.8|
                  |L7.6|
;;;243    	  ((buffer_number < CAN_BUFFER_NUMBER) &&  ((CANx->BUF_CON[buffer_number] & CAN_STATUS_EN) != 0));
;;;244           buffer_number++)
000006  1c40              ADDS     r0,r0,#1
                  |L7.8|
000008  2820              CMP      r0,#0x20              ;243
00000a  d207              BCS      |L7.28|
00000c  f1010240          ADD      r2,r1,#0x40           ;243
000010  f8522020          LDR      r2,[r2,r0,LSL #2]     ;243
000014  f0020201          AND      r2,r2,#1              ;243
000018  2a00              CMP      r2,#0                 ;243
00001a  d1f4              BNE      |L7.6|
                  |L7.28|
;;;245      {
;;;246      }
;;;247    
;;;248      return buffer_number;
;;;249    }
00001c  4770              BX       lr
;;;250    
                          ENDP


                          AREA ||i.CAN_GetEmptyTransferBuffer||, CODE, READONLY, ALIGN=1

                  CAN_GetEmptyTransferBuffer PROC
;;;258      */
;;;259    uint32_t CAN_GetEmptyTransferBuffer(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;260    {
;;;261      uint32_t buffer_number;
;;;262    
;;;263      /* Check the parameters */
;;;264      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;265    
;;;266      for (buffer_number = 0; (buffer_number < CAN_BUFFER_NUMBER) &&
000002  2000              MOVS     r0,#0
000004  e000              B        |L8.8|
                  |L8.6|
;;;267            ((CANx->BUF_CON[buffer_number] & (CAN_STATUS_EN | CAN_STATUS_TX_REQ | CAN_STATUS_RX_TXn)) != CAN_STATUS_EN);
;;;268            buffer_number++)
000006  1c40              ADDS     r0,r0,#1
                  |L8.8|
000008  2820              CMP      r0,#0x20              ;266
00000a  d207              BCS      |L8.28|
00000c  f1010240          ADD      r2,r1,#0x40           ;267
000010  f8522020          LDR      r2,[r2,r0,LSL #2]     ;267
000014  f0020223          AND      r2,r2,#0x23           ;267
000018  2a01              CMP      r2,#1                 ;267
00001a  d1f4              BNE      |L8.6|
                  |L8.28|
;;;269      {
;;;270      }
;;;271      return buffer_number;
;;;272    }
00001c  4770              BX       lr
;;;273    
                          ENDP


                          AREA ||i.CAN_GetITState||, CODE, READONLY, ALIGN=1

                  CAN_GetITState PROC
;;;619      */
;;;620    ITStatus CAN_GetITState(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  4602              MOV      r2,r0
;;;621    {
;;;622      ITStatus bitstatus;
;;;623    
;;;624      /* Check the parameters */
;;;625      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;626      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;627    
;;;628      if ((CANx->INT_EN & CAN_IT) == 0)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b90b              CBNZ     r3,|L9.12|
;;;629      {
;;;630        bitstatus = RESET;
000008  2000              MOVS     r0,#0
00000a  e000              B        |L9.14|
                  |L9.12|
;;;631      }
;;;632      else
;;;633      {
;;;634        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;635      }
;;;636    
;;;637      return bitstatus;
;;;638    }
00000e  4770              BX       lr
;;;639    
                          ENDP


                          AREA ||i.CAN_GetRawReceivedData||, CODE, READONLY, ALIGN=1

                  CAN_GetRawReceivedData PROC
;;;488      */
;;;489    void CAN_GetRawReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RxMsgTypeDef* RxMessage)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;490    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;491      uint32_t tmpreg;
;;;492    
;;;493      /* Check the parameters */
;;;494      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;495      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;496    
;;;497      /* Get the DLC */
;;;498      tmpreg = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DLC));
00000a  f5057100          ADD      r1,r5,#0x200
00000e  eb011106          ADD      r1,r1,r6,LSL #4
000012  1d08              ADDS     r0,r1,#4
000014  f7fffffe          BL       CAN_ReadBufferSFR
000018  4607              MOV      r7,r0
;;;499    
;;;500      RxMessage->Rx_Header.DLC = (uint8_t)(tmpreg & CAN_DLC_DATA_LENGTH);
00001a  f007000f          AND      r0,r7,#0xf
00001e  71a0              STRB     r0,[r4,#6]
;;;501      /* Get the IDE */
;;;502      RxMessage->Rx_Header.IDE = CAN_ID_STD;
000020  2000              MOVS     r0,#0
000022  7160              STRB     r0,[r4,#5]
;;;503      if ((tmpreg & CAN_DLC_IDE) != 0)
000024  f4075080          AND      r0,r7,#0x1000
000028  b108              CBZ      r0,|L10.46|
;;;504      {
;;;505        RxMessage->Rx_Header.IDE = CAN_ID_EXT;
00002a  2001              MOVS     r0,#1
00002c  7160              STRB     r0,[r4,#5]
                  |L10.46|
;;;506      }
;;;507      /* Get the OVER_EN */
;;;508      RxMessage->Rx_Header.OVER_EN = DISABLE;
00002e  2000              MOVS     r0,#0
000030  7120              STRB     r0,[r4,#4]
;;;509      tmpreg = CAN_ReadBufferSFR(&(CANx->BUF_CON[BufferNumber]));
000032  f1050140          ADD      r1,r5,#0x40
000036  eb010086          ADD      r0,r1,r6,LSL #2
00003a  f7fffffe          BL       CAN_ReadBufferSFR
00003e  4607              MOV      r7,r0
;;;510      if ((tmpreg & CAN_BUF_CON_OVER_EN) != 0)
000040  f0070004          AND      r0,r7,#4
000044  b108              CBZ      r0,|L10.74|
;;;511      {
;;;512        RxMessage->Rx_Header.OVER_EN = ENABLE;
000046  2001              MOVS     r0,#1
000048  7120              STRB     r0,[r4,#4]
                  |L10.74|
;;;513      }
;;;514      /* Get the Id */
;;;515      RxMessage->Rx_Header.ID = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].ID));
00004a  f5057100          ADD      r1,r5,#0x200
00004e  eb011006          ADD      r0,r1,r6,LSL #4
000052  f7fffffe          BL       CAN_ReadBufferSFR
000056  6020              STR      r0,[r4,#0]
;;;516    
;;;517      /* Get the data field */
;;;518      RxMessage->Data[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
000058  f5057100          ADD      r1,r5,#0x200
00005c  eb011106          ADD      r1,r1,r6,LSL #4
000060  f1010008          ADD      r0,r1,#8
000064  f7fffffe          BL       CAN_ReadBufferSFR
000068  60a0              STR      r0,[r4,#8]
;;;519      RxMessage->Data[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
00006a  f5057100          ADD      r1,r5,#0x200
00006e  eb011106          ADD      r1,r1,r6,LSL #4
000072  f101000c          ADD      r0,r1,#0xc
000076  f7fffffe          BL       CAN_ReadBufferSFR
00007a  60e0              STR      r0,[r4,#0xc]
;;;520    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;521    
                          ENDP


                          AREA ||i.CAN_GetReceivedData||, CODE, READONLY, ALIGN=1

                  CAN_GetReceivedData PROC
;;;469      */
;;;470    void CAN_GetReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_DataTypeDef RxBuffer)
000000  b570              PUSH     {r4-r6,lr}
;;;471    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;472      /* Check the parameters */
;;;473      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;474      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;475    
;;;476      RxBuffer[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
000008  f5047100          ADD      r1,r4,#0x200
00000c  eb011105          ADD      r1,r1,r5,LSL #4
000010  f1010008          ADD      r0,r1,#8
000014  f7fffffe          BL       CAN_ReadBufferSFR
000018  6030              STR      r0,[r6,#0]
;;;477      RxBuffer[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
00001a  f5047100          ADD      r1,r4,#0x200
00001e  eb011105          ADD      r1,r1,r5,LSL #4
000022  f101000c          ADD      r0,r1,#0xc
000026  f7fffffe          BL       CAN_ReadBufferSFR
00002a  6070              STR      r0,[r6,#4]
;;;478    }
00002c  bd70              POP      {r4-r6,pc}
;;;479    
                          ENDP


                          AREA ||i.CAN_GetRx||, CODE, READONLY, ALIGN=1

                  CAN_GetRx PROC
;;;732      */
;;;733    uint32_t CAN_GetRx(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;737    
;;;738      return CANx->RX;
000002  f8d100c4          LDR      r0,[r1,#0xc4]
;;;739    }
000006  4770              BX       lr
;;;740    
                          ENDP


                          AREA ||i.CAN_GetRxITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetRxITStatus PROC
;;;705      */
;;;706    ITStatus CAN_GetRxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  b510              PUSH     {r4,lr}
;;;707    {
000002  4602              MOV      r2,r0
;;;708      FlagStatus bitstatus;
;;;709    
;;;710      /* Check the parameters */
;;;711      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;712      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;713    
;;;714      if ((CANx->RX & CANx->INT_RX & (((uint32_t)0x1) << BufferNumber)) == 0)
000004  f8d230c4          LDR      r3,[r2,#0xc4]
000008  f8d240c0          LDR      r4,[r2,#0xc0]
00000c  4023              ANDS     r3,r3,r4
00000e  2401              MOVS     r4,#1
000010  408c              LSLS     r4,r4,r1
000012  4023              ANDS     r3,r3,r4
000014  b90b              CBNZ     r3,|L13.26|
;;;715      {
;;;716        bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e000              B        |L13.28|
                  |L13.26|
;;;717      }
;;;718      else
;;;719      {
;;;720        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L13.28|
;;;721      }
;;;722    
;;;723      return bitstatus;
;;;724    }
00001c  bd10              POP      {r4,pc}
;;;725    
                          ENDP


                          AREA ||i.CAN_GetStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetStatus PROC
;;;584      */
;;;585    uint32_t CAN_GetStatus(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;586    {
;;;587      /* Check the parameters */
;;;588      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;589    
;;;590      return CANx->STATUS;
000002  6848              LDR      r0,[r1,#4]
;;;591    }
000004  4770              BX       lr
;;;592    
                          ENDP


                          AREA ||i.CAN_GetTxITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetTxITStatus PROC
;;;782      */
;;;783    ITStatus CAN_GetTxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  b510              PUSH     {r4,lr}
;;;784    {
000002  4602              MOV      r2,r0
;;;785      FlagStatus bitstatus;
;;;786    
;;;787      /* Check the parameters */
;;;788      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;789      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;790    
;;;791      if ((CANx->TX & CANx->INT_TX & (((uint32_t)0x1) << BufferNumber)) == 0)
000004  f8d230cc          LDR      r3,[r2,#0xcc]
000008  f8d240c8          LDR      r4,[r2,#0xc8]
00000c  4023              ANDS     r3,r3,r4
00000e  2401              MOVS     r4,#1
000010  408c              LSLS     r4,r4,r1
000012  4023              ANDS     r3,r3,r4
000014  b90b              CBNZ     r3,|L15.26|
;;;792      {
;;;793        bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e000              B        |L15.28|
                  |L15.26|
;;;794      }
;;;795      else
;;;796      {
;;;797        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L15.28|
;;;798      }
;;;799    
;;;800      return bitstatus;
;;;801    }
00001c  bd10              POP      {r4,pc}
;;;802    
                          ENDP


                          AREA ||i.CAN_ITClearErrorPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ITClearErrorPendingBit PROC
;;;654      */
;;;655    void CAN_ITClearErrorPendingBit(MDR_CAN_TypeDef* CANx, uint32_t Status_Flag)
000000  6842              LDR      r2,[r0,#4]
;;;656    {
;;;657      /* Check the parameters */
;;;658      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;659      assert_param(IS_CAN_IT_ERROR_FLAG(Status_Flag));
;;;660    
;;;661      CANx->STATUS &= ~Status_Flag;
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;662    }
000006  4770              BX       lr
;;;663    
                          ENDP


                          AREA ||i.CAN_ITClearRxTxPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ITClearRxTxPendingBit PROC
;;;815      */
;;;816    void CAN_ITClearRxTxPendingBit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, uint32_t Status_Flag)
000000  b510              PUSH     {r4,lr}
;;;817    {
;;;818      uint32_t tmpreg;
;;;819    
;;;820      /* Check the parameters */
;;;821      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;822      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;823      assert_param(IS_CAN_IT_RXTX_FLAG(Status_Flag));
;;;824    
;;;825      tmpreg = CANx->BUF_CON[BufferNumber];
000002  f1000440          ADD      r4,r0,#0x40
000006  f8543021          LDR      r3,[r4,r1,LSL #2]
;;;826    
;;;827      if (Status_Flag == CAN_STATUS_RX_READY)
00000a  2a01              CMP      r2,#1
00000c  d102              BNE      |L17.20|
;;;828      {
;;;829        tmpreg &= ~CAN_STATUS_RX_FULL;
00000e  f0230340          BIC      r3,r3,#0x40
000012  e003              B        |L17.28|
                  |L17.20|
;;;830      }
;;;831      else if (Status_Flag == CAN_STATUS_TX_READY)
000014  2a02              CMP      r2,#2
000016  d101              BNE      |L17.28|
;;;832      {
;;;833        tmpreg |= CAN_STATUS_TX_REQ;
000018  f0430320          ORR      r3,r3,#0x20
                  |L17.28|
;;;834      }
;;;835    
;;;836      CANx->BUF_CON[BufferNumber] = tmpreg;
00001c  f1000440          ADD      r4,r0,#0x40
000020  f8443021          STR      r3,[r4,r1,LSL #2]
;;;837    }
000024  bd10              POP      {r4,pc}
;;;838    
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;208      */
;;;209    void CAN_ITConfig(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L18.10|
;;;210    {
;;;211      /* Check the parameters */
;;;212      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;213      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;214      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;215    
;;;216      if (NewState != DISABLE)
;;;217      {
;;;218        CANx->INT_EN |= CAN_IT;
000002  6903              LDR      r3,[r0,#0x10]
000004  430b              ORRS     r3,r3,r1
000006  6103              STR      r3,[r0,#0x10]
000008  e002              B        |L18.16|
                  |L18.10|
;;;219      }
;;;220      else
;;;221      {
;;;222        CANx->INT_EN &= ~CAN_IT;
00000a  6903              LDR      r3,[r0,#0x10]
00000c  438b              BICS     r3,r3,r1
00000e  6103              STR      r3,[r0,#0x10]
                  |L18.16|
;;;223      }
;;;224    }
000010  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;86       */
;;;87     void CAN_Init(MDR_CAN_TypeDef* CANx, const CAN_InitTypeDef* CAN_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
;;;89       uint32_t tmpreg_CONTROL = 0;
000002  2200              MOVS     r2,#0
;;;90       uint32_t tmpreg_BITTMNG;
;;;91       uint32_t i;
;;;92     
;;;93       /* Check the parameters */
;;;94       assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;95       assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROP));
;;;96       assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_SAP));
;;;97       assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_STM));
;;;98       assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROM));
;;;99       assert_param(IS_CAN_PSEG_VALUE(CAN_InitStruct->CAN_PSEG));
;;;100      assert_param(IS_CAN_SEG1_VALUE(CAN_InitStruct->CAN_SEG1));
;;;101      assert_param(IS_CAN_SEG2_VALUE(CAN_InitStruct->CAN_SEG2));
;;;102      assert_param(IS_CAN_SJW_VALUE(CAN_InitStruct->CAN_SJW));
;;;103      assert_param(IS_CAN_SAMPLING_MODE(CAN_InitStruct->CAN_SB));
;;;104    
;;;105      /* Configure CONTROL register*/
;;;106      if (CAN_InitStruct->CAN_ROP != DISABLE)
000004  780d              LDRB     r5,[r1,#0]
000006  b10d              CBZ      r5,|L19.12|
;;;107      {
;;;108        tmpreg_CONTROL |= CAN_CONTROL_ROP;
000008  f0420210          ORR      r2,r2,#0x10
                  |L19.12|
;;;109      }
;;;110      if (CAN_InitStruct->CAN_SAP != DISABLE)
00000c  784d              LDRB     r5,[r1,#1]
00000e  b10d              CBZ      r5,|L19.20|
;;;111      {
;;;112        tmpreg_CONTROL |= CAN_CONTROL_SAP;
000010  f0420208          ORR      r2,r2,#8
                  |L19.20|
;;;113      }
;;;114      if (CAN_InitStruct->CAN_STM != DISABLE)
000014  788d              LDRB     r5,[r1,#2]
000016  b10d              CBZ      r5,|L19.28|
;;;115      {
;;;116        tmpreg_CONTROL |= CAN_CONTROL_STM;
000018  f0420204          ORR      r2,r2,#4
                  |L19.28|
;;;117      }
;;;118      if (CAN_InitStruct->CAN_ROM != DISABLE)
00001c  78cd              LDRB     r5,[r1,#3]
00001e  b10d              CBZ      r5,|L19.36|
;;;119      {
;;;120        tmpreg_CONTROL |= CAN_CONTROL_ROM;
000020  f0420202          ORR      r2,r2,#2
                  |L19.36|
;;;121      }
;;;122      CANx->CONTROL = tmpreg_CONTROL;
000024  6002              STR      r2,[r0,#0]
;;;123    
;;;124      /* Configure BITTMNG register*/
;;;125      tmpreg_BITTMNG = CAN_InitStruct->CAN_PSEG + CAN_InitStruct->CAN_SEG1 +
000026  e9d15601          LDRD     r5,r6,[r1,#4]
00002a  4435              ADD      r5,r5,r6
00002c  68ce              LDR      r6,[r1,#0xc]
00002e  4435              ADD      r5,r5,r6
000030  690e              LDR      r6,[r1,#0x10]
000032  4435              ADD      r5,r5,r6
000034  8b0e              LDRH     r6,[r1,#0x18]
000036  19ac              ADDS     r4,r5,r6
;;;126                       CAN_InitStruct->CAN_SEG2 + CAN_InitStruct->CAN_SJW +
;;;127                       (uint32_t)(CAN_InitStruct->CAN_BRP);
;;;128      tmpreg_BITTMNG |= CAN_InitStruct->CAN_SB;
000038  694d              LDR      r5,[r1,#0x14]
00003a  432c              ORRS     r4,r4,r5
;;;129      CANx->BITTMNG = tmpreg_BITTMNG;
00003c  6084              STR      r4,[r0,#8]
;;;130    
;;;131      /* Initialize Filters */
;;;132      for (i = 0; i < 32; i++)
00003e  2300              MOVS     r3,#0
000040  e00a              B        |L19.88|
                  |L19.66|
;;;133      {
;;;134        CANx->CAN_BUF_FILTER[i].FILTER = 0;
000042  2600              MOVS     r6,#0
000044  f50065a0          ADD      r5,r0,#0x500
000048  eb0505c3          ADD      r5,r5,r3,LSL #3
00004c  606e              STR      r6,[r5,#4]
;;;135        CANx->CAN_BUF_FILTER[i].MASK = 0;
00004e  f50065a0          ADD      r5,r0,#0x500
000052  f8456033          STR      r6,[r5,r3,LSL #3]
000056  1c5b              ADDS     r3,r3,#1              ;132
                  |L19.88|
000058  2b20              CMP      r3,#0x20              ;132
00005a  d3f2              BCC      |L19.66|
;;;136      }
;;;137    
;;;138      /* Configure OVER register*/
;;;139      CANx->OVER = (uint32_t)(CAN_InitStruct->CAN_OVER_ERROR_MAX);
00005c  7e8d              LDRB     r5,[r1,#0x1a]
00005e  61c5              STR      r5,[r0,#0x1c]
;;;140    }
000060  bd70              POP      {r4-r6,pc}
;;;141    
                          ENDP


                          AREA ||i.CAN_RTRReply||, CODE, READONLY, ALIGN=1

                  CAN_RTRReply PROC
;;;388    
;;;389    void CAN_RTRReply(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRReplyTypeDef* RTRReplyMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;390    {
;;;391      uint32_t tmpreg;
;;;392    
;;;393      /* Check the parameters */
;;;394      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;395      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;396      assert_param(IS_CAN_IDTYPE(RTRReplyMessage->IDE));
;;;397      assert_param(IS_CAN_ID(RTRReplyMessage->ID));
;;;398      assert_param(IS_CAN_DLC(RTRReplyMessage->DLC));
;;;399    
;;;400      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;401      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;402      /* Packet format */
;;;403      if (RTRReplyMessage->IDE == CAN_ID_STD)
000002  7914              LDRB     r4,[r2,#4]
000004  b91c              CBNZ     r4,|L20.14|
;;;404      {
;;;405        /* Standard */
;;;406        tmpreg = CAN_BUF_DLC_STD + RTRReplyMessage->DLC;
000006  7954              LDRB     r4,[r2,#5]
000008  f5046320          ADD      r3,r4,#0xa00
00000c  e002              B        |L20.20|
                  |L20.14|
;;;407      }
;;;408      else
;;;409      {
;;;410        /* Extended */
;;;411        tmpreg = CAN_BUF_DLC_EXT + RTRReplyMessage->DLC;
00000e  7954              LDRB     r4,[r2,#5]
000010  f50453d0          ADD      r3,r4,#0x1a00
                  |L20.20|
;;;412      }
;;;413      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
000014  f5007400          ADD      r4,r0,#0x200
000018  eb041401          ADD      r4,r4,r1,LSL #4
00001c  6063              STR      r3,[r4,#4]
;;;414      CANx->CAN_BUF[BufferNumber].ID  = RTRReplyMessage->ID;
00001e  f5007400          ADD      r4,r0,#0x200
000022  eb041401          ADD      r4,r4,r1,LSL #4
000026  6815              LDR      r5,[r2,#0]
000028  6025              STR      r5,[r4,#0]
;;;415    
;;;416      /* Buffer data unit */
;;;417      CANx->CAN_BUF[BufferNumber].DATAL = RTRReplyMessage->Data[0];
00002a  f5007400          ADD      r4,r0,#0x200
00002e  eb041401          ADD      r4,r4,r1,LSL #4
000032  6895              LDR      r5,[r2,#8]
000034  60a5              STR      r5,[r4,#8]
;;;418      CANx->CAN_BUF[BufferNumber].DATAH = RTRReplyMessage->Data[1];
000036  f5007400          ADD      r4,r0,#0x200
00003a  eb041401          ADD      r4,r4,r1,LSL #4
00003e  68d5              LDR      r5,[r2,#0xc]
000040  60e5              STR      r5,[r4,#0xc]
;;;419    
;;;420      /* Configure CAN_BUF_CON register */
;;;421      /* Set RTR_EN bit */
;;;422      tmpreg = CAN_STATUS_RTR_EN;
000042  2308              MOVS     r3,#8
;;;423      /* Enable buffer */
;;;424      tmpreg |= CAN_BUF_CON_EN;
000044  f0430301          ORR      r3,r3,#1
;;;425    
;;;426      CANx->BUF_CON[BufferNumber] = tmpreg;
000048  f1000440          ADD      r4,r0,#0x40
00004c  f8443021          STR      r3,[r4,r1,LSL #2]
;;;427    }
000050  bd30              POP      {r4,r5,pc}
;;;428    
                          ENDP


                          AREA ||i.CAN_ReadBufferSFR||, CODE, READONLY, ALIGN=1

                  CAN_ReadBufferSFR PROC
;;;893      */
;;;894    static __INLINE uint32_t CAN_ReadBufferSFR(__IO uint32_t* SFR)
000000  4601              MOV      r1,r0
;;;895    {
;;;896    #ifdef WORKAROUND_MDR32F9QX_ERROR_0002
;;;897      /*
;;;898       * MDR32F9Qx Series Errata Notice, Error 0002:
;;;899       * The registers CAN_BUFxx_ID, CAN_BUFxx_DLC, CAN_BUFxx_DATAL,
;;;900       * CAN_BUFxx_DATAH, CAN_BUFxx_MASK or CAN_BUFxx_FILTER value
;;;901       * may be incorrectly read as 0 if CAN controller accessed any
;;;902       * of that registers at the moment of reading.
;;;903       * In such case, another read should be performed in a time less
;;;904       * than minimum CAN package.
;;;905       */
;;;906      uint32_t tmpreg;
;;;907    
;;;908      __disable_irq();
000002  b672              CPSID    i
;;;909      tmpreg = *SFR;
000004  6808              LDR      r0,[r1,#0]
;;;910      if (tmpreg == 0)
000006  b900              CBNZ     r0,|L21.10|
;;;911      {
;;;912        tmpreg = *SFR;
000008  6808              LDR      r0,[r1,#0]
                  |L21.10|
;;;913      }
;;;914      __enable_irq();
00000a  b662              CPSIE    i
;;;915      return tmpreg;
;;;916    #else
;;;917      return *SFR;
;;;918    #endif  /* WORKAROUND_MDR32F9QX_ERROR_0002 */
;;;919    }
00000c  4770              BX       lr
;;;920    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;439      */
;;;440    void CAN_Receive(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, FunctionalState OverWrite)
000000  b510              PUSH     {r4,lr}
;;;441    {
;;;442      uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;443    
;;;444      /* Check the parameters */
;;;445      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;446      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;447      assert_param(IS_FUNCTIONAL_STATE(OverWrite));
;;;448    
;;;449      /* Configure CAN_BUF_CON register */
;;;450      /* Overwrite mode */
;;;451      if (OverWrite != DISABLE)
000004  b102              CBZ      r2,|L22.8|
;;;452      {
;;;453        tmpreg = CAN_BUF_CON_OVER_EN;
000006  2304              MOVS     r3,#4
                  |L22.8|
;;;454      }
;;;455      /* Configure buffer for receiving and enable it */
;;;456      tmpreg |= CAN_BUF_CON_RX_TXN | CAN_BUF_CON_EN;
000008  f0430303          ORR      r3,r3,#3
;;;457    
;;;458      CANx->BUF_CON[BufferNumber] = tmpreg;
00000c  f1000440          ADD      r4,r0,#0x40
000010  f8443021          STR      r3,[r4,r1,LSL #2]
;;;459    }
000014  bd10              POP      {r4,pc}
;;;460    
                          ENDP


                          AREA ||i.CAN_RxITConfig||, CODE, READONLY, ALIGN=1

                  CAN_RxITConfig PROC
;;;675      */
;;;676    void CAN_RxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;677    {
000002  4613              MOV      r3,r2
;;;678      uint32_t tmpreg;
;;;679    
;;;680      /* Check the parameters */
;;;681      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;682      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;683    
;;;684      tmpreg = CANx->INT_RX;
000004  f8d020c0          LDR      r2,[r0,#0xc0]
;;;685    
;;;686      if (NewState != DISABLE)
000008  b10b              CBZ      r3,|L23.14|
;;;687      {
;;;688        tmpreg |= Buffer_IT;
00000a  430a              ORRS     r2,r2,r1
00000c  e000              B        |L23.16|
                  |L23.14|
;;;689      }
;;;690      else
;;;691      {
;;;692        tmpreg &= ~Buffer_IT;
00000e  438a              BICS     r2,r2,r1
                  |L23.16|
;;;693      }
;;;694    
;;;695      CANx->INT_RX = tmpreg;
000010  f8c020c0          STR      r2,[r0,#0xc0]
;;;696    }
000014  bd10              POP      {r4,pc}
;;;697    
                          ENDP


                          AREA ||i.CAN_SendRTR||, CODE, READONLY, ALIGN=1

                  CAN_SendRTR PROC
;;;337      */
;;;338    void CAN_SendRTR(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRMessageTypeDef* RTRMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;339    {
000002  4603              MOV      r3,r0
;;;340      uint32_t tmpreg;
;;;341    
;;;342      /* Check the parameters */
;;;343      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;344      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;345      assert_param(IS_CAN_IDTYPE(RTRMessage->IDE));
;;;346      assert_param(IS_FUNCTIONAL_STATE(RTRMessage->PRIOR_0));
;;;347      assert_param(IS_CAN_ID(RTRMessage->ID));
;;;348    
;;;349      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;350      /* Packet format */
;;;351      if (RTRMessage->IDE == CAN_ID_STD)
000004  7954              LDRB     r4,[r2,#5]
000006  b914              CBNZ     r4,|L24.14|
;;;352      {
;;;353        /* Standard */
;;;354        tmpreg = CAN_BUF_DLC_STD;
000008  f44f6020          MOV      r0,#0xa00
00000c  e001              B        |L24.18|
                  |L24.14|
;;;355      }
;;;356      else
;;;357      {
;;;358        /* Extended */
;;;359        tmpreg = CAN_BUF_DLC_EXT;
00000e  f44f50d0          MOV      r0,#0x1a00
                  |L24.18|
;;;360      }
;;;361      CANx->CAN_BUF[BufferNumber].DLC = tmpreg + CAN_RTR_REMOTE;
000012  f5007480          ADD      r4,r0,#0x100
000016  f5037500          ADD      r5,r3,#0x200
00001a  eb051501          ADD      r5,r5,r1,LSL #4
00001e  606c              STR      r4,[r5,#4]
;;;362      CANx->CAN_BUF[BufferNumber].ID  = RTRMessage->ID;
000020  f5037400          ADD      r4,r3,#0x200
000024  eb041401          ADD      r4,r4,r1,LSL #4
000028  6815              LDR      r5,[r2,#0]
00002a  6025              STR      r5,[r4,#0]
;;;363    
;;;364      /* Configure CAN_BUF_CON register */
;;;365      tmpreg = 0;
00002c  2000              MOVS     r0,#0
;;;366      /* Transmission priority */
;;;367      if (RTRMessage->PRIOR_0 != DISABLE)
00002e  7914              LDRB     r4,[r2,#4]
000030  b10c              CBZ      r4,|L24.54|
;;;368      {
;;;369        tmpreg |= CAN_BUF_CON_PRIOR_0;
000032  f0400010          ORR      r0,r0,#0x10
                  |L24.54|
;;;370      }
;;;371      /* Set transmission request bit */
;;;372      tmpreg |= CAN_BUF_CON_TX_REQ;
000036  f0400020          ORR      r0,r0,#0x20
;;;373      /* Enable buffer */
;;;374      tmpreg |= CAN_BUF_CON_EN;
00003a  f0400001          ORR      r0,r0,#1
;;;375    
;;;376      CANx->BUF_CON[BufferNumber] = tmpreg;
00003e  f1030440          ADD      r4,r3,#0x40
000042  f8440021          STR      r0,[r4,r1,LSL #2]
;;;377    }
000046  bd30              POP      {r4,r5,pc}
;;;378    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;147      */
;;;148    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;149    {
;;;150      /* Reset CAN init structure parameters values */
;;;151      /* Own packet reception: disabled */
;;;152      CAN_InitStruct->CAN_ROP = DISABLE;
000002  7001              STRB     r1,[r0,#0]
;;;153      /* Sending ACK on own packets: disabled */
;;;154      CAN_InitStruct->CAN_SAP = DISABLE;
000004  7041              STRB     r1,[r0,#1]
;;;155      /* Self Test mode: disabled */
;;;156      CAN_InitStruct->CAN_STM = DISABLE;
000006  7081              STRB     r1,[r0,#2]
;;;157      /* Read Only mode: disabled */
;;;158      CAN_InitStruct->CAN_ROM = DISABLE;
000008  70c1              STRB     r1,[r0,#3]
;;;159      /* CAN_PSEG member */
;;;160      CAN_InitStruct->CAN_PSEG = CAN_PSEG_Mul_1TQ;
00000a  6041              STR      r1,[r0,#4]
;;;161      /* CAN_SEG1 member */
;;;162      CAN_InitStruct->CAN_SEG1 = CAN_SEG1_Mul_2TQ;
00000c  f44f2100          MOV      r1,#0x80000
000010  6081              STR      r1,[r0,#8]
;;;163      /* CAN_SEG2 member */
;;;164      CAN_InitStruct->CAN_SEG2 = CAN_SEG2_Mul_6TQ;
000012  f04f71a0          MOV      r1,#0x1400000
000016  60c1              STR      r1,[r0,#0xc]
;;;165      /* CAN_SEG2 member */
;;;166      CAN_InitStruct->CAN_SJW = CAN_SJW_Mul_1TQ;
000018  2100              MOVS     r1,#0
00001a  6101              STR      r1,[r0,#0x10]
;;;167      /* Sampling mode member */
;;;168      CAN_InitStruct->CAN_SB = CAN_SB_1_SAMPLE;
00001c  6141              STR      r1,[r0,#0x14]
;;;169      /* CAN_BRP member */
;;;170      CAN_InitStruct->CAN_BRP = 0;
00001e  8301              STRH     r1,[r0,#0x18]
;;;171      /* CAN_OVER_ERROR_MAX member */
;;;172      CAN_InitStruct->CAN_OVER_ERROR_MAX = 255;
000020  21ff              MOVS     r1,#0xff
000022  7681              STRB     r1,[r0,#0x1a]
;;;173    }
000024  4770              BX       lr
;;;174    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;282      */
;;;283    void CAN_Transmit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_TxMsgTypeDef* TxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;284    {
000002  4603              MOV      r3,r0
;;;285      uint32_t tmpreg;
;;;286    
;;;287      /* Check the parameters */
;;;288      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;289      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;290      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;291      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;292      assert_param(IS_FUNCTIONAL_STATE(TxMessage->PRIOR_0));
;;;293      assert_param(IS_CAN_ID(TxMessage->ID));
;;;294    
;;;295      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;296      /* Packet format */
;;;297      if (TxMessage->IDE == CAN_ID_STD)
000004  7954              LDRB     r4,[r2,#5]
000006  b91c              CBNZ     r4,|L26.16|
;;;298      {
;;;299        /* Standard */
;;;300        tmpreg = CAN_BUF_DLC_STD + TxMessage->DLC;
000008  7994              LDRB     r4,[r2,#6]
00000a  f5046020          ADD      r0,r4,#0xa00
00000e  e002              B        |L26.22|
                  |L26.16|
;;;301      }
;;;302      else
;;;303      {
;;;304        /* Extended */
;;;305        tmpreg = CAN_BUF_DLC_EXT + TxMessage->DLC;
000010  7994              LDRB     r4,[r2,#6]
000012  f50450d0          ADD      r0,r4,#0x1a00
                  |L26.22|
;;;306      }
;;;307      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
000016  f5037400          ADD      r4,r3,#0x200
00001a  eb041401          ADD      r4,r4,r1,LSL #4
00001e  6060              STR      r0,[r4,#4]
;;;308      CANx->CAN_BUF[BufferNumber].ID  = TxMessage->ID;
000020  f5037400          ADD      r4,r3,#0x200
000024  eb041401          ADD      r4,r4,r1,LSL #4
000028  6815              LDR      r5,[r2,#0]
00002a  6025              STR      r5,[r4,#0]
;;;309    
;;;310      /* Buffer data unit */
;;;311      CANx->CAN_BUF[BufferNumber].DATAL = TxMessage->Data[0];
00002c  f5037400          ADD      r4,r3,#0x200
000030  eb041401          ADD      r4,r4,r1,LSL #4
000034  6895              LDR      r5,[r2,#8]
000036  60a5              STR      r5,[r4,#8]
;;;312      CANx->CAN_BUF[BufferNumber].DATAH = TxMessage->Data[1];
000038  f5037400          ADD      r4,r3,#0x200
00003c  eb041401          ADD      r4,r4,r1,LSL #4
000040  68d5              LDR      r5,[r2,#0xc]
000042  60e5              STR      r5,[r4,#0xc]
;;;313    
;;;314      /* Configure CAN_BUF_CON register */
;;;315      tmpreg = 0;
000044  2000              MOVS     r0,#0
;;;316      /* Transmission priority */
;;;317      if (TxMessage->PRIOR_0 != DISABLE)
000046  7914              LDRB     r4,[r2,#4]
000048  b10c              CBZ      r4,|L26.78|
;;;318      {
;;;319        tmpreg |= CAN_BUF_CON_PRIOR_0;
00004a  f0400010          ORR      r0,r0,#0x10
                  |L26.78|
;;;320      }
;;;321      /* Set transmission request bit */
;;;322      tmpreg |= CAN_BUF_CON_TX_REQ;
00004e  f0400020          ORR      r0,r0,#0x20
;;;323      /* Enable buffer */
;;;324      tmpreg |= CAN_BUF_CON_EN;
000052  f0400001          ORR      r0,r0,#1
;;;325    
;;;326      CANx->BUF_CON[BufferNumber] = tmpreg;
000056  f1030440          ADD      r4,r3,#0x40
00005a  f8440021          STR      r0,[r4,r1,LSL #2]
;;;327    }
00005e  bd30              POP      {r4,r5,pc}
;;;328    
                          ENDP


                          AREA ||i.CAN_TxITConfig||, CODE, READONLY, ALIGN=1

                  CAN_TxITConfig PROC
;;;752      */
;;;753    void CAN_TxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;754    {
000002  4613              MOV      r3,r2
;;;755      uint32_t tmpreg;
;;;756    
;;;757      /* Check the parameters */
;;;758      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;759      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;760    
;;;761      tmpreg = CANx->INT_TX;
000004  f8d020c8          LDR      r2,[r0,#0xc8]
;;;762    
;;;763      if (NewState != DISABLE)
000008  b10b              CBZ      r3,|L27.14|
;;;764      {
;;;765        tmpreg |= Buffer_IT;
00000a  430a              ORRS     r2,r2,r1
00000c  e000              B        |L27.16|
                  |L27.14|
;;;766      }
;;;767      else
;;;768      {
;;;769        tmpreg &= ~Buffer_IT;
00000e  438a              BICS     r2,r2,r1
                  |L27.16|
;;;770      }
;;;771    
;;;772      CANx->INT_TX = tmpreg;
000010  f8c020c8          STR      r2,[r0,#0xc8]
;;;773    }
000014  bd10              POP      {r4,pc}
;;;774    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_can_c_347dae01____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REVSH|
#line 482
|__asm___15_MDR32F9Qx_can_c_347dae01____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____RRX|
#line 669
|__asm___15_MDR32F9Qx_can_c_347dae01____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
