; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_can.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_can.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_can.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_can.c]
                          THUMB

                          AREA ||i.CAN_BRGInit||, CODE, READONLY, ALIGN=2

                  CAN_BRGInit PROC
;;;875      */
;;;876    void CAN_BRGInit(MDR_CAN_TypeDef* CANx, uint32_t CAN_BRG)
000000  4602              MOV      r2,r0
;;;877    {
;;;878      uint32_t tmpreg;
;;;879    
;;;880      /* Check the parameters */
;;;881      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;882      assert_param(IS_CAN_CLOCK_BRG(CAN_BRG));
;;;883    
;;;884      tmpreg = MDR_RST_CLK->CAN_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6a18              LDR      r0,[r3,#0x20]
;;;885    
;;;886      if (CANx == MDR_CAN1)
000006  f1b24f80          CMP      r2,#0x40000000
00000a  d105              BNE      |L1.24|
;;;887      {
;;;888        tmpreg |= RST_CLK_CAN_CLOCK_CAN1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;889        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;890        tmpreg |= CAN_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;891      }
;;;892      else if (CANx == MDR_CAN2)
000018  4b06              LDR      r3,|L1.52|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;893      {
;;;894        tmpreg |= RST_CLK_CAN_CLOCK_CAN2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;895        tmpreg &= ~RST_CLK_CAN_CLOCK_CAN2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;896        tmpreg |= (CAN_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;897      }
;;;898    
;;;899      MDR_RST_CLK->CAN_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  6218              STR      r0,[r3,#0x20]
;;;900    }
00002e  4770              BX       lr
;;;901    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40008000

                          AREA ||i.CAN_BufferRelease||, CODE, READONLY, ALIGN=1

                  CAN_BufferRelease PROC
;;;548      */
;;;549    void CAN_BufferRelease(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  f1000340          ADD      r3,r0,#0x40
;;;550    {
;;;551      uint32_t tmpreg;
;;;552    
;;;553      /* Check the parameters */
;;;554      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;555      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;556    
;;;557      tmpreg = CANx->BUF_CON[BufferNumber];
000004  f8532021          LDR      r2,[r3,r1,LSL #2]
;;;558      tmpreg &= ~CAN_STATUS_EN;
000008  f0220201          BIC      r2,r2,#1
;;;559      CANx->BUF_CON[BufferNumber] = tmpreg;
00000c  f8432021          STR      r2,[r3,r1,LSL #2]
;;;560    }
000010  4770              BX       lr
;;;561    
                          ENDP


                          AREA ||i.CAN_Cmd||, CODE, READONLY, ALIGN=1

                  CAN_Cmd PROC
;;;570      */
;;;571    void CAN_Cmd(MDR_CAN_TypeDef* CANx, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;572    {
;;;573      uint32_t tmpreg_CONTROL;
;;;574    
;;;575      /* Check the parameters */
;;;576      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;577      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;578    
;;;579      tmpreg_CONTROL = CANx->CONTROL;
000002  6801              LDR      r1,[r0,#0]
;;;580    
;;;581      /* Form new value */
;;;582      if (NewState != DISABLE)
000004  b112              CBZ      r2,|L3.12|
;;;583      {
;;;584        /* Enable CANx by setting the CAN_EN bit in the CONTROL register */
;;;585        tmpreg_CONTROL |= CAN_CONTROL_CAN_EN;
000006  f0410101          ORR      r1,r1,#1
00000a  e001              B        |L3.16|
                  |L3.12|
;;;586      }
;;;587      else
;;;588      {
;;;589        /* Disable CANx by resetting the CAN_EN bit in the CONTROL register */
;;;590        tmpreg_CONTROL &= ~CAN_CONTROL_CAN_EN;
00000c  f0210101          BIC      r1,r1,#1
                  |L3.16|
;;;591      }
;;;592    
;;;593      /* Configure CONTROL register with new value */
;;;594      CANx->CONTROL = tmpreg_CONTROL;
000010  6001              STR      r1,[r0,#0]
;;;595    }
000012  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.CAN_DeInit||, CODE, READONLY, ALIGN=1

                  CAN_DeInit PROC
;;;71       */
;;;72     void CAN_DeInit(MDR_CAN_TypeDef* CANx)
000000  2200              MOVS     r2,#0
;;;73     {
;;;74       uint32_t i;
;;;75     
;;;76       /* Check the parameters */
;;;77       assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;78     
;;;79       CANx->CONTROL = 0;
000002  6002              STR      r2,[r0,#0]
;;;80       CANx->STATUS = 0;
000004  6042              STR      r2,[r0,#4]
;;;81       CANx->BITTMNG = 0;
000006  6082              STR      r2,[r0,#8]
;;;82       CANx->INT_EN = 0;
000008  6102              STR      r2,[r0,#0x10]
;;;83       CANx->OVER = 0;
00000a  61c2              STR      r2,[r0,#0x1c]
;;;84       CANx->INT_RX = 0;
00000c  f8c020c0          STR      r2,[r0,#0xc0]
;;;85       CANx->INT_TX = 0;
000010  f8c020c8          STR      r2,[r0,#0xc8]
;;;86     
;;;87       for (i = 0; i < 32; i++)
000014  2100              MOVS     r1,#0
000016  e005              B        |L4.36|
                  |L4.24|
;;;88       {
;;;89         CANx->BUF_CON[i] = 0;
000018  2300              MOVS     r3,#0
00001a  f1000240          ADD      r2,r0,#0x40
00001e  f8423021          STR      r3,[r2,r1,LSL #2]
000022  1c49              ADDS     r1,r1,#1              ;87
                  |L4.36|
000024  2920              CMP      r1,#0x20              ;87
000026  d3f7              BCC      |L4.24|
;;;90       }
;;;91     }
000028  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.CAN_FilterInit||, CODE, READONLY, ALIGN=1

                  CAN_FilterInit PROC
;;;203      */
;;;204    void CAN_FilterInit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_FilterInitTypeDef* CAN_FilterInitStruct)
000000  b510              PUSH     {r4,lr}
;;;205    {
;;;206      /* Check the parameters */
;;;207      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;208      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;209      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Filter_ID));
;;;210      assert_param(IS_CAN_ID(CAN_FilterInitStruct->Mask_ID));
;;;211    
;;;212      CANx->CAN_BUF_FILTER[BufferNumber].FILTER  = CAN_FilterInitStruct->Filter_ID;
000002  f50063a0          ADD      r3,r0,#0x500
000006  eb0303c1          ADD      r3,r3,r1,LSL #3
00000a  6814              LDR      r4,[r2,#0]
00000c  605c              STR      r4,[r3,#4]
;;;213      CANx->CAN_BUF_FILTER[BufferNumber].MASK    = CAN_FilterInitStruct->Mask_ID;
00000e  f50063a0          ADD      r3,r0,#0x500
000012  6854              LDR      r4,[r2,#4]
000014  f8434031          STR      r4,[r3,r1,LSL #3]
;;;214    }
000018  bd10              POP      {r4,pc}
;;;215    
                          ENDP


                          AREA ||i.CAN_GetBufferStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetBufferStatus PROC
;;;619      */
;;;620    uint32_t CAN_GetBufferStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  4602              MOV      r2,r0
;;;621    {
;;;622      /* Check the parameters */
;;;623      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;624      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;625    
;;;626      return CANx->BUF_CON[BufferNumber];
000002  f1020040          ADD      r0,r2,#0x40
000006  f8500021          LDR      r0,[r0,r1,LSL #2]
;;;627    }
00000a  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.CAN_GetDisabledBuffer||, CODE, READONLY, ALIGN=1

                  CAN_GetDisabledBuffer PROC
;;;253      */
;;;254    uint32_t CAN_GetDisabledBuffer(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;255    {
;;;256      uint32_t buffer_number;
;;;257    
;;;258      /* Check the parameters */
;;;259      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;260    
;;;261      for (buffer_number = 0;
000002  2000              MOVS     r0,#0
000004  e000              B        |L7.8|
                  |L7.6|
;;;262    	  ((buffer_number < CAN_BUFFER_NUMBER) &&  ((CANx->BUF_CON[buffer_number] & CAN_STATUS_EN) != 0));
;;;263           buffer_number++)
000006  1c40              ADDS     r0,r0,#1
                  |L7.8|
000008  2820              CMP      r0,#0x20              ;262
00000a  d207              BCS      |L7.28|
00000c  f1010240          ADD      r2,r1,#0x40           ;262
000010  f8522020          LDR      r2,[r2,r0,LSL #2]     ;262
000014  f0020201          AND      r2,r2,#1              ;262
000018  2a00              CMP      r2,#0                 ;262
00001a  d1f4              BNE      |L7.6|
                  |L7.28|
;;;264      {
;;;265      }
;;;266    
;;;267      return buffer_number;
;;;268    }
00001c  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.CAN_GetEmptyTransferBuffer||, CODE, READONLY, ALIGN=1

                  CAN_GetEmptyTransferBuffer PROC
;;;277      */
;;;278    uint32_t CAN_GetEmptyTransferBuffer(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;279    {
;;;280      uint32_t buffer_number;
;;;281    
;;;282      /* Check the parameters */
;;;283      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;284    
;;;285      for (buffer_number = 0; (buffer_number < CAN_BUFFER_NUMBER) &&
000002  2000              MOVS     r0,#0
000004  e000              B        |L8.8|
                  |L8.6|
;;;286            ((CANx->BUF_CON[buffer_number] & (CAN_STATUS_EN | CAN_STATUS_TX_REQ | CAN_STATUS_RX_TXn)) != CAN_STATUS_EN);
;;;287            buffer_number++)
000006  1c40              ADDS     r0,r0,#1
                  |L8.8|
000008  2820              CMP      r0,#0x20              ;285
00000a  d207              BCS      |L8.28|
00000c  f1010240          ADD      r2,r1,#0x40           ;286
000010  f8522020          LDR      r2,[r2,r0,LSL #2]     ;286
000014  f0020223          AND      r2,r2,#0x23           ;286
000018  2a01              CMP      r2,#1                 ;286
00001a  d1f4              BNE      |L8.6|
                  |L8.28|
;;;288      {
;;;289      }
;;;290      return buffer_number;
;;;291    }
00001c  4770              BX       lr
;;;292    
                          ENDP


                          AREA ||i.CAN_GetITState||, CODE, READONLY, ALIGN=1

                  CAN_GetITState PROC
;;;638      */
;;;639    ITStatus CAN_GetITState(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT)
000000  4602              MOV      r2,r0
;;;640    {
;;;641      ITStatus bitstatus;
;;;642    
;;;643      /* Check the parameters */
;;;644      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;645      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;646    
;;;647      if ((CANx->INT_EN & CAN_IT) == 0)
000002  6913              LDR      r3,[r2,#0x10]
000004  400b              ANDS     r3,r3,r1
000006  b90b              CBNZ     r3,|L9.12|
;;;648      {
;;;649        bitstatus = RESET;
000008  2000              MOVS     r0,#0
00000a  e000              B        |L9.14|
                  |L9.12|
;;;650      }
;;;651      else
;;;652      {
;;;653        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L9.14|
;;;654      }
;;;655    
;;;656      return bitstatus;
;;;657    }
00000e  4770              BX       lr
;;;658    
                          ENDP


                          AREA ||i.CAN_GetRawReceivedData||, CODE, READONLY, ALIGN=1

                  CAN_GetRawReceivedData PROC
;;;507      */
;;;508    void CAN_GetRawReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RxMsgTypeDef* RxMessage)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;509    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;510      uint32_t tmpreg;
;;;511    
;;;512      /* Check the parameters */
;;;513      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;514      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;515    
;;;516      /* Get the DLC */
;;;517      tmpreg = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DLC));
00000a  f5057100          ADD      r1,r5,#0x200
00000e  eb011106          ADD      r1,r1,r6,LSL #4
000012  1d08              ADDS     r0,r1,#4
000014  f7fffffe          BL       CAN_ReadBufferSFR
000018  4607              MOV      r7,r0
;;;518    
;;;519      RxMessage->Rx_Header.DLC = (uint8_t)(tmpreg & CAN_DLC_DATA_LENGTH);
00001a  f007000f          AND      r0,r7,#0xf
00001e  71a0              STRB     r0,[r4,#6]
;;;520      /* Get the IDE */
;;;521      RxMessage->Rx_Header.IDE = CAN_ID_STD;
000020  2000              MOVS     r0,#0
000022  7160              STRB     r0,[r4,#5]
;;;522      if ((tmpreg & CAN_DLC_IDE) != 0)
000024  f4075080          AND      r0,r7,#0x1000
000028  b108              CBZ      r0,|L10.46|
;;;523      {
;;;524        RxMessage->Rx_Header.IDE = CAN_ID_EXT;
00002a  2001              MOVS     r0,#1
00002c  7160              STRB     r0,[r4,#5]
                  |L10.46|
;;;525      }
;;;526      /* Get the OVER_EN */
;;;527      RxMessage->Rx_Header.OVER_EN = DISABLE;
00002e  2000              MOVS     r0,#0
000030  7120              STRB     r0,[r4,#4]
;;;528      tmpreg = CAN_ReadBufferSFR(&(CANx->BUF_CON[BufferNumber]));
000032  f1050140          ADD      r1,r5,#0x40
000036  eb010086          ADD      r0,r1,r6,LSL #2
00003a  f7fffffe          BL       CAN_ReadBufferSFR
00003e  4607              MOV      r7,r0
;;;529      if ((tmpreg & CAN_BUF_CON_OVER_EN) != 0)
000040  f0070004          AND      r0,r7,#4
000044  b108              CBZ      r0,|L10.74|
;;;530      {
;;;531        RxMessage->Rx_Header.OVER_EN = ENABLE;
000046  2001              MOVS     r0,#1
000048  7120              STRB     r0,[r4,#4]
                  |L10.74|
;;;532      }
;;;533      /* Get the Id */
;;;534      RxMessage->Rx_Header.ID = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].ID));
00004a  f5057100          ADD      r1,r5,#0x200
00004e  eb011006          ADD      r0,r1,r6,LSL #4
000052  f7fffffe          BL       CAN_ReadBufferSFR
000056  6020              STR      r0,[r4,#0]
;;;535    
;;;536      /* Get the data field */
;;;537      RxMessage->Data[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
000058  f5057100          ADD      r1,r5,#0x200
00005c  eb011106          ADD      r1,r1,r6,LSL #4
000060  f1010008          ADD      r0,r1,#8
000064  f7fffffe          BL       CAN_ReadBufferSFR
000068  60a0              STR      r0,[r4,#8]
;;;538      RxMessage->Data[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
00006a  f5057100          ADD      r1,r5,#0x200
00006e  eb011106          ADD      r1,r1,r6,LSL #4
000072  f101000c          ADD      r0,r1,#0xc
000076  f7fffffe          BL       CAN_ReadBufferSFR
00007a  60e0              STR      r0,[r4,#0xc]
;;;539    }
00007c  e8bd81f0          POP      {r4-r8,pc}
;;;540    
                          ENDP


                          AREA ||i.CAN_GetReceivedData||, CODE, READONLY, ALIGN=1

                  CAN_GetReceivedData PROC
;;;488      */
;;;489    void CAN_GetReceivedData(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_DataTypeDef RxBuffer)
000000  b570              PUSH     {r4-r6,lr}
;;;490    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;491      /* Check the parameters */
;;;492      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;493      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;494    
;;;495      RxBuffer[0] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAL));
000008  f5047100          ADD      r1,r4,#0x200
00000c  eb011105          ADD      r1,r1,r5,LSL #4
000010  f1010008          ADD      r0,r1,#8
000014  f7fffffe          BL       CAN_ReadBufferSFR
000018  6030              STR      r0,[r6,#0]
;;;496      RxBuffer[1] = CAN_ReadBufferSFR(&(CANx->CAN_BUF[BufferNumber].DATAH));
00001a  f5047100          ADD      r1,r4,#0x200
00001e  eb011105          ADD      r1,r1,r5,LSL #4
000022  f101000c          ADD      r0,r1,#0xc
000026  f7fffffe          BL       CAN_ReadBufferSFR
00002a  6070              STR      r0,[r6,#4]
;;;497    }
00002c  bd70              POP      {r4-r6,pc}
;;;498    
                          ENDP


                          AREA ||i.CAN_GetRx||, CODE, READONLY, ALIGN=1

                  CAN_GetRx PROC
;;;751      */
;;;752    uint32_t CAN_GetRx(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;753    {
;;;754      /* Check the parameters */
;;;755      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;756    
;;;757      return CANx->RX;
000002  f8d100c4          LDR      r0,[r1,#0xc4]
;;;758    }
000006  4770              BX       lr
;;;759    
                          ENDP


                          AREA ||i.CAN_GetRxITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetRxITStatus PROC
;;;724      */
;;;725    ITStatus CAN_GetRxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  b510              PUSH     {r4,lr}
;;;726    {
000002  4602              MOV      r2,r0
;;;727      FlagStatus bitstatus;
;;;728    
;;;729      /* Check the parameters */
;;;730      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;731      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;732    
;;;733      if ((CANx->RX & CANx->INT_RX & (((uint32_t)0x1) << BufferNumber)) == 0)
000004  f8d230c4          LDR      r3,[r2,#0xc4]
000008  f8d240c0          LDR      r4,[r2,#0xc0]
00000c  4023              ANDS     r3,r3,r4
00000e  2401              MOVS     r4,#1
000010  408c              LSLS     r4,r4,r1
000012  4023              ANDS     r3,r3,r4
000014  b90b              CBNZ     r3,|L13.26|
;;;734      {
;;;735        bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e000              B        |L13.28|
                  |L13.26|
;;;736      }
;;;737      else
;;;738      {
;;;739        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L13.28|
;;;740      }
;;;741    
;;;742      return bitstatus;
;;;743    }
00001c  bd10              POP      {r4,pc}
;;;744    
                          ENDP


                          AREA ||i.CAN_GetStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetStatus PROC
;;;603      */
;;;604    uint32_t CAN_GetStatus(MDR_CAN_TypeDef* CANx)
000000  4601              MOV      r1,r0
;;;605    {
;;;606      /* Check the parameters */
;;;607      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;608    
;;;609      return CANx->STATUS;
000002  6848              LDR      r0,[r1,#4]
;;;610    }
000004  4770              BX       lr
;;;611    
                          ENDP


                          AREA ||i.CAN_GetTxITStatus||, CODE, READONLY, ALIGN=1

                  CAN_GetTxITStatus PROC
;;;801      */
;;;802    ITStatus CAN_GetTxITStatus(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber)
000000  b510              PUSH     {r4,lr}
;;;803    {
000002  4602              MOV      r2,r0
;;;804      FlagStatus bitstatus;
;;;805    
;;;806      /* Check the parameters */
;;;807      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;808      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;809    
;;;810      if ((CANx->TX & CANx->INT_TX & (((uint32_t)0x1) << BufferNumber)) == 0)
000004  f8d230cc          LDR      r3,[r2,#0xcc]
000008  f8d240c8          LDR      r4,[r2,#0xc8]
00000c  4023              ANDS     r3,r3,r4
00000e  2401              MOVS     r4,#1
000010  408c              LSLS     r4,r4,r1
000012  4023              ANDS     r3,r3,r4
000014  b90b              CBNZ     r3,|L15.26|
;;;811      {
;;;812        bitstatus = RESET;
000016  2000              MOVS     r0,#0
000018  e000              B        |L15.28|
                  |L15.26|
;;;813      }
;;;814      else
;;;815      {
;;;816        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L15.28|
;;;817      }
;;;818    
;;;819      return bitstatus;
;;;820    }
00001c  bd10              POP      {r4,pc}
;;;821    
                          ENDP


                          AREA ||i.CAN_ITClearErrorPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ITClearErrorPendingBit PROC
;;;673      */
;;;674    void CAN_ITClearErrorPendingBit(MDR_CAN_TypeDef* CANx, uint32_t Status_Flag)
000000  6842              LDR      r2,[r0,#4]
;;;675    {
;;;676      /* Check the parameters */
;;;677      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;678      assert_param(IS_CAN_IT_ERROR_FLAG(Status_Flag));
;;;679    
;;;680      CANx->STATUS &= ~Status_Flag;
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;681    }
000006  4770              BX       lr
;;;682    
                          ENDP


                          AREA ||i.CAN_ITClearRxTxPendingBit||, CODE, READONLY, ALIGN=1

                  CAN_ITClearRxTxPendingBit PROC
;;;834      */
;;;835    void CAN_ITClearRxTxPendingBit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, uint32_t Status_Flag)
000000  b510              PUSH     {r4,lr}
;;;836    {
;;;837      uint32_t tmpreg;
;;;838    
;;;839      /* Check the parameters */
;;;840      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;841      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;842      assert_param(IS_CAN_IT_RXTX_FLAG(Status_Flag));
;;;843    
;;;844      tmpreg = CANx->BUF_CON[BufferNumber];
000002  f1000440          ADD      r4,r0,#0x40
000006  f8543021          LDR      r3,[r4,r1,LSL #2]
;;;845    
;;;846      if (Status_Flag == CAN_STATUS_RX_READY)
00000a  2a01              CMP      r2,#1
00000c  d102              BNE      |L17.20|
;;;847      {
;;;848        tmpreg &= ~CAN_STATUS_RX_FULL;
00000e  f0230340          BIC      r3,r3,#0x40
000012  e003              B        |L17.28|
                  |L17.20|
;;;849      }
;;;850      else if (Status_Flag == CAN_STATUS_TX_READY)
000014  2a02              CMP      r2,#2
000016  d101              BNE      |L17.28|
;;;851      {
;;;852        tmpreg |= CAN_STATUS_TX_REQ;
000018  f0430320          ORR      r3,r3,#0x20
                  |L17.28|
;;;853      }
;;;854    
;;;855      CANx->BUF_CON[BufferNumber] = tmpreg;
00001c  f1000440          ADD      r4,r0,#0x40
000020  f8443021          STR      r3,[r4,r1,LSL #2]
;;;856    }
000024  bd10              POP      {r4,pc}
;;;857    
                          ENDP


                          AREA ||i.CAN_ITConfig||, CODE, READONLY, ALIGN=1

                  CAN_ITConfig PROC
;;;227      */
;;;228    void CAN_ITConfig(MDR_CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L18.10|
;;;229    {
;;;230      /* Check the parameters */
;;;231      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;232      assert_param(IS_CAN_ITConfig(CAN_IT));
;;;233      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;234    
;;;235      if (NewState != DISABLE)
;;;236      {
;;;237        CANx->INT_EN |= CAN_IT;
000002  6903              LDR      r3,[r0,#0x10]
000004  430b              ORRS     r3,r3,r1
000006  6103              STR      r3,[r0,#0x10]
000008  e002              B        |L18.16|
                  |L18.10|
;;;238      }
;;;239      else
;;;240      {
;;;241        CANx->INT_EN &= ~CAN_IT;
00000a  6903              LDR      r3,[r0,#0x10]
00000c  438b              BICS     r3,r3,r1
00000e  6103              STR      r3,[r0,#0x10]
                  |L18.16|
;;;242      }
;;;243    }
000010  4770              BX       lr
;;;244    
                          ENDP


                          AREA ||i.CAN_Init||, CODE, READONLY, ALIGN=1

                  CAN_Init PROC
;;;105      */
;;;106    void CAN_Init(MDR_CAN_TypeDef* CANx, const CAN_InitTypeDef* CAN_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;107    {
;;;108      uint32_t tmpreg_CONTROL = 0;
000002  2200              MOVS     r2,#0
;;;109      uint32_t tmpreg_BITTMNG;
;;;110      uint32_t i;
;;;111    
;;;112      /* Check the parameters */
;;;113      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;114      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROP));
;;;115      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_SAP));
;;;116      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_STM));
;;;117      assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ROM));
;;;118      assert_param(IS_CAN_PSEG_VALUE(CAN_InitStruct->CAN_PSEG));
;;;119      assert_param(IS_CAN_SEG1_VALUE(CAN_InitStruct->CAN_SEG1));
;;;120      assert_param(IS_CAN_SEG2_VALUE(CAN_InitStruct->CAN_SEG2));
;;;121      assert_param(IS_CAN_SJW_VALUE(CAN_InitStruct->CAN_SJW));
;;;122      assert_param(IS_CAN_SAMPLING_MODE(CAN_InitStruct->CAN_SB));
;;;123    
;;;124      /* Configure CONTROL register*/
;;;125      if (CAN_InitStruct->CAN_ROP != DISABLE)
000004  780d              LDRB     r5,[r1,#0]
000006  b10d              CBZ      r5,|L19.12|
;;;126      {
;;;127        tmpreg_CONTROL |= CAN_CONTROL_ROP;
000008  f0420210          ORR      r2,r2,#0x10
                  |L19.12|
;;;128      }
;;;129      if (CAN_InitStruct->CAN_SAP != DISABLE)
00000c  784d              LDRB     r5,[r1,#1]
00000e  b10d              CBZ      r5,|L19.20|
;;;130      {
;;;131        tmpreg_CONTROL |= CAN_CONTROL_SAP;
000010  f0420208          ORR      r2,r2,#8
                  |L19.20|
;;;132      }
;;;133      if (CAN_InitStruct->CAN_STM != DISABLE)
000014  788d              LDRB     r5,[r1,#2]
000016  b10d              CBZ      r5,|L19.28|
;;;134      {
;;;135        tmpreg_CONTROL |= CAN_CONTROL_STM;
000018  f0420204          ORR      r2,r2,#4
                  |L19.28|
;;;136      }
;;;137      if (CAN_InitStruct->CAN_ROM != DISABLE)
00001c  78cd              LDRB     r5,[r1,#3]
00001e  b10d              CBZ      r5,|L19.36|
;;;138      {
;;;139        tmpreg_CONTROL |= CAN_CONTROL_ROM;
000020  f0420202          ORR      r2,r2,#2
                  |L19.36|
;;;140      }
;;;141      CANx->CONTROL = tmpreg_CONTROL;
000024  6002              STR      r2,[r0,#0]
;;;142    
;;;143      /* Configure BITTMNG register*/
;;;144      tmpreg_BITTMNG = CAN_InitStruct->CAN_PSEG + CAN_InitStruct->CAN_SEG1 +
000026  e9d15601          LDRD     r5,r6,[r1,#4]
00002a  4435              ADD      r5,r5,r6
00002c  68ce              LDR      r6,[r1,#0xc]
00002e  4435              ADD      r5,r5,r6
000030  690e              LDR      r6,[r1,#0x10]
000032  4435              ADD      r5,r5,r6
000034  8b0e              LDRH     r6,[r1,#0x18]
000036  19ac              ADDS     r4,r5,r6
;;;145                       CAN_InitStruct->CAN_SEG2 + CAN_InitStruct->CAN_SJW +
;;;146                       (uint32_t)(CAN_InitStruct->CAN_BRP);
;;;147      tmpreg_BITTMNG |= CAN_InitStruct->CAN_SB;
000038  694d              LDR      r5,[r1,#0x14]
00003a  432c              ORRS     r4,r4,r5
;;;148      CANx->BITTMNG = tmpreg_BITTMNG;
00003c  6084              STR      r4,[r0,#8]
;;;149    
;;;150      /* Initialize Filters */
;;;151      for (i = 0; i < 32; i++)
00003e  2300              MOVS     r3,#0
000040  e00a              B        |L19.88|
                  |L19.66|
;;;152      {
;;;153        CANx->CAN_BUF_FILTER[i].FILTER = 0;
000042  2600              MOVS     r6,#0
000044  f50065a0          ADD      r5,r0,#0x500
000048  eb0505c3          ADD      r5,r5,r3,LSL #3
00004c  606e              STR      r6,[r5,#4]
;;;154        CANx->CAN_BUF_FILTER[i].MASK = 0;
00004e  f50065a0          ADD      r5,r0,#0x500
000052  f8456033          STR      r6,[r5,r3,LSL #3]
000056  1c5b              ADDS     r3,r3,#1              ;151
                  |L19.88|
000058  2b20              CMP      r3,#0x20              ;151
00005a  d3f2              BCC      |L19.66|
;;;155      }
;;;156    
;;;157      /* Configure OVER register*/
;;;158      CANx->OVER = (uint32_t)(CAN_InitStruct->CAN_OVER_ERROR_MAX);
00005c  7e8d              LDRB     r5,[r1,#0x1a]
00005e  61c5              STR      r5,[r0,#0x1c]
;;;159    }
000060  bd70              POP      {r4-r6,pc}
;;;160    
                          ENDP


                          AREA ||i.CAN_RTRReply||, CODE, READONLY, ALIGN=1

                  CAN_RTRReply PROC
;;;407    
;;;408    void CAN_RTRReply(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRReplyTypeDef* RTRReplyMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;409    {
;;;410      uint32_t tmpreg;
;;;411    
;;;412      /* Check the parameters */
;;;413      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;414      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;415      assert_param(IS_CAN_IDTYPE(RTRReplyMessage->IDE));
;;;416      assert_param(IS_CAN_ID(RTRReplyMessage->ID));
;;;417      assert_param(IS_CAN_DLC(RTRReplyMessage->DLC));
;;;418    
;;;419      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;420      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;421      /* Packet format */
;;;422      if (RTRReplyMessage->IDE == CAN_ID_STD)
000002  7914              LDRB     r4,[r2,#4]
000004  b91c              CBNZ     r4,|L20.14|
;;;423      {
;;;424        /* Standard */
;;;425        tmpreg = CAN_BUF_DLC_STD + RTRReplyMessage->DLC;
000006  7954              LDRB     r4,[r2,#5]
000008  f5046320          ADD      r3,r4,#0xa00
00000c  e002              B        |L20.20|
                  |L20.14|
;;;426      }
;;;427      else
;;;428      {
;;;429        /* Extended */
;;;430        tmpreg = CAN_BUF_DLC_EXT + RTRReplyMessage->DLC;
00000e  7954              LDRB     r4,[r2,#5]
000010  f50453d0          ADD      r3,r4,#0x1a00
                  |L20.20|
;;;431      }
;;;432      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
000014  f5007400          ADD      r4,r0,#0x200
000018  eb041401          ADD      r4,r4,r1,LSL #4
00001c  6063              STR      r3,[r4,#4]
;;;433      CANx->CAN_BUF[BufferNumber].ID  = RTRReplyMessage->ID;
00001e  f5007400          ADD      r4,r0,#0x200
000022  eb041401          ADD      r4,r4,r1,LSL #4
000026  6815              LDR      r5,[r2,#0]
000028  6025              STR      r5,[r4,#0]
;;;434    
;;;435      /* Buffer data unit */
;;;436      CANx->CAN_BUF[BufferNumber].DATAL = RTRReplyMessage->Data[0];
00002a  f5007400          ADD      r4,r0,#0x200
00002e  eb041401          ADD      r4,r4,r1,LSL #4
000032  6895              LDR      r5,[r2,#8]
000034  60a5              STR      r5,[r4,#8]
;;;437      CANx->CAN_BUF[BufferNumber].DATAH = RTRReplyMessage->Data[1];
000036  f5007400          ADD      r4,r0,#0x200
00003a  eb041401          ADD      r4,r4,r1,LSL #4
00003e  68d5              LDR      r5,[r2,#0xc]
000040  60e5              STR      r5,[r4,#0xc]
;;;438    
;;;439      /* Configure CAN_BUF_CON register */
;;;440      /* Set RTR_EN bit */
;;;441      tmpreg = CAN_STATUS_RTR_EN;
000042  2308              MOVS     r3,#8
;;;442      /* Enable buffer */
;;;443      tmpreg |= CAN_BUF_CON_EN;
000044  f0430301          ORR      r3,r3,#1
;;;444    
;;;445      CANx->BUF_CON[BufferNumber] = tmpreg;
000048  f1000440          ADD      r4,r0,#0x40
00004c  f8443021          STR      r3,[r4,r1,LSL #2]
;;;446    }
000050  bd30              POP      {r4,r5,pc}
;;;447    
                          ENDP


                          AREA ||i.CAN_ReadBufferSFR||, CODE, READONLY, ALIGN=1

                  CAN_ReadBufferSFR PROC
;;;912      */
;;;913    static __INLINE uint32_t CAN_ReadBufferSFR(__IO uint32_t* SFR)
000000  4601              MOV      r1,r0
;;;914    {
;;;915    #ifdef WORKAROUND_MDR32F9QX_ERROR_0002
;;;916      /*
;;;917       * MDR32F9Qx Series Errata Notice, Error 0002:
;;;918       * The registers CAN_BUFxx_ID, CAN_BUFxx_DLC, CAN_BUFxx_DATAL,
;;;919       * CAN_BUFxx_DATAH, CAN_BUFxx_MASK or CAN_BUFxx_FILTER value
;;;920       * may be incorrectly read as 0 if CAN controller accessed any
;;;921       * of that registers at the moment of reading.
;;;922       * In such case, another read should be performed in a time less
;;;923       * than minimum CAN package.
;;;924       */
;;;925      uint32_t tmpreg;
;;;926    
;;;927      __disable_irq();
000002  b672              CPSID    i
;;;928      tmpreg = *SFR;
000004  6808              LDR      r0,[r1,#0]
;;;929      if (tmpreg == 0)
000006  b900              CBNZ     r0,|L21.10|
;;;930      {
;;;931        tmpreg = *SFR;
000008  6808              LDR      r0,[r1,#0]
                  |L21.10|
;;;932      }
;;;933      __enable_irq();
00000a  b662              CPSIE    i
;;;934      return tmpreg;
;;;935    #else
;;;936      return *SFR;
;;;937    #endif  /* WORKAROUND_MDR32F9QX_ERROR_0002 */
;;;938    }
00000c  4770              BX       lr
;;;939    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;458      */
;;;459    void CAN_Receive(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, FunctionalState OverWrite)
000000  b510              PUSH     {r4,lr}
;;;460    {
;;;461      uint32_t tmpreg = 0;
000002  2300              MOVS     r3,#0
;;;462    
;;;463      /* Check the parameters */
;;;464      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;465      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;466      assert_param(IS_FUNCTIONAL_STATE(OverWrite));
;;;467    
;;;468      /* Configure CAN_BUF_CON register */
;;;469      /* Overwrite mode */
;;;470      if (OverWrite != DISABLE)
000004  b102              CBZ      r2,|L22.8|
;;;471      {
;;;472        tmpreg = CAN_BUF_CON_OVER_EN;
000006  2304              MOVS     r3,#4
                  |L22.8|
;;;473      }
;;;474      /* Configure buffer for receiving and enable it */
;;;475      tmpreg |= CAN_BUF_CON_RX_TXN | CAN_BUF_CON_EN;
000008  f0430303          ORR      r3,r3,#3
;;;476    
;;;477      CANx->BUF_CON[BufferNumber] = tmpreg;
00000c  f1000440          ADD      r4,r0,#0x40
000010  f8443021          STR      r3,[r4,r1,LSL #2]
;;;478    }
000014  bd10              POP      {r4,pc}
;;;479    
                          ENDP


                          AREA ||i.CAN_RxITConfig||, CODE, READONLY, ALIGN=1

                  CAN_RxITConfig PROC
;;;694      */
;;;695    void CAN_RxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;696    {
000002  4613              MOV      r3,r2
;;;697      uint32_t tmpreg;
;;;698    
;;;699      /* Check the parameters */
;;;700      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;701      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;702    
;;;703      tmpreg = CANx->INT_RX;
000004  f8d020c0          LDR      r2,[r0,#0xc0]
;;;704    
;;;705      if (NewState != DISABLE)
000008  b10b              CBZ      r3,|L23.14|
;;;706      {
;;;707        tmpreg |= Buffer_IT;
00000a  430a              ORRS     r2,r2,r1
00000c  e000              B        |L23.16|
                  |L23.14|
;;;708      }
;;;709      else
;;;710      {
;;;711        tmpreg &= ~Buffer_IT;
00000e  438a              BICS     r2,r2,r1
                  |L23.16|
;;;712      }
;;;713    
;;;714      CANx->INT_RX = tmpreg;
000010  f8c020c0          STR      r2,[r0,#0xc0]
;;;715    }
000014  bd10              POP      {r4,pc}
;;;716    
                          ENDP


                          AREA ||i.CAN_SendRTR||, CODE, READONLY, ALIGN=1

                  CAN_SendRTR PROC
;;;356      */
;;;357    void CAN_SendRTR(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_RTRMessageTypeDef* RTRMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;358    {
000002  4603              MOV      r3,r0
;;;359      uint32_t tmpreg;
;;;360    
;;;361      /* Check the parameters */
;;;362      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;363      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;364      assert_param(IS_CAN_IDTYPE(RTRMessage->IDE));
;;;365      assert_param(IS_FUNCTIONAL_STATE(RTRMessage->PRIOR_0));
;;;366      assert_param(IS_CAN_ID(RTRMessage->ID));
;;;367    
;;;368      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;369      /* Packet format */
;;;370      if (RTRMessage->IDE == CAN_ID_STD)
000004  7954              LDRB     r4,[r2,#5]
000006  b914              CBNZ     r4,|L24.14|
;;;371      {
;;;372        /* Standard */
;;;373        tmpreg = CAN_BUF_DLC_STD;
000008  f44f6020          MOV      r0,#0xa00
00000c  e001              B        |L24.18|
                  |L24.14|
;;;374      }
;;;375      else
;;;376      {
;;;377        /* Extended */
;;;378        tmpreg = CAN_BUF_DLC_EXT;
00000e  f44f50d0          MOV      r0,#0x1a00
                  |L24.18|
;;;379      }
;;;380      CANx->CAN_BUF[BufferNumber].DLC = tmpreg + CAN_RTR_REMOTE;
000012  f5007480          ADD      r4,r0,#0x100
000016  f5037500          ADD      r5,r3,#0x200
00001a  eb051501          ADD      r5,r5,r1,LSL #4
00001e  606c              STR      r4,[r5,#4]
;;;381      CANx->CAN_BUF[BufferNumber].ID  = RTRMessage->ID;
000020  f5037400          ADD      r4,r3,#0x200
000024  eb041401          ADD      r4,r4,r1,LSL #4
000028  6815              LDR      r5,[r2,#0]
00002a  6025              STR      r5,[r4,#0]
;;;382    
;;;383      /* Configure CAN_BUF_CON register */
;;;384      tmpreg = 0;
00002c  2000              MOVS     r0,#0
;;;385      /* Transmission priority */
;;;386      if (RTRMessage->PRIOR_0 != DISABLE)
00002e  7914              LDRB     r4,[r2,#4]
000030  b10c              CBZ      r4,|L24.54|
;;;387      {
;;;388        tmpreg |= CAN_BUF_CON_PRIOR_0;
000032  f0400010          ORR      r0,r0,#0x10
                  |L24.54|
;;;389      }
;;;390      /* Set transmission request bit */
;;;391      tmpreg |= CAN_BUF_CON_TX_REQ;
000036  f0400020          ORR      r0,r0,#0x20
;;;392      /* Enable buffer */
;;;393      tmpreg |= CAN_BUF_CON_EN;
00003a  f0400001          ORR      r0,r0,#1
;;;394    
;;;395      CANx->BUF_CON[BufferNumber] = tmpreg;
00003e  f1030440          ADD      r4,r3,#0x40
000042  f8440021          STR      r0,[r4,r1,LSL #2]
;;;396    }
000046  bd30              POP      {r4,r5,pc}
;;;397    
                          ENDP


                          AREA ||i.CAN_StructInit||, CODE, READONLY, ALIGN=1

                  CAN_StructInit PROC
;;;166      */
;;;167    void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
000000  2100              MOVS     r1,#0
;;;168    {
;;;169      /* Reset CAN init structure parameters values */
;;;170      /* Own packet reception: disabled */
;;;171      CAN_InitStruct->CAN_ROP = DISABLE;
000002  7001              STRB     r1,[r0,#0]
;;;172      /* Sending ACK on own packets: disabled */
;;;173      CAN_InitStruct->CAN_SAP = DISABLE;
000004  7041              STRB     r1,[r0,#1]
;;;174      /* Self Test mode: disabled */
;;;175      CAN_InitStruct->CAN_STM = DISABLE;
000006  7081              STRB     r1,[r0,#2]
;;;176      /* Read Only mode: disabled */
;;;177      CAN_InitStruct->CAN_ROM = DISABLE;
000008  70c1              STRB     r1,[r0,#3]
;;;178      /* CAN_PSEG member */
;;;179      CAN_InitStruct->CAN_PSEG = CAN_PSEG_Mul_1TQ;
00000a  6041              STR      r1,[r0,#4]
;;;180      /* CAN_SEG1 member */
;;;181      CAN_InitStruct->CAN_SEG1 = CAN_SEG1_Mul_2TQ;
00000c  f44f2100          MOV      r1,#0x80000
000010  6081              STR      r1,[r0,#8]
;;;182      /* CAN_SEG2 member */
;;;183      CAN_InitStruct->CAN_SEG2 = CAN_SEG2_Mul_6TQ;
000012  f04f71a0          MOV      r1,#0x1400000
000016  60c1              STR      r1,[r0,#0xc]
;;;184      /* CAN_SEG2 member */
;;;185      CAN_InitStruct->CAN_SJW = CAN_SJW_Mul_1TQ;
000018  2100              MOVS     r1,#0
00001a  6101              STR      r1,[r0,#0x10]
;;;186      /* Sampling mode member */
;;;187      CAN_InitStruct->CAN_SB = CAN_SB_1_SAMPLE;
00001c  6141              STR      r1,[r0,#0x14]
;;;188      /* CAN_BRP member */
;;;189      CAN_InitStruct->CAN_BRP = 0;
00001e  8301              STRH     r1,[r0,#0x18]
;;;190      /* CAN_OVER_ERROR_MAX member */
;;;191      CAN_InitStruct->CAN_OVER_ERROR_MAX = 255;
000020  21ff              MOVS     r1,#0xff
000022  7681              STRB     r1,[r0,#0x1a]
;;;192    }
000024  4770              BX       lr
;;;193    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;301      */
;;;302    void CAN_Transmit(MDR_CAN_TypeDef* CANx, uint32_t BufferNumber, CAN_TxMsgTypeDef* TxMessage)
000000  b530              PUSH     {r4,r5,lr}
;;;303    {
000002  4603              MOV      r3,r0
;;;304      uint32_t tmpreg;
;;;305    
;;;306      /* Check the parameters */
;;;307      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;308      assert_param(IS_CAN_BUFFER(BufferNumber));
;;;309      assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
;;;310      assert_param(IS_CAN_DLC(TxMessage->DLC));
;;;311      assert_param(IS_FUNCTIONAL_STATE(TxMessage->PRIOR_0));
;;;312      assert_param(IS_CAN_ID(TxMessage->ID));
;;;313    
;;;314      /* Configure CAN_BUF_ID and CAN_BUF_DLC registers */
;;;315      /* Packet format */
;;;316      if (TxMessage->IDE == CAN_ID_STD)
000004  7954              LDRB     r4,[r2,#5]
000006  b91c              CBNZ     r4,|L26.16|
;;;317      {
;;;318        /* Standard */
;;;319        tmpreg = CAN_BUF_DLC_STD + TxMessage->DLC;
000008  7994              LDRB     r4,[r2,#6]
00000a  f5046020          ADD      r0,r4,#0xa00
00000e  e002              B        |L26.22|
                  |L26.16|
;;;320      }
;;;321      else
;;;322      {
;;;323        /* Extended */
;;;324        tmpreg = CAN_BUF_DLC_EXT + TxMessage->DLC;
000010  7994              LDRB     r4,[r2,#6]
000012  f50450d0          ADD      r0,r4,#0x1a00
                  |L26.22|
;;;325      }
;;;326      CANx->CAN_BUF[BufferNumber].DLC = tmpreg;
000016  f5037400          ADD      r4,r3,#0x200
00001a  eb041401          ADD      r4,r4,r1,LSL #4
00001e  6060              STR      r0,[r4,#4]
;;;327      CANx->CAN_BUF[BufferNumber].ID  = TxMessage->ID;
000020  f5037400          ADD      r4,r3,#0x200
000024  eb041401          ADD      r4,r4,r1,LSL #4
000028  6815              LDR      r5,[r2,#0]
00002a  6025              STR      r5,[r4,#0]
;;;328    
;;;329      /* Buffer data unit */
;;;330      CANx->CAN_BUF[BufferNumber].DATAL = TxMessage->Data[0];
00002c  f5037400          ADD      r4,r3,#0x200
000030  eb041401          ADD      r4,r4,r1,LSL #4
000034  6895              LDR      r5,[r2,#8]
000036  60a5              STR      r5,[r4,#8]
;;;331      CANx->CAN_BUF[BufferNumber].DATAH = TxMessage->Data[1];
000038  f5037400          ADD      r4,r3,#0x200
00003c  eb041401          ADD      r4,r4,r1,LSL #4
000040  68d5              LDR      r5,[r2,#0xc]
000042  60e5              STR      r5,[r4,#0xc]
;;;332    
;;;333      /* Configure CAN_BUF_CON register */
;;;334      tmpreg = 0;
000044  2000              MOVS     r0,#0
;;;335      /* Transmission priority */
;;;336      if (TxMessage->PRIOR_0 != DISABLE)
000046  7914              LDRB     r4,[r2,#4]
000048  b10c              CBZ      r4,|L26.78|
;;;337      {
;;;338        tmpreg |= CAN_BUF_CON_PRIOR_0;
00004a  f0400010          ORR      r0,r0,#0x10
                  |L26.78|
;;;339      }
;;;340      /* Set transmission request bit */
;;;341      tmpreg |= CAN_BUF_CON_TX_REQ;
00004e  f0400020          ORR      r0,r0,#0x20
;;;342      /* Enable buffer */
;;;343      tmpreg |= CAN_BUF_CON_EN;
000052  f0400001          ORR      r0,r0,#1
;;;344    
;;;345      CANx->BUF_CON[BufferNumber] = tmpreg;
000056  f1030440          ADD      r4,r3,#0x40
00005a  f8440021          STR      r0,[r4,r1,LSL #2]
;;;346    }
00005e  bd30              POP      {r4,r5,pc}
;;;347    
                          ENDP


                          AREA ||i.CAN_TxITConfig||, CODE, READONLY, ALIGN=1

                  CAN_TxITConfig PROC
;;;771      */
;;;772    void CAN_TxITConfig(MDR_CAN_TypeDef* CANx, uint32_t Buffer_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;773    {
000002  4613              MOV      r3,r2
;;;774      uint32_t tmpreg;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_CAN_ALL_PERIPH(CANx));
;;;778      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;779    
;;;780      tmpreg = CANx->INT_TX;
000004  f8d020c8          LDR      r2,[r0,#0xc8]
;;;781    
;;;782      if (NewState != DISABLE)
000008  b10b              CBZ      r3,|L27.14|
;;;783      {
;;;784        tmpreg |= Buffer_IT;
00000a  430a              ORRS     r2,r2,r1
00000c  e000              B        |L27.16|
                  |L27.14|
;;;785      }
;;;786      else
;;;787      {
;;;788        tmpreg &= ~Buffer_IT;
00000e  438a              BICS     r2,r2,r1
                  |L27.16|
;;;789      }
;;;790    
;;;791      CANx->INT_TX = tmpreg;
000010  f8c020c8          STR      r2,[r0,#0xc8]
;;;792    }
000014  bd10              POP      {r4,pc}
;;;793    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_can_c_347dae01____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____REVSH|
#line 462
|__asm___15_MDR32F9Qx_can_c_347dae01____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_can_c_347dae01____RRX|
#line 649
|__asm___15_MDR32F9Qx_can_c_347dae01____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
