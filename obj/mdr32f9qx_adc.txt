; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_adc.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_adc.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||i.ADC1_ChannelSwithingConfig||, CODE, READONLY, ALIGN=2

                  ADC1_ChannelSwithingConfig PROC
;;;521      */
;;;522    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
000000  4601              MOV      r1,r0
;;;523    {
;;;524      uint32_t tmpreg_CFG;
;;;525    
;;;526      /* Check the parameters */
;;;527      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;528    
;;;529      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a03              LDR      r2,|L1.16|
000004  6810              LDR      r0,[r2,#0]
;;;530      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
000006  f4207000          BIC      r0,r0,#0x200
;;;531      tmpreg_CFG += SwitchingMode;
00000a  4408              ADD      r0,r0,r1
;;;532      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000c  6010              STR      r0,[r2,#0]
;;;533    }
00000e  4770              BX       lr
;;;534    
                          ENDP

                  |L1.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_ClearOutOfRangeFlag||, CODE, READONLY, ALIGN=2

                  ADC1_ClearOutOfRangeFlag PROC
;;;874      */
;;;875    void ADC1_ClearOutOfRangeFlag(void)
000000  4803              LDR      r0,|L2.16|
;;;876    {
;;;877      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L2.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;878    }
00000c  4770              BX       lr
;;;879    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_ClearOverwriteFlag||, CODE, READONLY, ALIGN=2

                  ADC1_ClearOverwriteFlag PROC
;;;850      */
;;;851    void ADC1_ClearOverwriteFlag(void)
000000  4803              LDR      r0,|L3.16|
;;;852    {
;;;853      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L3.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;854    }
00000c  4770              BX       lr
;;;855    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_Cmd||, CODE, READONLY, ALIGN=2

                  ADC1_Cmd PROC
;;;304      */
;;;305    void ADC1_Cmd(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;306    {
;;;307      uint32_t tmpreg_CFG;
;;;308    
;;;309      /* Check the parameters */
;;;310      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;311    
;;;312      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a05              LDR      r2,|L4.24|
000004  6810              LDR      r0,[r2,#0]
;;;313    
;;;314      /* Form new value */
;;;315      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L4.14|
;;;316      {
;;;317        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;318        tmpreg_CFG |= ADC1_CFG_REG_ADON;
000008  f0400001          ORR      r0,r0,#1
00000c  e001              B        |L4.18|
                  |L4.14|
;;;319      }
;;;320      else
;;;321      {
;;;322        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;323        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
00000e  f0200001          BIC      r0,r0,#1
                  |L4.18|
;;;324      }
;;;325    
;;;326      /* Configure ADC1_CFG register with new value */
;;;327      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000012  4a01              LDR      r2,|L4.24|
000014  6010              STR      r0,[r2,#0]
;;;328    }
000016  4770              BX       lr
;;;329    
                          ENDP

                  |L4.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetFlagStatus PROC
;;;794      */
;;;795    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
000000  4601              MOV      r1,r0
;;;796    {
;;;797      FlagStatus bitstatus;
;;;798    
;;;799      /* Check the parameters */
;;;800      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;801    
;;;802      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
000002  4a04              LDR      r2,|L5.20|
000004  6a12              LDR      r2,[r2,#0x20]
000006  400a              ANDS     r2,r2,r1
000008  b90a              CBNZ     r2,|L5.14|
;;;803      {
;;;804        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L5.16|
                  |L5.14|
;;;805      }
;;;806      else
;;;807      {
;;;808        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;809      }
;;;810    
;;;811      return bitstatus;
;;;812    }
000010  4770              BX       lr
;;;813    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetITStatus PROC
;;;1072     */
;;;1073   ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
000000  4602              MOV      r2,r0
;;;1074   {
;;;1075     ITStatus bitstatus;
;;;1076     uint32_t tmpreg;
;;;1077   
;;;1078     /* Check the parameters */
;;;1079     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1080   
;;;1081     tmpreg = MDR_ADC->ADC1_STATUS;
000002  4b05              LDR      r3,|L6.24|
000004  6a19              LDR      r1,[r3,#0x20]
;;;1082     tmpreg &= (tmpreg >> 2) & ADC_IT;
000006  ea020391          AND      r3,r2,r1,LSR #2
00000a  4019              ANDS     r1,r1,r3
;;;1083   
;;;1084     if (tmpreg == 0)
00000c  b909              CBNZ     r1,|L6.18|
;;;1085     {
;;;1086       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
000010  e000              B        |L6.20|
                  |L6.18|
;;;1087     }
;;;1088     else
;;;1089     {
;;;1090       bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L6.20|
;;;1091     }
;;;1092   
;;;1093     return bitstatus;
;;;1094   }
000014  4770              BX       lr
;;;1095   
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetResult||, CODE, READONLY, ALIGN=2

                  ADC1_GetResult PROC
;;;697      */
;;;698    uint32_t ADC1_GetResult(void)
000000  4801              LDR      r0,|L7.8|
;;;699    {
;;;700      return MDR_ADC->ADC1_RESULT;
000002  6980              LDR      r0,[r0,#0x18]
;;;701    }
000004  4770              BX       lr
;;;702    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetStatus PROC
;;;735      */
;;;736    uint32_t ADC1_GetStatus(void)
000000  4801              LDR      r0,|L8.8|
;;;737    {
;;;738      return MDR_ADC->ADC1_STATUS;
000002  6a00              LDR      r0,[r0,#0x20]
;;;739    }
000004  4770              BX       lr
;;;740    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC1_ITConfig PROC
;;;965      */
;;;966    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;967    {
;;;968      uint32_t tmpreg_ADC1_IE;
;;;969    
;;;970      /* Check the parameters */
;;;971      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;972      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;973    
;;;974      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
000002  4b05              LDR      r3,|L9.24|
000004  6a19              LDR      r1,[r3,#0x20]
;;;975    
;;;976      /* Form new value */
;;;977      if (NewState != DISABLE)
000006  b112              CBZ      r2,|L9.14|
;;;978      {
;;;979        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;980        tmpreg_ADC1_IE |= (ADC_IT << 2);
000008  ea410180          ORR      r1,r1,r0,LSL #2
00000c  e001              B        |L9.18|
                  |L9.14|
;;;981      }
;;;982      else
;;;983      {
;;;984        /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;985        tmpreg_ADC1_IE &= ~(ADC_IT << 2);
00000e  ea210180          BIC      r1,r1,r0,LSL #2
                  |L9.18|
;;;986      }
;;;987    
;;;988      /* Configure ADC1_STATUS registers with new value */
;;;989      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000012  4b01              LDR      r3,|L9.24|
000014  6219              STR      r1,[r3,#0x20]
;;;990    }
000016  4770              BX       lr
;;;991    
                          ENDP

                  |L9.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_Init||, CODE, READONLY, ALIGN=2

                  ADC1_Init PROC
;;;166      */
;;;167    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;168    {
;;;169      uint32_t tmpreg_CFG1;
;;;170      uint32_t tmpreg_CFG2;
;;;171    
;;;172      /* Check the parameters */
;;;173      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;174      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;175      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;176      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;177      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;178      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;179      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;180      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;181      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;182      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;183      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;184      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;185    
;;;186      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
000002  4b14              LDR      r3,|L10.84|
000004  681a              LDR      r2,[r3,#0]
;;;187    
;;;188      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
000006  4b14              LDR      r3,|L10.88|
000008  401a              ANDS     r2,r2,r3
;;;189                     | ADC1_CFG_REG_SAMPLE
;;;190                     | ADC1_CFG_REG_CHCH
;;;191                     | ADC1_CFG_REG_CHS_Msk
;;;192                     | ADC1_CFG_REG_RNGC
;;;193                     | ADC1_CFG_M_REF
;;;194                     | ADC1_CFG_REG_DIVCLK_Msk
;;;195                     | ADC1_CFG_DELAY_GO_Msk);
;;;196    
;;;197      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
00000a  e9d03400          LDRD     r3,r4,[r0,#0]
00000e  4423              ADD      r3,r3,r4
000010  6884              LDR      r4,[r0,#8]
000012  4423              ADD      r3,r3,r4
000014  68c4              LDR      r4,[r0,#0xc]
000016  eb031304          ADD      r3,r3,r4,LSL #4
00001a  6944              LDR      r4,[r0,#0x14]
00001c  4423              ADD      r3,r3,r4
00001e  69c4              LDR      r4,[r0,#0x1c]
000020  4423              ADD      r3,r3,r4
000022  6a44              LDR      r4,[r0,#0x24]
000024  4423              ADD      r3,r3,r4
000026  f8904028          LDRB     r4,[r0,#0x28]
00002a  eb036344          ADD      r3,r3,r4,LSL #25
00002e  441a              ADD      r2,r2,r3
;;;198                   + ADCx_InitStruct->ADC_SamplingMode
;;;199                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;200                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;201                   + ADCx_InitStruct->ADC_LevelControl
;;;202                   + ADCx_InitStruct->ADC_VRefSource
;;;203                   + ADCx_InitStruct->ADC_Prescaler
;;;204                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;205    
;;;206      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
000030  4b08              LDR      r3,|L10.84|
000032  6859              LDR      r1,[r3,#4]
;;;207      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
000034  f4213100          BIC      r1,r1,#0x20000
;;;208      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
000038  8c03              LDRH     r3,[r0,#0x20]
00003a  eb014143          ADD      r1,r1,r3,LSL #17
;;;209    
;;;210      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
00003e  4b05              LDR      r3,|L10.84|
000040  601a              STR      r2,[r3,#0]
;;;211      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
000042  6059              STR      r1,[r3,#4]
;;;212    
;;;213      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
000044  8b03              LDRH     r3,[r0,#0x18]
000046  4c03              LDR      r4,|L10.84|
000048  6123              STR      r3,[r4,#0x10]
;;;214      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
00004a  8b43              LDRH     r3,[r0,#0x1a]
00004c  60a3              STR      r3,[r4,#8]
;;;215      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
00004e  6903              LDR      r3,[r0,#0x10]
000050  62a3              STR      r3,[r4,#0x28]
;;;216    }
000052  bd10              POP      {r4,pc}
;;;217    
                          ENDP

                  |L10.84|
                          DCD      0x40088000
                  |L10.88|
                          DCD      0xf1ff0003

                          AREA ||i.ADC1_LevelsConfig||, CODE, READONLY, ALIGN=2

                  ADC1_LevelsConfig PROC
;;;563      */
;;;564    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
000000  b510              PUSH     {r4,lr}
;;;565    {
000002  4603              MOV      r3,r0
;;;566      uint32_t tmpreg_CFG;
;;;567    
;;;568      /* Check the parameters */
;;;569      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;570      assert_param(IS_ADC_VALUE(LowLevel));
;;;571      assert_param(IS_ADC_VALUE(HighLevel));
;;;572    
;;;573      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000004  4c04              LDR      r4,|L11.24|
000006  6820              LDR      r0,[r4,#0]
;;;574      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
000008  f4206080          BIC      r0,r0,#0x400
;;;575      tmpreg_CFG += NewState;
00000c  4410              ADD      r0,r0,r2
;;;576      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  6020              STR      r0,[r4,#0]
;;;577    
;;;578      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000010  6123              STR      r3,[r4,#0x10]
;;;579      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000012  60a1              STR      r1,[r4,#8]
;;;580    }
000014  bd10              POP      {r4,pc}
;;;581    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_OperationModeConfig||, CODE, READONLY, ALIGN=2

                  ADC1_OperationModeConfig PROC
;;;438      */
;;;439    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000000  4602              MOV      r2,r0
;;;440    {
;;;441      uint32_t tmpreg_CFG;
;;;442    
;;;443      /* Check the parameters */
;;;444      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;445      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;446    
;;;447      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4b04              LDR      r3,|L12.20|
000004  6818              LDR      r0,[r3,#0]
;;;448      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
000006  f4207002          BIC      r0,r0,#0x208
;;;449      tmpreg_CFG += SamplingMode + SwitchingMode;
00000a  1853              ADDS     r3,r2,r1
00000c  4418              ADD      r0,r0,r3
;;;450      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  4b01              LDR      r3,|L12.20|
000010  6018              STR      r0,[r3,#0]
;;;451    }
000012  4770              BX       lr
;;;452    
                          ENDP

                  |L12.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_SamplingModeConfig||, CODE, READONLY, ALIGN=2

                  ADC1_SamplingModeConfig PROC
;;;481      */
;;;482    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
000000  4601              MOV      r1,r0
;;;483    {
;;;484      uint32_t tmpreg_CFG;
;;;485    
;;;486      /* Check the parameters */
;;;487      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;488    
;;;489      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a03              LDR      r2,|L13.16|
000004  6810              LDR      r0,[r2,#0]
;;;490      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
000006  f0200008          BIC      r0,r0,#8
;;;491      tmpreg_CFG += SamplingMode;
00000a  4408              ADD      r0,r0,r1
;;;492      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000c  6010              STR      r0,[r2,#0]
;;;493    }
00000e  4770              BX       lr
;;;494    
                          ENDP

                  |L13.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetChannel||, CODE, READONLY, ALIGN=2

                  ADC1_SetChannel PROC
;;;369      */
;;;370    void ADC1_SetChannel(uint32_t Channel)
000000  4601              MOV      r1,r0
;;;371    {
;;;372      uint32_t tmpreg_CFG;
;;;373    
;;;374      /* Check the parameters */
;;;375      assert_param(IS_ADC1_CH_NUM(Channel));
;;;376    
;;;377      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a04              LDR      r2,|L14.20|
000004  6810              LDR      r0,[r2,#0]
;;;378      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
000006  f42070f8          BIC      r0,r0,#0x1f0
;;;379      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
00000a  eb001001          ADD      r0,r0,r1,LSL #4
;;;380      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  6010              STR      r0,[r2,#0]
;;;381    }
000010  4770              BX       lr
;;;382    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetChannels||, CODE, READONLY, ALIGN=2

                  ADC1_SetChannels PROC
;;;409      */
;;;410    void ADC1_SetChannels(uint32_t ChannelMask)
000000  4901              LDR      r1,|L15.8|
;;;411    {
;;;412      /* Check the parameters */
;;;413      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;414    
;;;415      MDR_ADC->ADC1_CHSEL = ChannelMask;
000002  6288              STR      r0,[r1,#0x28]
;;;416    }
000004  4770              BX       lr
;;;417    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetHighLevel||, CODE, READONLY, ALIGN=2

                  ADC1_SetHighLevel PROC
;;;643      */
;;;644    void ADC1_SetHighLevel(uint32_t HighLevel)
000000  4901              LDR      r1,|L16.8|
;;;645    {
;;;646      /* Check the parameters */
;;;647      assert_param(IS_ADC_VALUE(HighLevel));
;;;648    
;;;649      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000002  6088              STR      r0,[r1,#8]
;;;650    }
000004  4770              BX       lr
;;;651    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetLowLevel||, CODE, READONLY, ALIGN=2

                  ADC1_SetLowLevel PROC
;;;615      */
;;;616    void ADC1_SetLowLevel(uint32_t LowLevel)
000000  4901              LDR      r1,|L17.8|
;;;617    {
;;;618      /* Check the parameters */
;;;619      assert_param(IS_ADC_VALUE(LowLevel));
;;;620    
;;;621      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000002  6108              STR      r0,[r1,#0x10]
;;;622    }
000004  4770              BX       lr
;;;623    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_Start||, CODE, READONLY, ALIGN=2

                  ADC1_Start PROC
;;;673      */
;;;674    void ADC1_Start(void)
000000  4803              LDR      r0,|L18.16|
;;;675    {
;;;676      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L18.16|
00000a  6008              STR      r0,[r1,#0]
;;;677    }
00000c  4770              BX       lr
;;;678    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ChannelSwithingConfig||, CODE, READONLY, ALIGN=2

                  ADC2_ChannelSwithingConfig PROC
;;;542      */
;;;543    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
000000  4601              MOV      r1,r0
;;;544    {
;;;545      uint32_t tmpreg_CFG;
;;;546    
;;;547      /* Check the parameters */
;;;548      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;549    
;;;550      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a03              LDR      r2,|L19.16|
000004  6850              LDR      r0,[r2,#4]
;;;551      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
000006  f4207000          BIC      r0,r0,#0x200
;;;552      tmpreg_CFG += SwitchingMode;
00000a  4408              ADD      r0,r0,r1
;;;553      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000c  6050              STR      r0,[r2,#4]
;;;554    }
00000e  4770              BX       lr
;;;555    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L19.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ClearOutOfRangeFlag||, CODE, READONLY, ALIGN=2

                  ADC2_ClearOutOfRangeFlag PROC
;;;887      */
;;;888    void ADC2_ClearOutOfRangeFlag(void)
000000  4803              LDR      r0,|L20.16|
;;;889    {
;;;890      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L20.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;891    }
00000c  4770              BX       lr
;;;892    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ClearOverwriteFlag||, CODE, READONLY, ALIGN=2

                  ADC2_ClearOverwriteFlag PROC
;;;863      */
;;;864    void ADC2_ClearOverwriteFlag(void)
000000  4803              LDR      r0,|L21.16|
;;;865    {
;;;866      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L21.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;867    }
00000c  4770              BX       lr
;;;868    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_Cmd||, CODE, READONLY, ALIGN=2

                  ADC2_Cmd PROC
;;;338      */
;;;339    void ADC2_Cmd(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;340    {
;;;341      uint32_t tmpreg_CFG;
;;;342    
;;;343      /* Check the parameters */
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a05              LDR      r2,|L22.24|
000004  6850              LDR      r0,[r2,#4]
;;;347    
;;;348      /* Form new value */
;;;349      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L22.14|
;;;350      {
;;;351        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;352        tmpreg_CFG |= ADC2_CFG_REG_ADON;
000008  f0400001          ORR      r0,r0,#1
00000c  e001              B        |L22.18|
                  |L22.14|
;;;353      }
;;;354      else
;;;355      {
;;;356        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;357        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
00000e  f0200001          BIC      r0,r0,#1
                  |L22.18|
;;;358      }
;;;359    
;;;360      /* Configure ADC2_CFG register with new value */
;;;361      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000012  4a01              LDR      r2,|L22.24|
000014  6050              STR      r0,[r2,#4]
;;;362    }
000016  4770              BX       lr
;;;363    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L22.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetFlagStatus PROC
;;;825      */
;;;826    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
000000  4601              MOV      r1,r0
;;;827    {
;;;828      FlagStatus bitstatus;
;;;829    
;;;830      /* Check the parameters */
;;;831      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;832    
;;;833      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
000002  4a04              LDR      r2,|L23.20|
000004  6a52              LDR      r2,[r2,#0x24]
000006  400a              ANDS     r2,r2,r1
000008  b90a              CBNZ     r2,|L23.14|
;;;834      {
;;;835        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L23.16|
                  |L23.14|
;;;836      }
;;;837      else
;;;838      {
;;;839        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L23.16|
;;;840      }
;;;841    
;;;842      return bitstatus;
;;;843    }
000010  4770              BX       lr
;;;844    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetITStatus PROC
;;;1106     */
;;;1107   ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
000000  4602              MOV      r2,r0
;;;1108   {
;;;1109     ITStatus bitstatus;
;;;1110     uint32_t tmpreg;
;;;1111   
;;;1112     /* Check the parameters */
;;;1113     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1114   
;;;1115     tmpreg = MDR_ADC->ADC2_STATUS;
000002  4b05              LDR      r3,|L24.24|
000004  6a59              LDR      r1,[r3,#0x24]
;;;1116     tmpreg &= (tmpreg >> 2) & ADC_IT;
000006  ea020391          AND      r3,r2,r1,LSR #2
00000a  4019              ANDS     r1,r1,r3
;;;1117   
;;;1118     if (tmpreg == 0)
00000c  b909              CBNZ     r1,|L24.18|
;;;1119     {
;;;1120       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
000010  e000              B        |L24.20|
                  |L24.18|
;;;1121     }
;;;1122     else
;;;1123     {
;;;1124       bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L24.20|
;;;1125     }
;;;1126   
;;;1127     return bitstatus;
;;;1128   }
000014  4770              BX       lr
;;;1129   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetResult||, CODE, READONLY, ALIGN=2

                  ADC2_GetResult PROC
;;;710      */
;;;711    uint32_t ADC2_GetResult(void)
000000  4801              LDR      r0,|L25.8|
;;;712    {
;;;713      return MDR_ADC->ADC2_RESULT;
000002  69c0              LDR      r0,[r0,#0x1c]
;;;714    }
000004  4770              BX       lr
;;;715    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetStatus PROC
;;;748      */
;;;749    uint32_t ADC2_GetStatus(void)
000000  4801              LDR      r0,|L26.8|
;;;750    {
;;;751      return MDR_ADC->ADC2_STATUS;
000002  6a40              LDR      r0,[r0,#0x24]
;;;752    }
000004  4770              BX       lr
;;;753    #endif // #ifdef USE_MDR1986VE9x /* For Cortex M3 */
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC2_ITConfig PROC
;;;1004     */
;;;1005   void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;1006   {
;;;1007     uint32_t tmpreg_ADC2_IE;
;;;1008   
;;;1009     /* Check the parameters */
;;;1010     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1011     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1012   
;;;1013     tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
000002  4b05              LDR      r3,|L27.24|
000004  6a59              LDR      r1,[r3,#0x24]
;;;1014   
;;;1015     /* Form new value */
;;;1016     if (NewState != DISABLE)
000006  b112              CBZ      r2,|L27.14|
;;;1017     {
;;;1018       /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;1019       tmpreg_ADC2_IE |= (ADC_IT << 2);
000008  ea410180          ORR      r1,r1,r0,LSL #2
00000c  e001              B        |L27.18|
                  |L27.14|
;;;1020     }
;;;1021     else
;;;1022     {
;;;1023       /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;1024       tmpreg_ADC2_IE &= ~(ADC_IT << 2);
00000e  ea210180          BIC      r1,r1,r0,LSL #2
                  |L27.18|
;;;1025     }
;;;1026   
;;;1027     /* Configure ADC2_STATUS registers with new value */
;;;1028     MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000012  4b01              LDR      r3,|L27.24|
000014  6259              STR      r1,[r3,#0x24]
;;;1029   }
000016  4770              BX       lr
;;;1030   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L27.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_Init||, CODE, READONLY, ALIGN=2

                  ADC2_Init PROC
;;;228      */
;;;229    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
000000  4a11              LDR      r2,|L28.72|
;;;230    {
;;;231      uint32_t tmpreg_CFG2;
;;;232    
;;;233      /* Check the parameters */
;;;234      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;235      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;236      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;237      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;238      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;239      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;240      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;241      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;242      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;243      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;244      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;245      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;246    
;;;247      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
000002  6851              LDR      r1,[r2,#4]
;;;248    
;;;249      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
000004  4a11              LDR      r2,|L28.76|
000006  4011              ANDS     r1,r1,r2
;;;250                     | ADC2_CFG_REG_SAMPLE
;;;251                     | ADC2_CFG_REG_CHCH
;;;252                     | ADC2_CFG_REG_CHS_Msk
;;;253                     | ADC2_CFG_REG_RNGC
;;;254                     | ADC2_CFG_M_REF
;;;255                     | ADC2_CFG_ADC2_OP
;;;256                     | ADC2_CFG_REG_DIVCLK_Msk
;;;257                     | ADC2_CFG_DELAY_GO_Msk);
;;;258    
;;;259      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
000008  e9d02300          LDRD     r2,r3,[r0,#0]
00000c  441a              ADD      r2,r2,r3
00000e  6883              LDR      r3,[r0,#8]
000010  441a              ADD      r2,r2,r3
000012  68c3              LDR      r3,[r0,#0xc]
000014  eb021203          ADD      r2,r2,r3,LSL #4
000018  6943              LDR      r3,[r0,#0x14]
00001a  441a              ADD      r2,r2,r3
00001c  69c3              LDR      r3,[r0,#0x1c]
00001e  441a              ADD      r2,r2,r3
000020  8c03              LDRH     r3,[r0,#0x20]
000022  eb024283          ADD      r2,r2,r3,LSL #18
000026  6a43              LDR      r3,[r0,#0x24]
000028  441a              ADD      r2,r2,r3
00002a  f8903028          LDRB     r3,[r0,#0x28]
00002e  eb026243          ADD      r2,r2,r3,LSL #25
000032  4411              ADD      r1,r1,r2
;;;260                   + ADCx_InitStruct->ADC_SamplingMode
;;;261                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;262                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;263                   + ADCx_InitStruct->ADC_LevelControl
;;;264                   + ADCx_InitStruct->ADC_VRefSource
;;;265                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;266                   + ADCx_InitStruct->ADC_Prescaler
;;;267                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;268    
;;;269      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
000034  4a04              LDR      r2,|L28.72|
000036  6051              STR      r1,[r2,#4]
;;;270      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
000038  8b02              LDRH     r2,[r0,#0x18]
00003a  4b03              LDR      r3,|L28.72|
00003c  615a              STR      r2,[r3,#0x14]
;;;271      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
00003e  8b42              LDRH     r2,[r0,#0x1a]
000040  60da              STR      r2,[r3,#0xc]
;;;272      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
000042  6902              LDR      r2,[r0,#0x10]
000044  62da              STR      r2,[r3,#0x2c]
;;;273    }
000046  4770              BX       lr
;;;274    
                          ENDP

                  |L28.72|
                          DCD      0x40088000
                  |L28.76|
                          DCD      0xf1fb0003

                          AREA ||i.ADC2_LevelsConfig||, CODE, READONLY, ALIGN=2

                  ADC2_LevelsConfig PROC
;;;591      */
;;;592    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
000000  b510              PUSH     {r4,lr}
;;;593    {
000002  4603              MOV      r3,r0
;;;594      uint32_t tmpreg_CFG;
;;;595    
;;;596      /* Check the parameters */
;;;597      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;598      assert_param(IS_ADC_VALUE(LowLevel));
;;;599      assert_param(IS_ADC_VALUE(HighLevel));
;;;600    
;;;601      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000004  4c04              LDR      r4,|L29.24|
000006  6860              LDR      r0,[r4,#4]
;;;602      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
000008  f4206080          BIC      r0,r0,#0x400
;;;603      tmpreg_CFG += NewState;
00000c  4410              ADD      r0,r0,r2
;;;604      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  6060              STR      r0,[r4,#4]
;;;605    
;;;606      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000010  6163              STR      r3,[r4,#0x14]
;;;607      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000012  60e1              STR      r1,[r4,#0xc]
;;;608    }
000014  bd10              POP      {r4,pc}
;;;609    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_OperationModeConfig||, CODE, READONLY, ALIGN=2

                  ADC2_OperationModeConfig PROC
;;;461      */
;;;462    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000000  4602              MOV      r2,r0
;;;463    {
;;;464      uint32_t tmpreg_CFG;
;;;465    
;;;466      /* Check the parameters */
;;;467      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;468      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;469    
;;;470      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4b04              LDR      r3,|L30.20|
000004  6858              LDR      r0,[r3,#4]
;;;471      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
000006  f4207002          BIC      r0,r0,#0x208
;;;472      tmpreg_CFG += SamplingMode + SwitchingMode;
00000a  1853              ADDS     r3,r2,r1
00000c  4418              ADD      r0,r0,r3
;;;473      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  4b01              LDR      r3,|L30.20|
000010  6058              STR      r0,[r3,#4]
;;;474    }
000012  4770              BX       lr
;;;475    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L30.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_SamplingModeConfig||, CODE, READONLY, ALIGN=2

                  ADC2_SamplingModeConfig PROC
;;;502      */
;;;503    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
000000  4601              MOV      r1,r0
;;;504    {
;;;505      uint32_t tmpreg_CFG;
;;;506    
;;;507      /* Check the parameters */
;;;508      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;509    
;;;510      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a03              LDR      r2,|L31.16|
000004  6850              LDR      r0,[r2,#4]
;;;511      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
000006  f0200008          BIC      r0,r0,#8
;;;512      tmpreg_CFG += SamplingMode;
00000a  4408              ADD      r0,r0,r1
;;;513      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000c  6050              STR      r0,[r2,#4]
;;;514    }
00000e  4770              BX       lr
;;;515    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L31.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetChannel||, CODE, READONLY, ALIGN=2

                  ADC2_SetChannel PROC
;;;390      */
;;;391    void ADC2_SetChannel(uint32_t Channel)
000000  4601              MOV      r1,r0
;;;392    {
;;;393      uint32_t tmpreg_CFG;
;;;394    
;;;395      /* Check the parameters */
;;;396      assert_param(IS_ADC2_CH_NUM(Channel));
;;;397    
;;;398      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a04              LDR      r2,|L32.20|
000004  6850              LDR      r0,[r2,#4]
;;;399      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
000006  f42070f8          BIC      r0,r0,#0x1f0
;;;400      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
00000a  eb001001          ADD      r0,r0,r1,LSL #4
;;;401      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  6050              STR      r0,[r2,#4]
;;;402    }
000010  4770              BX       lr
;;;403    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetChannels||, CODE, READONLY, ALIGN=2

                  ADC2_SetChannels PROC
;;;423      */
;;;424    void ADC2_SetChannels(uint32_t ChannelMask)
000000  4901              LDR      r1,|L33.8|
;;;425    {
;;;426      /* Check the parameters */
;;;427      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;428    
;;;429      MDR_ADC->ADC2_CHSEL = ChannelMask;
000002  62c8              STR      r0,[r1,#0x2c]
;;;430    }
000004  4770              BX       lr
;;;431    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetHighLevel||, CODE, READONLY, ALIGN=2

                  ADC2_SetHighLevel PROC
;;;659      */
;;;660    void ADC2_SetHighLevel(uint32_t HighLevel)
000000  4901              LDR      r1,|L34.8|
;;;661    {
;;;662      /* Check the parameters */
;;;663      assert_param(IS_ADC_VALUE(HighLevel));
;;;664    
;;;665      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000002  60c8              STR      r0,[r1,#0xc]
;;;666    }
000004  4770              BX       lr
;;;667    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetLowLevel||, CODE, READONLY, ALIGN=2

                  ADC2_SetLowLevel PROC
;;;629      */
;;;630    void ADC2_SetLowLevel(uint32_t LowLevel)
000000  4901              LDR      r1,|L35.8|
;;;631    {
;;;632      /* Check the parameters */
;;;633      assert_param(IS_ADC_VALUE(LowLevel));
;;;634    
;;;635      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000002  6148              STR      r0,[r1,#0x14]
;;;636    }
000004  4770              BX       lr
;;;637    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_Start||, CODE, READONLY, ALIGN=2

                  ADC2_Start PROC
;;;686      */
;;;687    void ADC2_Start(void)
000000  4803              LDR      r0,|L36.16|
;;;688    {
;;;689      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
000002  6840              LDR      r0,[r0,#4]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L36.16|
00000a  6048              STR      r0,[r1,#4]
;;;690    }
00000c  4770              BX       lr
;;;691    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40088000

                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;26       */
;;;27     void ADC_DeInit ( void )
000000  2000              MOVS     r0,#0
;;;28     {
;;;29       MDR_ADC->ADC1_CFG = 0;
000002  4909              LDR      r1,|L37.40|
000004  6008              STR      r0,[r1,#0]
;;;30       MDR_ADC->ADC2_CFG = 0;
000006  6048              STR      r0,[r1,#4]
;;;31       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6088              STR      r0,[r1,#8]
;;;32       MDR_ADC->ADC1_L_LEVEL = 0;
00000a  6108              STR      r0,[r1,#0x10]
;;;33       MDR_ADC->ADC1_RESULT;
00000c  4608              MOV      r0,r1
00000e  6980              LDR      r0,[r0,#0x18]
;;;34       MDR_ADC->ADC1_STATUS = 0;
000010  2000              MOVS     r0,#0
000012  6208              STR      r0,[r1,#0x20]
;;;35       MDR_ADC->ADC1_CHSEL = 0;
000014  6288              STR      r0,[r1,#0x28]
;;;36     
;;;37     #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;38       MDR_ADC->ADC2_H_LEVEL = 0;
000016  60c8              STR      r0,[r1,#0xc]
;;;39       MDR_ADC->ADC2_L_LEVEL = 0;
000018  6148              STR      r0,[r1,#0x14]
;;;40       MDR_ADC->ADC2_RESULT;
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
;;;41       MDR_ADC->ADC2_STATUS = 0;
00001e  2000              MOVS     r0,#0
000020  6248              STR      r0,[r1,#0x24]
;;;42       MDR_ADC->ADC2_CHSEL = 0;
000022  62c8              STR      r0,[r1,#0x2c]
;;;43     #endif // #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;44     
;;;45     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;46       MDR_ADC->ADC1_TRIM = 0;
;;;47     #endif
;;;48     }
000024  4770              BX       lr
;;;49     
                          ENDP

000026  0000              DCW      0x0000
                  |L37.40|
                          DCD      0x40088000

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;766      */
;;;767    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
000000  b500              PUSH     {lr}
;;;768    {
000002  4603              MOV      r3,r0
;;;769      FlagStatus bitstatus;
;;;770    
;;;771      /* Check the parameters */
;;;772      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;773    
;;;774      if ((ADC_GetStatus() & Flag) == 0)
000004  f7fffffe          BL       ADC_GetStatus
000008  4018              ANDS     r0,r0,r3
00000a  b908              CBNZ     r0,|L38.16|
;;;775      {
;;;776        bitstatus = RESET;
00000c  2200              MOVS     r2,#0
00000e  e000              B        |L38.18|
                  |L38.16|
;;;777      }
;;;778      else
;;;779      {
;;;780        bitstatus = SET;
000010  2201              MOVS     r2,#1
                  |L38.18|
;;;781      }
;;;782    
;;;783      return bitstatus;
000012  4610              MOV      r0,r2
;;;784    }
000014  bd00              POP      {pc}
;;;785    
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1041     */
;;;1042   ITStatus ADC_GetITStatus(uint32_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;1043   {
000002  4604              MOV      r4,r0
;;;1044     ITStatus bitstatus;
;;;1045     uint32_t tmpreg;
;;;1046   
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;1049   
;;;1050     tmpreg = ADC_GetStatus();
000004  f7fffffe          BL       ADC_GetStatus
000008  4603              MOV      r3,r0
;;;1051     tmpreg &= (tmpreg >> 2) & ADC_IT;
00000a  ea040093          AND      r0,r4,r3,LSR #2
00000e  4003              ANDS     r3,r3,r0
;;;1052   
;;;1053     if (tmpreg == 0)
000010  b90b              CBNZ     r3,|L39.22|
;;;1054     {
;;;1055       bitstatus = RESET;
000012  2200              MOVS     r2,#0
000014  e000              B        |L39.24|
                  |L39.22|
;;;1056     }
;;;1057     else
;;;1058     {
;;;1059       bitstatus = SET;
000016  2201              MOVS     r2,#1
                  |L39.24|
;;;1060     }
;;;1061   
;;;1062     return bitstatus;
000018  4610              MOV      r0,r2
;;;1063   }
00001a  bd10              POP      {r4,pc}
;;;1064   
                          ENDP


                          AREA ||i.ADC_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetStatus PROC
;;;721      */
;;;722    uint32_t ADC_GetStatus ( void )
000000  4803              LDR      r0,|L40.16|
;;;723    {
;;;724    #if defined  (USE_MDR1986VE9x)|| defined (USE_MDR1901VC1T)		/* For Cortex M3 */
;;;725      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
000002  6a00              LDR      r0,[r0,#0x20]
000004  4902              LDR      r1,|L40.16|
000006  6a49              LDR      r1,[r1,#0x24]
000008  eb004001          ADD      r0,r0,r1,LSL #16
;;;726    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) 	/* For Cortex M1 */
;;;727      return MDR_ADC->ADC1_STATUS;
;;;728    #endif
;;;729    }
00000c  4770              BX       lr
;;;730    
                          ENDP

00000e  0000              DCW      0x0000
                  |L40.16|
                          DCD      0x40088000

                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC_ITConfig PROC
;;;905      */
;;;906    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;907    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;908      uint32_t tmpreg_ADC1_IE;
;;;909      uint32_t tmpreg_ADC_IT;
;;;910    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;911      uint32_t tmpreg_ADC2_IE;
;;;912    #endif
;;;913    
;;;914      /* Check the parameters */
;;;915      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;916      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;917    
;;;918      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
000006  4d0a              LDR      r5,|L41.48|
000008  6a2b              LDR      r3,[r5,#0x20]
;;;919      tmpreg_ADC_IT = ADC_IT << 2;
00000a  00a0              LSLS     r0,r4,#2
;;;920    
;;;921      /* Form new value */
;;;922      if (NewState != DISABLE)
00000c  b112              CBZ      r2,|L41.20|
;;;923      {
;;;924        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;925        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
00000e  b285              UXTH     r5,r0
000010  432b              ORRS     r3,r3,r5
000012  e001              B        |L41.24|
                  |L41.20|
;;;926      }
;;;927      else
;;;928      {
;;;929        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;930        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
000014  b285              UXTH     r5,r0
000016  43ab              BICS     r3,r3,r5
                  |L41.24|
;;;931      }
;;;932    
;;;933      /* Configure ADCx_STATUS registers with new value */
;;;934      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000018  4d05              LDR      r5,|L41.48|
00001a  622b              STR      r3,[r5,#0x20]
;;;935    
;;;936    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;937    
;;;938      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
00001c  6a69              LDR      r1,[r5,#0x24]
;;;939    
;;;940      /* Form new value */
;;;941      if (NewState != DISABLE)
00001e  b112              CBZ      r2,|L41.38|
;;;942      {
;;;943        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;944        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
000020  ea414110          ORR      r1,r1,r0,LSR #16
000024  e001              B        |L41.42|
                  |L41.38|
;;;945      }
;;;946      else
;;;947      {
;;;948        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;949        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
000026  ea214110          BIC      r1,r1,r0,LSR #16
                  |L41.42|
;;;950      }
;;;951      /* Configure ADCx_STATUS registers with new value */
;;;952      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
00002a  4d01              LDR      r5,|L41.48|
00002c  6269              STR      r1,[r5,#0x24]
;;;953    #endif /* #if defined  (USE_MDR1986VE9x) */
;;;954    }
00002e  bd30              POP      {r4,r5,pc}
;;;955    
                          ENDP

                  |L41.48|
                          DCD      0x40088000

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;57       */
;;;58     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;59     {
;;;60       uint32_t tmpreg_CFG;
;;;61       uint32_t tmpreg_MSK;
;;;62     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;63       uint32_t tmpreg_TRIM;
;;;64     #endif
;;;65     
;;;66       /* Check the parameters */
;;;67     #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;68       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;69     #endif
;;;70       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;71       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;72       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;73       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;74       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;75       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;76     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;77       assert_param(IS_ADC_INT_VREF_AMPLIFIER(ADC_InitStruct->ADC_IntVRefAmplifier));
;;;78     #endif
;;;79     
;;;80       tmpreg_CFG = (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
000002  7904              LDRB     r4,[r0,#4]
000004  6883              LDR      r3,[r0,#8]
000006  eb037304          ADD      r3,r3,r4,LSL #28
00000a  68c4              LDR      r4,[r0,#0xc]
00000c  4423              ADD      r3,r3,r4
00000e  6904              LDR      r4,[r0,#0x10]
000010  4423              ADD      r3,r3,r4
000012  6944              LDR      r4,[r0,#0x14]
000014  1919              ADDS     r1,r3,r4
;;;81                  + ADC_InitStruct->ADC_TempSensor
;;;82                  + ADC_InitStruct->ADC_TempSensorAmplifier
;;;83                  + ADC_InitStruct->ADC_TempSensorConversion
;;;84                  + ADC_InitStruct->ADC_IntVRefConversion;
;;;85     
;;;86     #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* For Cortex M3*/
;;;87       tmpreg_CFG += (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos)
000016  8b04              LDRH     r4,[r0,#0x18]
000018  6803              LDR      r3,[r0,#0]
00001a  eb035344          ADD      r3,r3,r4,LSL #21
00001e  4419              ADD      r1,r1,r3
;;;88                  +   ADC_InitStruct->ADC_SynchronousMode;
;;;89     #endif // #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;90     
;;;91       tmpreg_MSK = ADC1_CFG_DELAY_ADC_Msk
000020  4a04              LDR      r2,|L42.52|
;;;92                  | ADC1_CFG_TS_EN
;;;93                  | ADC1_CFG_TS_BUF_EN
;;;94                  | ADC1_CFG_SEL_TS
;;;95                  | ADC1_CFG_SEL_VREF;
;;;96     #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* For Cortex M3*/
;;;97       tmpreg_MSK |= ADC1_CFG_TR_Msk
000022  4b05              LDR      r3,|L42.56|
000024  431a              ORRS     r2,r2,r3
;;;98                  |  ADC1_CFG_SYNC_CONVER;
;;;99     #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;100      tmpreg_TRIM = (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_TRIM_TS_TRIM_Pos)
;;;101              | ADC_InitStruct->ADC_IntVRefAmplifier;
;;;102      MDR_ADC->ADC1_TRIM  = tmpreg_TRIM;
;;;103    #endif
;;;104    
;;;105      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
000026  4b05              LDR      r3,|L42.60|
000028  681b              LDR      r3,[r3,#0]
00002a  4393              BICS     r3,r3,r2
00002c  440b              ADD      r3,r3,r1
00002e  4c03              LDR      r4,|L42.60|
000030  6023              STR      r3,[r4,#0]
;;;106    }
000032  bd10              POP      {r4,pc}
;;;107    
                          ENDP

                  |L42.52|
                          DCD      0xf01e0000
                  |L42.56|
                          DCD      0x01e10000
                  |L42.60|
                          DCD      0x40088000

                          AREA ||i.ADC_SetTrim||, CODE, READONLY, ALIGN=2

                  ADC_SetTrim PROC
;;;138      */
;;;139    void ADC_SetTrim(uint32_t Trim)
000000  4a04              LDR      r2,|L43.20|
;;;140    {
;;;141      uint32_t tmpreg;
;;;142    
;;;143      /* Check the parameters */
;;;144      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;145    
;;;146    #if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;147      tmpreg = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
000002  6812              LDR      r2,[r2,#0]
000004  f02271f0          BIC      r1,r2,#0x1e00000
;;;148      MDR_ADC->ADC1_CFG = tmpreg + (Trim << ADC1_CFG_TR_Pos);
000008  eb015240          ADD      r2,r1,r0,LSL #21
00000c  4b01              LDR      r3,|L43.20|
00000e  601a              STR      r2,[r3,#0]
;;;149    
;;;150    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;151      tmpreg = MDR_ADC->ADC1_TRIM;
;;;152      tmpreg &= ~ADC1_TRIM_TS_TRIM_Msk;
;;;153      tmpreg |= Trim << ADC1_TRIM_TS_TRIM_Pos;
;;;154      MDR_ADC->ADC1_TRIM = tmpreg;
;;;155    #endif
;;;156    }
000010  4770              BX       lr
;;;157    
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40088000

                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;113      */
;;;114    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;115    {
;;;116    
;;;117    #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;118      ADC_InitStruct->ADC_SynchronousMode     = ADC_SyncMode_Independent;
000002  6001              STR      r1,[r0,#0]
;;;119    #endif
;;;120    
;;;121      ADC_InitStruct->ADC_StartDelay        	= 0;
000004  6041              STR      r1,[r0,#4]
;;;122      ADC_InitStruct->ADC_TempSensor        	= ADC_TEMP_SENSOR_Disable;
000006  6081              STR      r1,[r0,#8]
;;;123      ADC_InitStruct->ADC_TempSensorAmplifier   = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
000008  60c1              STR      r1,[r0,#0xc]
;;;124      ADC_InitStruct->ADC_TempSensorConversion  = ADC_TEMP_SENSOR_CONVERSION_Disable;
00000a  6101              STR      r1,[r0,#0x10]
;;;125      ADC_InitStruct->ADC_IntVRefConversion     = ADC_VREF_CONVERSION_Disable;
00000c  6141              STR      r1,[r0,#0x14]
;;;126      ADC_InitStruct->ADC_IntVRefTrimming     	= 0;
00000e  6181              STR      r1,[r0,#0x18]
;;;127    
;;;128    #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
;;;129      ADC_InitStruct->ADC_IntVRefAmplifier    	= ADC_INT_VREF_AMPLIFIER_Disable;
;;;130    #endif
;;;131    }
000010  4770              BX       lr
;;;132    
                          ENDP


                          AREA ||i.ADCx_StructInit||, CODE, READONLY, ALIGN=1

                  ADCx_StructInit PROC
;;;282      */
;;;283    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
000000  2100              MOVS     r1,#0
;;;284    {
;;;285      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
000002  6001              STR      r1,[r0,#0]
;;;286      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000004  6041              STR      r1,[r0,#4]
;;;287      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000006  6081              STR      r1,[r0,#8]
;;;288      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
000008  60c1              STR      r1,[r0,#0xc]
;;;289      ADCx_InitStruct->ADC_Channels         = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;290      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00000c  6141              STR      r1,[r0,#0x14]
;;;291      ADCx_InitStruct->ADC_LowLevel         = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;292      ADCx_InitStruct->ADC_HighLevel        = 0;
000010  8341              STRH     r1,[r0,#0x1a]
;;;293      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
000012  61c1              STR      r1,[r0,#0x1c]
;;;294      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
000014  6201              STR      r1,[r0,#0x20]
;;;295      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000016  6241              STR      r1,[r0,#0x24]
;;;296      ADCx_InitStruct->ADC_DelayGo          = 0;
000018  6281              STR      r1,[r0,#0x28]
;;;297    }
00001a  4770              BX       lr
;;;298    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 482
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____RRX|
#line 669
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
