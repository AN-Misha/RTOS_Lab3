; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_adc.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_adc.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_adc.c]
                          THUMB

                          AREA ||i.ADC1_ChannelSwithingConfig||, CODE, READONLY, ALIGN=2

                  ADC1_ChannelSwithingConfig PROC
;;;540      */
;;;541    void ADC1_ChannelSwithingConfig(uint32_t SwitchingMode)
000000  4601              MOV      r1,r0
;;;542    {
;;;543      uint32_t tmpreg_CFG;
;;;544    
;;;545      /* Check the parameters */
;;;546      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;547    
;;;548      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a03              LDR      r2,|L1.16|
000004  6810              LDR      r0,[r2,#0]
;;;549      tmpreg_CFG &= ~ADC1_CFG_REG_CHCH;
000006  f4207000          BIC      r0,r0,#0x200
;;;550      tmpreg_CFG += SwitchingMode;
00000a  4408              ADD      r0,r0,r1
;;;551      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000c  6010              STR      r0,[r2,#0]
;;;552    }
00000e  4770              BX       lr
;;;553    
                          ENDP

                  |L1.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_ClearOutOfRangeFlag||, CODE, READONLY, ALIGN=2

                  ADC1_ClearOutOfRangeFlag PROC
;;;893      */
;;;894    void ADC1_ClearOutOfRangeFlag(void)
000000  4803              LDR      r0,|L2.16|
;;;895    {
;;;896      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L2.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;897    }
00000c  4770              BX       lr
;;;898    
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_ClearOverwriteFlag||, CODE, READONLY, ALIGN=2

                  ADC1_ClearOverwriteFlag PROC
;;;869      */
;;;870    void ADC1_ClearOverwriteFlag(void)
000000  4803              LDR      r0,|L3.16|
;;;871    {
;;;872      MDR_ADC->ADC1_STATUS &= ~ADCx_FLAG_OVERWRITE;
000002  6a00              LDR      r0,[r0,#0x20]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L3.16|
00000a  6208              STR      r0,[r1,#0x20]
;;;873    }
00000c  4770              BX       lr
;;;874    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_Cmd||, CODE, READONLY, ALIGN=2

                  ADC1_Cmd PROC
;;;323      */
;;;324    void ADC1_Cmd(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;325    {
;;;326      uint32_t tmpreg_CFG;
;;;327    
;;;328      /* Check the parameters */
;;;329      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;330    
;;;331      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a05              LDR      r2,|L4.24|
000004  6810              LDR      r0,[r2,#0]
;;;332    
;;;333      /* Form new value */
;;;334      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L4.14|
;;;335      {
;;;336        /* Enable ADC1 by setting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;337        tmpreg_CFG |= ADC1_CFG_REG_ADON;
000008  f0400001          ORR      r0,r0,#1
00000c  e001              B        |L4.18|
                  |L4.14|
;;;338      }
;;;339      else
;;;340      {
;;;341        /* Disable ADC1 by resetting the Cfg_REG_ADON bit in the ADC1_CFG register */
;;;342        tmpreg_CFG &= ~ADC1_CFG_REG_ADON;
00000e  f0200001          BIC      r0,r0,#1
                  |L4.18|
;;;343      }
;;;344    
;;;345      /* Configure ADC1_CFG register with new value */
;;;346      MDR_ADC->ADC1_CFG = tmpreg_CFG;
000012  4a01              LDR      r2,|L4.24|
000014  6010              STR      r0,[r2,#0]
;;;347    }
000016  4770              BX       lr
;;;348    
                          ENDP

                  |L4.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetFlagStatus PROC
;;;813      */
;;;814    FlagStatus ADC1_GetFlagStatus(uint32_t Flag)
000000  4601              MOV      r1,r0
;;;815    {
;;;816      FlagStatus bitstatus;
;;;817    
;;;818      /* Check the parameters */
;;;819      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;820    
;;;821      if ((MDR_ADC->ADC1_STATUS & Flag) == 0)
000002  4a04              LDR      r2,|L5.20|
000004  6a12              LDR      r2,[r2,#0x20]
000006  400a              ANDS     r2,r2,r1
000008  b90a              CBNZ     r2,|L5.14|
;;;822      {
;;;823        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L5.16|
                  |L5.14|
;;;824      }
;;;825      else
;;;826      {
;;;827        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L5.16|
;;;828      }
;;;829    
;;;830      return bitstatus;
;;;831    }
000010  4770              BX       lr
;;;832    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetITStatus PROC
;;;1089     */
;;;1090   ITStatus ADC1_GetITStatus(uint32_t ADC_IT)
000000  4602              MOV      r2,r0
;;;1091   {
;;;1092     ITStatus bitstatus;
;;;1093     uint32_t tmpreg;
;;;1094   
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1097   
;;;1098     tmpreg = MDR_ADC->ADC1_STATUS;
000002  4b05              LDR      r3,|L6.24|
000004  6a19              LDR      r1,[r3,#0x20]
;;;1099     tmpreg &= (tmpreg >> 2) & ADC_IT;
000006  ea020391          AND      r3,r2,r1,LSR #2
00000a  4019              ANDS     r1,r1,r3
;;;1100   
;;;1101     if (tmpreg == 0)
00000c  b909              CBNZ     r1,|L6.18|
;;;1102     {
;;;1103       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
000010  e000              B        |L6.20|
                  |L6.18|
;;;1104     }
;;;1105     else
;;;1106     {
;;;1107       bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L6.20|
;;;1108     }
;;;1109   
;;;1110     return bitstatus;
;;;1111   }
000014  4770              BX       lr
;;;1112   
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetResult||, CODE, READONLY, ALIGN=2

                  ADC1_GetResult PROC
;;;716      */
;;;717    uint32_t ADC1_GetResult(void)
000000  4801              LDR      r0,|L7.8|
;;;718    {
;;;719      return MDR_ADC->ADC1_RESULT;
000002  6980              LDR      r0,[r0,#0x18]
;;;720    }
000004  4770              BX       lr
;;;721    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC1_GetStatus PROC
;;;754      */
;;;755    uint32_t ADC1_GetStatus(void)
000000  4801              LDR      r0,|L8.8|
;;;756    {
;;;757      return MDR_ADC->ADC1_STATUS;
000002  6a00              LDR      r0,[r0,#0x20]
;;;758    }
000004  4770              BX       lr
;;;759    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC1_ITConfig PROC
;;;982      */
;;;983    void ADC1_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;984    {
;;;985      uint32_t tmpreg_ADC1_IE;
;;;986    
;;;987      /* Check the parameters */
;;;988      assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;989      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;990    
;;;991      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
000002  4b05              LDR      r3,|L9.24|
000004  6a19              LDR      r1,[r3,#0x20]
;;;992    
;;;993      /* Form new value */
;;;994      if (NewState != DISABLE)
000006  b112              CBZ      r2,|L9.14|
;;;995      {
;;;996        /* Enable the ADC Interrupt requests by setting bits in the ADC1_STATUS register */
;;;997        tmpreg_ADC1_IE |= (ADC_IT << 2);
000008  ea410180          ORR      r1,r1,r0,LSL #2
00000c  e001              B        |L9.18|
                  |L9.14|
;;;998      }
;;;999      else
;;;1000     {
;;;1001       /* Disable the ADC Interrupt requests by clearing bits in the ADC1_STATUS register */
;;;1002       tmpreg_ADC1_IE &= ~(ADC_IT << 2);
00000e  ea210180          BIC      r1,r1,r0,LSL #2
                  |L9.18|
;;;1003     }
;;;1004   
;;;1005     /* Configure ADC1_STATUS registers with new value */
;;;1006     MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000012  4b01              LDR      r3,|L9.24|
000014  6219              STR      r1,[r3,#0x20]
;;;1007   }
000016  4770              BX       lr
;;;1008   
                          ENDP

                  |L9.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_Init||, CODE, READONLY, ALIGN=2

                  ADC1_Init PROC
;;;185      */
;;;186    void ADC1_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188      uint32_t tmpreg_CFG1;
;;;189      uint32_t tmpreg_CFG2;
;;;190    
;;;191      /* Check the parameters */
;;;192      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;193      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;194      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;195      assert_param(IS_ADC1_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;196      assert_param(IS_ADC1_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;197      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;198      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;199      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;200      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;201      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;202      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;203      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;204    
;;;205      tmpreg_CFG1 = MDR_ADC->ADC1_CFG;
000002  4b14              LDR      r3,|L10.84|
000004  681a              LDR      r2,[r3,#0]
;;;206    
;;;207      tmpreg_CFG1 &= ~(ADC1_CFG_REG_CLKS
000006  4b14              LDR      r3,|L10.88|
000008  401a              ANDS     r2,r2,r3
;;;208                     | ADC1_CFG_REG_SAMPLE
;;;209                     | ADC1_CFG_REG_CHCH
;;;210                     | ADC1_CFG_REG_CHS_Msk
;;;211                     | ADC1_CFG_REG_RNGC
;;;212                     | ADC1_CFG_M_REF
;;;213                     | ADC1_CFG_REG_DIVCLK_Msk
;;;214                     | ADC1_CFG_DELAY_GO_Msk);
;;;215    
;;;216      tmpreg_CFG1 += ADCx_InitStruct->ADC_ClockSource
00000a  e9d03400          LDRD     r3,r4,[r0,#0]
00000e  4423              ADD      r3,r3,r4
000010  6884              LDR      r4,[r0,#8]
000012  4423              ADD      r3,r3,r4
000014  68c4              LDR      r4,[r0,#0xc]
000016  eb031304          ADD      r3,r3,r4,LSL #4
00001a  6944              LDR      r4,[r0,#0x14]
00001c  4423              ADD      r3,r3,r4
00001e  69c4              LDR      r4,[r0,#0x1c]
000020  4423              ADD      r3,r3,r4
000022  6a44              LDR      r4,[r0,#0x24]
000024  4423              ADD      r3,r3,r4
000026  f8904028          LDRB     r4,[r0,#0x28]
00002a  eb036344          ADD      r3,r3,r4,LSL #25
00002e  441a              ADD      r2,r2,r3
;;;217                   + ADCx_InitStruct->ADC_SamplingMode
;;;218                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;219                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC1_CFG_REG_CHS_Pos)
;;;220                   + ADCx_InitStruct->ADC_LevelControl
;;;221                   + ADCx_InitStruct->ADC_VRefSource
;;;222                   + ADCx_InitStruct->ADC_Prescaler
;;;223                   + (ADCx_InitStruct->ADC_DelayGo << ADC1_CFG_DELAY_GO_Pos);
;;;224    
;;;225      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
000030  4b08              LDR      r3,|L10.84|
000032  6859              LDR      r1,[r3,#4]
;;;226      tmpreg_CFG2 &= ~ADC2_CFG_ADC1_OP;
000034  f4213100          BIC      r1,r1,#0x20000
;;;227      tmpreg_CFG2 += ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC1_OP_Pos;
000038  8c03              LDRH     r3,[r0,#0x20]
00003a  eb014143          ADD      r1,r1,r3,LSL #17
;;;228    
;;;229      MDR_ADC->ADC1_CFG = tmpreg_CFG1;
00003e  4b05              LDR      r3,|L10.84|
000040  601a              STR      r2,[r3,#0]
;;;230      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
000042  6059              STR      r1,[r3,#4]
;;;231    
;;;232      MDR_ADC->ADC1_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
000044  8b03              LDRH     r3,[r0,#0x18]
000046  4c03              LDR      r4,|L10.84|
000048  6123              STR      r3,[r4,#0x10]
;;;233      MDR_ADC->ADC1_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
00004a  8b43              LDRH     r3,[r0,#0x1a]
00004c  60a3              STR      r3,[r4,#8]
;;;234      MDR_ADC->ADC1_CHSEL   = ADCx_InitStruct->ADC_Channels;
00004e  6903              LDR      r3,[r0,#0x10]
000050  62a3              STR      r3,[r4,#0x28]
;;;235    }
000052  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  |L10.84|
                          DCD      0x40088000
                  |L10.88|
                          DCD      0xf1ff0003

                          AREA ||i.ADC1_LevelsConfig||, CODE, READONLY, ALIGN=2

                  ADC1_LevelsConfig PROC
;;;582      */
;;;583    void ADC1_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
000000  b510              PUSH     {r4,lr}
;;;584    {
000002  4603              MOV      r3,r0
;;;585      uint32_t tmpreg_CFG;
;;;586    
;;;587      /* Check the parameters */
;;;588      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;589      assert_param(IS_ADC_VALUE(LowLevel));
;;;590      assert_param(IS_ADC_VALUE(HighLevel));
;;;591    
;;;592      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000004  4c04              LDR      r4,|L11.24|
000006  6820              LDR      r0,[r4,#0]
;;;593      tmpreg_CFG &= ~ADC1_CFG_REG_RNGC;
000008  f4206080          BIC      r0,r0,#0x400
;;;594      tmpreg_CFG += NewState;
00000c  4410              ADD      r0,r0,r2
;;;595      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  6020              STR      r0,[r4,#0]
;;;596    
;;;597      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000010  6123              STR      r3,[r4,#0x10]
;;;598      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000012  60a1              STR      r1,[r4,#8]
;;;599    }
000014  bd10              POP      {r4,pc}
;;;600    
                          ENDP

000016  0000              DCW      0x0000
                  |L11.24|
                          DCD      0x40088000

                          AREA ||i.ADC1_OperationModeConfig||, CODE, READONLY, ALIGN=2

                  ADC1_OperationModeConfig PROC
;;;457      */
;;;458    void ADC1_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000000  4602              MOV      r2,r0
;;;459    {
;;;460      uint32_t tmpreg_CFG;
;;;461    
;;;462      /* Check the parameters */
;;;463      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;464      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;465    
;;;466      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4b04              LDR      r3,|L12.20|
000004  6818              LDR      r0,[r3,#0]
;;;467      tmpreg_CFG &= ~(ADC1_CFG_REG_SAMPLE | ADC1_CFG_REG_CHCH);
000006  f4207002          BIC      r0,r0,#0x208
;;;468      tmpreg_CFG += SamplingMode + SwitchingMode;
00000a  1853              ADDS     r3,r2,r1
00000c  4418              ADD      r0,r0,r3
;;;469      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  4b01              LDR      r3,|L12.20|
000010  6018              STR      r0,[r3,#0]
;;;470    }
000012  4770              BX       lr
;;;471    
                          ENDP

                  |L12.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_SamplingModeConfig||, CODE, READONLY, ALIGN=2

                  ADC1_SamplingModeConfig PROC
;;;500      */
;;;501    void ADC1_SamplingModeConfig(uint32_t SamplingMode)
000000  4601              MOV      r1,r0
;;;502    {
;;;503      uint32_t tmpreg_CFG;
;;;504    
;;;505      /* Check the parameters */
;;;506      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;507    
;;;508      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a03              LDR      r2,|L13.16|
000004  6810              LDR      r0,[r2,#0]
;;;509      tmpreg_CFG &= ~ADC1_CFG_REG_SAMPLE;
000006  f0200008          BIC      r0,r0,#8
;;;510      tmpreg_CFG += SamplingMode;
00000a  4408              ADD      r0,r0,r1
;;;511      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000c  6010              STR      r0,[r2,#0]
;;;512    }
00000e  4770              BX       lr
;;;513    
                          ENDP

                  |L13.16|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetChannel||, CODE, READONLY, ALIGN=2

                  ADC1_SetChannel PROC
;;;388      */
;;;389    void ADC1_SetChannel(uint32_t Channel)
000000  4601              MOV      r1,r0
;;;390    {
;;;391      uint32_t tmpreg_CFG;
;;;392    
;;;393      /* Check the parameters */
;;;394      assert_param(IS_ADC1_CH_NUM(Channel));
;;;395    
;;;396      tmpreg_CFG = MDR_ADC->ADC1_CFG;
000002  4a04              LDR      r2,|L14.20|
000004  6810              LDR      r0,[r2,#0]
;;;397      tmpreg_CFG &= ~ADC1_CFG_REG_CHS_Msk;
000006  f42070f8          BIC      r0,r0,#0x1f0
;;;398      tmpreg_CFG += Channel << ADC1_CFG_REG_CHS_Pos;
00000a  eb001001          ADD      r0,r0,r1,LSL #4
;;;399      MDR_ADC->ADC1_CFG = tmpreg_CFG;
00000e  6010              STR      r0,[r2,#0]
;;;400    }
000010  4770              BX       lr
;;;401    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetChannels||, CODE, READONLY, ALIGN=2

                  ADC1_SetChannels PROC
;;;428      */
;;;429    void ADC1_SetChannels(uint32_t ChannelMask)
000000  4901              LDR      r1,|L15.8|
;;;430    {
;;;431      /* Check the parameters */
;;;432      assert_param(IS_ADC1_CH_MASK(ChannelMask));
;;;433    
;;;434      MDR_ADC->ADC1_CHSEL = ChannelMask;
000002  6288              STR      r0,[r1,#0x28]
;;;435    }
000004  4770              BX       lr
;;;436    
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetHighLevel||, CODE, READONLY, ALIGN=2

                  ADC1_SetHighLevel PROC
;;;662      */
;;;663    void ADC1_SetHighLevel(uint32_t HighLevel)
000000  4901              LDR      r1,|L16.8|
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_ADC_VALUE(HighLevel));
;;;667    
;;;668      MDR_ADC->ADC1_H_LEVEL = HighLevel;
000002  6088              STR      r0,[r1,#8]
;;;669    }
000004  4770              BX       lr
;;;670    
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_SetLowLevel||, CODE, READONLY, ALIGN=2

                  ADC1_SetLowLevel PROC
;;;634      */
;;;635    void ADC1_SetLowLevel(uint32_t LowLevel)
000000  4901              LDR      r1,|L17.8|
;;;636    {
;;;637      /* Check the parameters */
;;;638      assert_param(IS_ADC_VALUE(LowLevel));
;;;639    
;;;640      MDR_ADC->ADC1_L_LEVEL = LowLevel;
000002  6108              STR      r0,[r1,#0x10]
;;;641    }
000004  4770              BX       lr
;;;642    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x40088000

                          AREA ||i.ADC1_Start||, CODE, READONLY, ALIGN=2

                  ADC1_Start PROC
;;;692      */
;;;693    void ADC1_Start(void)
000000  4803              LDR      r0,|L18.16|
;;;694    {
;;;695      MDR_ADC->ADC1_CFG |= ADC1_CFG_REG_GO;
000002  6800              LDR      r0,[r0,#0]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L18.16|
00000a  6008              STR      r0,[r1,#0]
;;;696    }
00000c  4770              BX       lr
;;;697    
                          ENDP

00000e  0000              DCW      0x0000
                  |L18.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ChannelSwithingConfig||, CODE, READONLY, ALIGN=2

                  ADC2_ChannelSwithingConfig PROC
;;;561      */
;;;562    void ADC2_ChannelSwithingConfig(uint32_t SwitchingMode)
000000  4601              MOV      r1,r0
;;;563    {
;;;564      uint32_t tmpreg_CFG;
;;;565    
;;;566      /* Check the parameters */
;;;567      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;568    
;;;569      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a03              LDR      r2,|L19.16|
000004  6850              LDR      r0,[r2,#4]
;;;570      tmpreg_CFG &= ~ADC2_CFG_REG_CHCH;
000006  f4207000          BIC      r0,r0,#0x200
;;;571      tmpreg_CFG += SwitchingMode;
00000a  4408              ADD      r0,r0,r1
;;;572      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000c  6050              STR      r0,[r2,#4]
;;;573    }
00000e  4770              BX       lr
;;;574    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L19.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ClearOutOfRangeFlag||, CODE, READONLY, ALIGN=2

                  ADC2_ClearOutOfRangeFlag PROC
;;;906      */
;;;907    void ADC2_ClearOutOfRangeFlag(void)
000000  4803              LDR      r0,|L20.16|
;;;908    {
;;;909      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OUT_OF_RANGE;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0200002          BIC      r0,r0,#2
000008  4901              LDR      r1,|L20.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;910    }
00000c  4770              BX       lr
;;;911    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L20.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_ClearOverwriteFlag||, CODE, READONLY, ALIGN=2

                  ADC2_ClearOverwriteFlag PROC
;;;882      */
;;;883    void ADC2_ClearOverwriteFlag(void)
000000  4803              LDR      r0,|L21.16|
;;;884    {
;;;885      MDR_ADC->ADC2_STATUS &= ~ADCx_FLAG_OVERWRITE;
000002  6a40              LDR      r0,[r0,#0x24]
000004  f0200001          BIC      r0,r0,#1
000008  4901              LDR      r1,|L21.16|
00000a  6248              STR      r0,[r1,#0x24]
;;;886    }
00000c  4770              BX       lr
;;;887    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_Cmd||, CODE, READONLY, ALIGN=2

                  ADC2_Cmd PROC
;;;357      */
;;;358    void ADC2_Cmd(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;359    {
;;;360      uint32_t tmpreg_CFG;
;;;361    
;;;362      /* Check the parameters */
;;;363      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;364    
;;;365      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a05              LDR      r2,|L22.24|
000004  6850              LDR      r0,[r2,#4]
;;;366    
;;;367      /* Form new value */
;;;368      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L22.14|
;;;369      {
;;;370        /* Enable ADC2 by setting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;371        tmpreg_CFG |= ADC2_CFG_REG_ADON;
000008  f0400001          ORR      r0,r0,#1
00000c  e001              B        |L22.18|
                  |L22.14|
;;;372      }
;;;373      else
;;;374      {
;;;375        /* Disable ADC2 by resetting the Cfg_REG_ADON bit in the ADC2_CFG register */
;;;376        tmpreg_CFG &= ~ADC2_CFG_REG_ADON;
00000e  f0200001          BIC      r0,r0,#1
                  |L22.18|
;;;377      }
;;;378    
;;;379      /* Configure ADC2_CFG register with new value */
;;;380      MDR_ADC->ADC2_CFG = tmpreg_CFG;
000012  4a01              LDR      r2,|L22.24|
000014  6050              STR      r0,[r2,#4]
;;;381    }
000016  4770              BX       lr
;;;382    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L22.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetFlagStatus PROC
;;;844      */
;;;845    FlagStatus ADC2_GetFlagStatus(uint32_t Flag)
000000  4601              MOV      r1,r0
;;;846    {
;;;847      FlagStatus bitstatus;
;;;848    
;;;849      /* Check the parameters */
;;;850      assert_param(IS_ADCx_STATUS_FLAG(Flag));
;;;851    
;;;852      if ((MDR_ADC->ADC2_STATUS & Flag) == 0)
000002  4a04              LDR      r2,|L23.20|
000004  6a52              LDR      r2,[r2,#0x24]
000006  400a              ANDS     r2,r2,r1
000008  b90a              CBNZ     r2,|L23.14|
;;;853      {
;;;854        bitstatus = RESET;
00000a  2000              MOVS     r0,#0
00000c  e000              B        |L23.16|
                  |L23.14|
;;;855      }
;;;856      else
;;;857      {
;;;858        bitstatus = SET;
00000e  2001              MOVS     r0,#1
                  |L23.16|
;;;859      }
;;;860    
;;;861      return bitstatus;
;;;862    }
000010  4770              BX       lr
;;;863    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000012  0000              DCW      0x0000
                  |L23.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetITStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetITStatus PROC
;;;1123     */
;;;1124   ITStatus ADC2_GetITStatus(uint32_t ADC_IT)
000000  4602              MOV      r2,r0
;;;1125   {
;;;1126     ITStatus bitstatus;
;;;1127     uint32_t tmpreg;
;;;1128   
;;;1129     /* Check the parameters */
;;;1130     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1131   
;;;1132     tmpreg = MDR_ADC->ADC2_STATUS;
000002  4b05              LDR      r3,|L24.24|
000004  6a59              LDR      r1,[r3,#0x24]
;;;1133     tmpreg &= (tmpreg >> 2) & ADC_IT;
000006  ea020391          AND      r3,r2,r1,LSR #2
00000a  4019              ANDS     r1,r1,r3
;;;1134   
;;;1135     if (tmpreg == 0)
00000c  b909              CBNZ     r1,|L24.18|
;;;1136     {
;;;1137       bitstatus = RESET;
00000e  2000              MOVS     r0,#0
000010  e000              B        |L24.20|
                  |L24.18|
;;;1138     }
;;;1139     else
;;;1140     {
;;;1141       bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L24.20|
;;;1142     }
;;;1143   
;;;1144     return bitstatus;
;;;1145   }
000014  4770              BX       lr
;;;1146   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetResult||, CODE, READONLY, ALIGN=2

                  ADC2_GetResult PROC
;;;729      */
;;;730    uint32_t ADC2_GetResult(void)
000000  4801              LDR      r0,|L25.8|
;;;731    {
;;;732      return MDR_ADC->ADC2_RESULT;
000002  69c0              LDR      r0,[r0,#0x1c]
;;;733    }
000004  4770              BX       lr
;;;734    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L25.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC2_GetStatus PROC
;;;767      */
;;;768    uint32_t ADC2_GetStatus(void)
000000  4801              LDR      r0,|L26.8|
;;;769    {
;;;770      return MDR_ADC->ADC2_STATUS;
000002  6a40              LDR      r0,[r0,#0x24]
;;;771    }
000004  4770              BX       lr
;;;772    #endif // #ifdef USE_MDR1986VE9x /* For Cortex M3 */
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC2_ITConfig PROC
;;;1021     */
;;;1022   void ADC2_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  460a              MOV      r2,r1
;;;1023   {
;;;1024     uint32_t tmpreg_ADC2_IE;
;;;1025   
;;;1026     /* Check the parameters */
;;;1027     assert_param(IS_ADCx_CONFIG_IT(ADC_IT));
;;;1028     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1029   
;;;1030     tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
000002  4b05              LDR      r3,|L27.24|
000004  6a59              LDR      r1,[r3,#0x24]
;;;1031   
;;;1032     /* Form new value */
;;;1033     if (NewState != DISABLE)
000006  b112              CBZ      r2,|L27.14|
;;;1034     {
;;;1035       /* Enable the ADC Interrupt requests by setting bits in the ADC2_STATUS register */
;;;1036       tmpreg_ADC2_IE |= (ADC_IT << 2);
000008  ea410180          ORR      r1,r1,r0,LSL #2
00000c  e001              B        |L27.18|
                  |L27.14|
;;;1037     }
;;;1038     else
;;;1039     {
;;;1040       /* Disable the ADC Interrupt requests by clearing bits in the ADC2_STATUS register */
;;;1041       tmpreg_ADC2_IE &= ~(ADC_IT << 2);
00000e  ea210180          BIC      r1,r1,r0,LSL #2
                  |L27.18|
;;;1042     }
;;;1043   
;;;1044     /* Configure ADC2_STATUS registers with new value */
;;;1045     MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
000012  4b01              LDR      r3,|L27.24|
000014  6259              STR      r1,[r3,#0x24]
;;;1046   }
000016  4770              BX       lr
;;;1047   #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L27.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_Init||, CODE, READONLY, ALIGN=2

                  ADC2_Init PROC
;;;247      */
;;;248    void ADC2_Init(const ADCx_InitTypeDef* ADCx_InitStruct)
000000  4a11              LDR      r2,|L28.72|
;;;249    {
;;;250      uint32_t tmpreg_CFG2;
;;;251    
;;;252      /* Check the parameters */
;;;253      assert_param(IS_ADC_CLOCK_SOURCE_CONFIG(ADCx_InitStruct->ADC_ClockSource));
;;;254      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(ADCx_InitStruct->ADC_SamplingMode));
;;;255      assert_param(IS_ADC_CH_SWITCHING_CONFIG(ADCx_InitStruct->ADC_ChannelSwitching));
;;;256      assert_param(IS_ADC2_CH_NUM(ADCx_InitStruct->ADC_ChannelNumber));
;;;257      assert_param(IS_ADC2_CH_MASK(ADCx_InitStruct->ADC_Channels));
;;;258      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(ADCx_InitStruct->ADC_LevelControl));
;;;259      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_LowLevel));
;;;260      assert_param(IS_ADC_VALUE(ADCx_InitStruct->ADC_HighLevel));
;;;261      assert_param(IS_ADC_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_VRefSource));
;;;262      assert_param(IS_ADC_INT_VREF_SOURCE_CONFIG(ADCx_InitStruct->ADC_IntVRefSource));
;;;263      assert_param(IS_ADC_CLK_div_VALUE(ADCx_InitStruct->ADC_Prescaler));
;;;264      assert_param(IS_ADC_DELAY_GO_VALUE(ADCx_InitStruct->ADC_DelayGo));
;;;265    
;;;266      tmpreg_CFG2 = MDR_ADC->ADC2_CFG;
000002  6851              LDR      r1,[r2,#4]
;;;267    
;;;268      tmpreg_CFG2 &= ~(ADC2_CFG_REG_CLKS
000004  4a11              LDR      r2,|L28.76|
000006  4011              ANDS     r1,r1,r2
;;;269                     | ADC2_CFG_REG_SAMPLE
;;;270                     | ADC2_CFG_REG_CHCH
;;;271                     | ADC2_CFG_REG_CHS_Msk
;;;272                     | ADC2_CFG_REG_RNGC
;;;273                     | ADC2_CFG_M_REF
;;;274                     | ADC2_CFG_ADC2_OP
;;;275                     | ADC2_CFG_REG_DIVCLK_Msk
;;;276                     | ADC2_CFG_DELAY_GO_Msk);
;;;277    
;;;278      tmpreg_CFG2 += ADCx_InitStruct->ADC_ClockSource
000008  e9d02300          LDRD     r2,r3,[r0,#0]
00000c  441a              ADD      r2,r2,r3
00000e  6883              LDR      r3,[r0,#8]
000010  441a              ADD      r2,r2,r3
000012  68c3              LDR      r3,[r0,#0xc]
000014  eb021203          ADD      r2,r2,r3,LSL #4
000018  6943              LDR      r3,[r0,#0x14]
00001a  441a              ADD      r2,r2,r3
00001c  69c3              LDR      r3,[r0,#0x1c]
00001e  441a              ADD      r2,r2,r3
000020  8c03              LDRH     r3,[r0,#0x20]
000022  eb024283          ADD      r2,r2,r3,LSL #18
000026  6a43              LDR      r3,[r0,#0x24]
000028  441a              ADD      r2,r2,r3
00002a  f8903028          LDRB     r3,[r0,#0x28]
00002e  eb026243          ADD      r2,r2,r3,LSL #25
000032  4411              ADD      r1,r1,r2
;;;279                   + ADCx_InitStruct->ADC_SamplingMode
;;;280                   + ADCx_InitStruct->ADC_ChannelSwitching
;;;281                   + (ADCx_InitStruct->ADC_ChannelNumber << ADC2_CFG_REG_CHS_Pos)
;;;282                   + ADCx_InitStruct->ADC_LevelControl
;;;283                   + ADCx_InitStruct->ADC_VRefSource
;;;284                   + (ADCx_InitStruct->ADC_IntVRefSource << ADC2_CFG_ADC2_OP_Pos)
;;;285                   + ADCx_InitStruct->ADC_Prescaler
;;;286                   + (ADCx_InitStruct->ADC_DelayGo << ADC2_CFG_DELAY_GO_Pos);
;;;287    
;;;288      MDR_ADC->ADC2_CFG = tmpreg_CFG2;
000034  4a04              LDR      r2,|L28.72|
000036  6051              STR      r1,[r2,#4]
;;;289      MDR_ADC->ADC2_L_LEVEL = ADCx_InitStruct->ADC_LowLevel;
000038  8b02              LDRH     r2,[r0,#0x18]
00003a  4b03              LDR      r3,|L28.72|
00003c  615a              STR      r2,[r3,#0x14]
;;;290      MDR_ADC->ADC2_H_LEVEL = ADCx_InitStruct->ADC_HighLevel;
00003e  8b42              LDRH     r2,[r0,#0x1a]
000040  60da              STR      r2,[r3,#0xc]
;;;291      MDR_ADC->ADC2_CHSEL   = ADCx_InitStruct->ADC_Channels;
000042  6902              LDR      r2,[r0,#0x10]
000044  62da              STR      r2,[r3,#0x2c]
;;;292    }
000046  4770              BX       lr
;;;293    
                          ENDP

                  |L28.72|
                          DCD      0x40088000
                  |L28.76|
                          DCD      0xf1fb0003

                          AREA ||i.ADC2_LevelsConfig||, CODE, READONLY, ALIGN=2

                  ADC2_LevelsConfig PROC
;;;610      */
;;;611    void ADC2_LevelsConfig(uint32_t LowLevel, uint32_t HighLevel, uint32_t NewState)
000000  b510              PUSH     {r4,lr}
;;;612    {
000002  4603              MOV      r3,r0
;;;613      uint32_t tmpreg_CFG;
;;;614    
;;;615      /* Check the parameters */
;;;616      assert_param(IS_ADC_LEVEL_CONTROL_CONFIG(NewState));
;;;617      assert_param(IS_ADC_VALUE(LowLevel));
;;;618      assert_param(IS_ADC_VALUE(HighLevel));
;;;619    
;;;620      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000004  4c04              LDR      r4,|L29.24|
000006  6860              LDR      r0,[r4,#4]
;;;621      tmpreg_CFG &= ~ADC2_CFG_REG_RNGC;
000008  f4206080          BIC      r0,r0,#0x400
;;;622      tmpreg_CFG += NewState;
00000c  4410              ADD      r0,r0,r2
;;;623      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  6060              STR      r0,[r4,#4]
;;;624    
;;;625      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000010  6163              STR      r3,[r4,#0x14]
;;;626      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000012  60e1              STR      r1,[r4,#0xc]
;;;627    }
000014  bd10              POP      {r4,pc}
;;;628    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000016  0000              DCW      0x0000
                  |L29.24|
                          DCD      0x40088000

                          AREA ||i.ADC2_OperationModeConfig||, CODE, READONLY, ALIGN=2

                  ADC2_OperationModeConfig PROC
;;;480      */
;;;481    void ADC2_OperationModeConfig(uint32_t SamplingMode, uint32_t SwitchingMode)
000000  4602              MOV      r2,r0
;;;482    {
;;;483      uint32_t tmpreg_CFG;
;;;484    
;;;485      /* Check the parameters */
;;;486      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;487      assert_param(IS_ADC_CH_SWITCHING_CONFIG(SwitchingMode));
;;;488    
;;;489      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4b04              LDR      r3,|L30.20|
000004  6858              LDR      r0,[r3,#4]
;;;490      tmpreg_CFG &= ~(ADC2_CFG_REG_SAMPLE | ADC2_CFG_REG_CHCH);
000006  f4207002          BIC      r0,r0,#0x208
;;;491      tmpreg_CFG += SamplingMode + SwitchingMode;
00000a  1853              ADDS     r3,r2,r1
00000c  4418              ADD      r0,r0,r3
;;;492      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  4b01              LDR      r3,|L30.20|
000010  6058              STR      r0,[r3,#4]
;;;493    }
000012  4770              BX       lr
;;;494    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L30.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_SamplingModeConfig||, CODE, READONLY, ALIGN=2

                  ADC2_SamplingModeConfig PROC
;;;521      */
;;;522    void ADC2_SamplingModeConfig(uint32_t SamplingMode)
000000  4601              MOV      r1,r0
;;;523    {
;;;524      uint32_t tmpreg_CFG;
;;;525    
;;;526      /* Check the parameters */
;;;527      assert_param(IS_ADC_SAMPLING_MODE_CONFIG(SamplingMode));
;;;528    
;;;529      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a03              LDR      r2,|L31.16|
000004  6850              LDR      r0,[r2,#4]
;;;530      tmpreg_CFG &= ~ADC2_CFG_REG_SAMPLE;
000006  f0200008          BIC      r0,r0,#8
;;;531      tmpreg_CFG += SamplingMode;
00000a  4408              ADD      r0,r0,r1
;;;532      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000c  6050              STR      r0,[r2,#4]
;;;533    }
00000e  4770              BX       lr
;;;534    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

                  |L31.16|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetChannel||, CODE, READONLY, ALIGN=2

                  ADC2_SetChannel PROC
;;;409      */
;;;410    void ADC2_SetChannel(uint32_t Channel)
000000  4601              MOV      r1,r0
;;;411    {
;;;412      uint32_t tmpreg_CFG;
;;;413    
;;;414      /* Check the parameters */
;;;415      assert_param(IS_ADC2_CH_NUM(Channel));
;;;416    
;;;417      tmpreg_CFG = MDR_ADC->ADC2_CFG;
000002  4a04              LDR      r2,|L32.20|
000004  6850              LDR      r0,[r2,#4]
;;;418      tmpreg_CFG &= ~ADC2_CFG_REG_CHS_Msk;
000006  f42070f8          BIC      r0,r0,#0x1f0
;;;419      tmpreg_CFG += Channel << ADC2_CFG_REG_CHS_Pos;
00000a  eb001001          ADD      r0,r0,r1,LSL #4
;;;420      MDR_ADC->ADC2_CFG = tmpreg_CFG;
00000e  6050              STR      r0,[r2,#4]
;;;421    }
000010  4770              BX       lr
;;;422    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetChannels||, CODE, READONLY, ALIGN=2

                  ADC2_SetChannels PROC
;;;442      */
;;;443    void ADC2_SetChannels(uint32_t ChannelMask)
000000  4901              LDR      r1,|L33.8|
;;;444    {
;;;445      /* Check the parameters */
;;;446      assert_param(IS_ADC2_CH_MASK(ChannelMask));
;;;447    
;;;448      MDR_ADC->ADC2_CHSEL = ChannelMask;
000002  62c8              STR      r0,[r1,#0x2c]
;;;449    }
000004  4770              BX       lr
;;;450    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetHighLevel||, CODE, READONLY, ALIGN=2

                  ADC2_SetHighLevel PROC
;;;678      */
;;;679    void ADC2_SetHighLevel(uint32_t HighLevel)
000000  4901              LDR      r1,|L34.8|
;;;680    {
;;;681      /* Check the parameters */
;;;682      assert_param(IS_ADC_VALUE(HighLevel));
;;;683    
;;;684      MDR_ADC->ADC2_H_LEVEL = HighLevel;
000002  60c8              STR      r0,[r1,#0xc]
;;;685    }
000004  4770              BX       lr
;;;686    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L34.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_SetLowLevel||, CODE, READONLY, ALIGN=2

                  ADC2_SetLowLevel PROC
;;;648      */
;;;649    void ADC2_SetLowLevel(uint32_t LowLevel)
000000  4901              LDR      r1,|L35.8|
;;;650    {
;;;651      /* Check the parameters */
;;;652      assert_param(IS_ADC_VALUE(LowLevel));
;;;653    
;;;654      MDR_ADC->ADC2_L_LEVEL = LowLevel;
000002  6148              STR      r0,[r1,#0x14]
;;;655    }
000004  4770              BX       lr
;;;656    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

000006  0000              DCW      0x0000
                  |L35.8|
                          DCD      0x40088000

                          AREA ||i.ADC2_Start||, CODE, READONLY, ALIGN=2

                  ADC2_Start PROC
;;;705      */
;;;706    void ADC2_Start(void)
000000  4803              LDR      r0,|L36.16|
;;;707    {
;;;708      MDR_ADC->ADC2_CFG |= ADC2_CFG_REG_GO;
000002  6840              LDR      r0,[r0,#4]
000004  f0400002          ORR      r0,r0,#2
000008  4901              LDR      r1,|L36.16|
00000a  6048              STR      r0,[r1,#4]
;;;709    }
00000c  4770              BX       lr
;;;710    #endif /* #if defined  (USE_MDR1986VE9x) */
                          ENDP

00000e  0000              DCW      0x0000
                  |L36.16|
                          DCD      0x40088000

                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;45       */
;;;46     void ADC_DeInit ( void )
000000  2000              MOVS     r0,#0
;;;47     {
;;;48       MDR_ADC->ADC1_CFG = 0;
000002  4909              LDR      r1,|L37.40|
000004  6008              STR      r0,[r1,#0]
;;;49       MDR_ADC->ADC2_CFG = 0;
000006  6048              STR      r0,[r1,#4]
;;;50       MDR_ADC->ADC1_H_LEVEL = 0;
000008  6088              STR      r0,[r1,#8]
;;;51       MDR_ADC->ADC1_L_LEVEL = 0;
00000a  6108              STR      r0,[r1,#0x10]
;;;52       MDR_ADC->ADC1_RESULT;
00000c  4608              MOV      r0,r1
00000e  6980              LDR      r0,[r0,#0x18]
;;;53       MDR_ADC->ADC1_STATUS = 0;
000010  2000              MOVS     r0,#0
000012  6208              STR      r0,[r1,#0x20]
;;;54       MDR_ADC->ADC1_CHSEL = 0;
000014  6288              STR      r0,[r1,#0x28]
;;;55     
;;;56     #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;57       MDR_ADC->ADC2_H_LEVEL = 0;
000016  60c8              STR      r0,[r1,#0xc]
;;;58       MDR_ADC->ADC2_L_LEVEL = 0;
000018  6148              STR      r0,[r1,#0x14]
;;;59       MDR_ADC->ADC2_RESULT;
00001a  4608              MOV      r0,r1
00001c  69c0              LDR      r0,[r0,#0x1c]
;;;60       MDR_ADC->ADC2_STATUS = 0;
00001e  2000              MOVS     r0,#0
000020  6248              STR      r0,[r1,#0x24]
;;;61       MDR_ADC->ADC2_CHSEL = 0;
000022  62c8              STR      r0,[r1,#0x2c]
;;;62     #endif // #if defined ( USE_MDR1986VE9x ) /* For Cortex M3 */
;;;63     
;;;64     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;65       MDR_ADC->ADC1_TRIM = 0;
;;;66     #endif
;;;67     }
000024  4770              BX       lr
;;;68     
                          ENDP

000026  0000              DCW      0x0000
                  |L37.40|
                          DCD      0x40088000

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;785      */
;;;786    FlagStatus ADC_GetFlagStatus(uint32_t Flag)
000000  b500              PUSH     {lr}
;;;787    {
000002  4603              MOV      r3,r0
;;;788      FlagStatus bitstatus;
;;;789    
;;;790      /* Check the parameters */
;;;791      assert_param(IS_ADC_STATUS_FLAG(Flag));
;;;792    
;;;793      if ((ADC_GetStatus() & Flag) == 0)
000004  f7fffffe          BL       ADC_GetStatus
000008  4018              ANDS     r0,r0,r3
00000a  b908              CBNZ     r0,|L38.16|
;;;794      {
;;;795        bitstatus = RESET;
00000c  2200              MOVS     r2,#0
00000e  e000              B        |L38.18|
                  |L38.16|
;;;796      }
;;;797      else
;;;798      {
;;;799        bitstatus = SET;
000010  2201              MOVS     r2,#1
                  |L38.18|
;;;800      }
;;;801    
;;;802      return bitstatus;
000012  4610              MOV      r0,r2
;;;803    }
000014  bd00              POP      {pc}
;;;804    
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1058     */
;;;1059   ITStatus ADC_GetITStatus(uint32_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;1060   {
000002  4604              MOV      r4,r0
;;;1061     ITStatus bitstatus;
;;;1062     uint32_t tmpreg;
;;;1063   
;;;1064     /* Check the parameters */
;;;1065     assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;1066   
;;;1067     tmpreg = ADC_GetStatus();
000004  f7fffffe          BL       ADC_GetStatus
000008  4603              MOV      r3,r0
;;;1068     tmpreg &= (tmpreg >> 2) & ADC_IT;
00000a  ea040093          AND      r0,r4,r3,LSR #2
00000e  4003              ANDS     r3,r3,r0
;;;1069   
;;;1070     if (tmpreg == 0)
000010  b90b              CBNZ     r3,|L39.22|
;;;1071     {
;;;1072       bitstatus = RESET;
000012  2200              MOVS     r2,#0
000014  e000              B        |L39.24|
                  |L39.22|
;;;1073     }
;;;1074     else
;;;1075     {
;;;1076       bitstatus = SET;
000016  2201              MOVS     r2,#1
                  |L39.24|
;;;1077     }
;;;1078   
;;;1079     return bitstatus;
000018  4610              MOV      r0,r2
;;;1080   }
00001a  bd10              POP      {r4,pc}
;;;1081   
                          ENDP


                          AREA ||i.ADC_GetStatus||, CODE, READONLY, ALIGN=2

                  ADC_GetStatus PROC
;;;740      */
;;;741    uint32_t ADC_GetStatus ( void )
000000  4803              LDR      r0,|L40.16|
;;;742    {
;;;743    #if defined  (USE_MDR1986VE9x)|| defined (USE_MDR1901VC1T)		/* For Cortex M3 */
;;;744      return MDR_ADC->ADC1_STATUS + (MDR_ADC->ADC2_STATUS << 16);
000002  6a00              LDR      r0,[r0,#0x20]
000004  4902              LDR      r1,|L40.16|
000006  6a49              LDR      r1,[r1,#0x24]
000008  eb004001          ADD      r0,r0,r1,LSL #16
;;;745    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) 	/* For Cortex M1 */
;;;746      return MDR_ADC->ADC1_STATUS;
;;;747    #endif
;;;748    }
00000c  4770              BX       lr
;;;749    
                          ENDP

00000e  0000              DCW      0x0000
                  |L40.16|
                          DCD      0x40088000

                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=2

                  ADC_ITConfig PROC
;;;924      */
;;;925    void ADC_ITConfig(uint32_t ADC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;926    {
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;927      uint32_t tmpreg_ADC1_IE;
;;;928      uint32_t tmpreg_ADC_IT;
;;;929      uint32_t tmpreg_ADC2_IE;
;;;930    
;;;931      /* Check the parameters */
;;;932      assert_param(IS_ADC_CONFIG_IT(ADC_IT));
;;;933      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;934    
;;;935      tmpreg_ADC1_IE = MDR_ADC->ADC1_STATUS;
000006  4d0a              LDR      r5,|L41.48|
000008  6a2b              LDR      r3,[r5,#0x20]
;;;936      tmpreg_ADC_IT = ADC_IT << 2;
00000a  00a0              LSLS     r0,r4,#2
;;;937    
;;;938      /* Form new value */
;;;939      if (NewState != DISABLE)
00000c  b112              CBZ      r2,|L41.20|
;;;940      {
;;;941        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;942        tmpreg_ADC1_IE |= tmpreg_ADC_IT & 0xFFFF;
00000e  b285              UXTH     r5,r0
000010  432b              ORRS     r3,r3,r5
000012  e001              B        |L41.24|
                  |L41.20|
;;;943      }
;;;944      else
;;;945      {
;;;946        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;947        tmpreg_ADC1_IE &= ~(tmpreg_ADC_IT & 0xFFFF);
000014  b285              UXTH     r5,r0
000016  43ab              BICS     r3,r3,r5
                  |L41.24|
;;;948      }
;;;949    
;;;950      /* Configure ADCx_STATUS registers with new value */
;;;951      MDR_ADC->ADC1_STATUS = tmpreg_ADC1_IE;
000018  4d05              LDR      r5,|L41.48|
00001a  622b              STR      r3,[r5,#0x20]
;;;952    
;;;953    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;954    
;;;955      tmpreg_ADC2_IE = MDR_ADC->ADC2_STATUS;
00001c  6a69              LDR      r1,[r5,#0x24]
;;;956    
;;;957      /* Form new value */
;;;958      if (NewState != DISABLE)
00001e  b112              CBZ      r2,|L41.38|
;;;959      {
;;;960        /* Enable the ADC Interrupt requests by setting bits in the ADCx_STATUS registers */
;;;961        tmpreg_ADC2_IE |= tmpreg_ADC_IT >> 16;
000020  ea414110          ORR      r1,r1,r0,LSR #16
000024  e001              B        |L41.42|
                  |L41.38|
;;;962      }
;;;963      else
;;;964      {
;;;965        /* Disable the ADC Interrupt requests by clearing bits in the ADCx_STATUS registers */
;;;966        tmpreg_ADC2_IE &= ~(tmpreg_ADC_IT >> 16);
000026  ea214110          BIC      r1,r1,r0,LSR #16
                  |L41.42|
;;;967      }
;;;968      /* Configure ADCx_STATUS registers with new value */
;;;969      MDR_ADC->ADC2_STATUS = tmpreg_ADC2_IE;
00002a  4d01              LDR      r5,|L41.48|
00002c  6269              STR      r1,[r5,#0x24]
;;;970    #endif /* #if defined  (USE_MDR1986VE9x) */
;;;971    }
00002e  bd30              POP      {r4,r5,pc}
;;;972    
                          ENDP

                  |L41.48|
                          DCD      0x40088000

                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;76       */
;;;77     void ADC_Init(const ADC_InitTypeDef* ADC_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79       uint32_t tmpreg_CFG;
;;;80       uint32_t tmpreg_MSK;
;;;81     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;82       uint32_t tmpreg_TRIM;
;;;83     #endif
;;;84     
;;;85       /* Check the parameters */
;;;86     #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;87       assert_param(IS_ADC_SYNC_MODE(ADC_InitStruct->ADC_SynchronousMode));
;;;88     #endif
;;;89       assert_param(IS_ADC_START_DELAY_VALUE(ADC_InitStruct->ADC_StartDelay));
;;;90       assert_param(IS_ADC_TEMP_SENSOR_CONFIG(ADC_InitStruct->ADC_TempSensor));
;;;91       assert_param(IS_ADC_TEMP_SENSOR_AMP_CONFIG(ADC_InitStruct->ADC_TempSensorAmplifier));
;;;92       assert_param(IS_ADC_TEMP_SENSOR_CONVERSION_CONFIG(ADC_InitStruct->ADC_TempSensorConversion));
;;;93       assert_param(IS_ADC_VREF_CONVERSION_CONFIG(ADC_InitStruct->ADC_IntVRefConversion));
;;;94       assert_param(IS_ADC_VREF_TRIMMING_VALUE(ADC_InitStruct->ADC_IntVRefTrimming));
;;;95     #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;96       assert_param(IS_ADC_INT_VREF_AMPLIFIER(ADC_InitStruct->ADC_IntVRefAmplifier));
;;;97     #endif
;;;98     
;;;99       tmpreg_CFG = (ADC_InitStruct->ADC_StartDelay << ADC1_CFG_DELAY_ADC_Pos)
000002  7904              LDRB     r4,[r0,#4]
000004  6883              LDR      r3,[r0,#8]
000006  eb037304          ADD      r3,r3,r4,LSL #28
00000a  68c4              LDR      r4,[r0,#0xc]
00000c  4423              ADD      r3,r3,r4
00000e  6904              LDR      r4,[r0,#0x10]
000010  4423              ADD      r3,r3,r4
000012  6944              LDR      r4,[r0,#0x14]
000014  1919              ADDS     r1,r3,r4
;;;100                 + ADC_InitStruct->ADC_TempSensor
;;;101                 + ADC_InitStruct->ADC_TempSensorAmplifier
;;;102                 + ADC_InitStruct->ADC_TempSensorConversion
;;;103                 + ADC_InitStruct->ADC_IntVRefConversion;
;;;104    
;;;105    #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* For Cortex M3*/
;;;106      tmpreg_CFG += (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_CFG_TR_Pos)
000016  8b04              LDRH     r4,[r0,#0x18]
000018  6803              LDR      r3,[r0,#0]
00001a  eb035344          ADD      r3,r3,r4,LSL #21
00001e  4419              ADD      r1,r1,r3
;;;107                 +   ADC_InitStruct->ADC_SynchronousMode;
;;;108    #endif // #if defined(USE_MDR1986VE9x) /* For Cortex M3*/
;;;109    
;;;110      tmpreg_MSK = ADC1_CFG_DELAY_ADC_Msk
000020  4a04              LDR      r2,|L42.52|
;;;111                 | ADC1_CFG_TS_EN
;;;112                 | ADC1_CFG_TS_BUF_EN
;;;113                 | ADC1_CFG_SEL_TS
;;;114                 | ADC1_CFG_SEL_VREF;
;;;115    #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* For Cortex M3*/
;;;116      tmpreg_MSK |= ADC1_CFG_TR_Msk
000022  4b05              LDR      r3,|L42.56|
000024  431a              ORRS     r2,r2,r3
;;;117                 |  ADC1_CFG_SYNC_CONVER;
;;;118    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;119      tmpreg_TRIM = (ADC_InitStruct->ADC_IntVRefTrimming << ADC1_TRIM_TS_TRIM_Pos)
;;;120              | ADC_InitStruct->ADC_IntVRefAmplifier;
;;;121      MDR_ADC->ADC1_TRIM  = tmpreg_TRIM;
;;;122    #endif
;;;123    
;;;124      MDR_ADC->ADC1_CFG = (MDR_ADC->ADC1_CFG & ~tmpreg_MSK) + tmpreg_CFG;
000026  4b05              LDR      r3,|L42.60|
000028  681b              LDR      r3,[r3,#0]
00002a  4393              BICS     r3,r3,r2
00002c  440b              ADD      r3,r3,r1
00002e  4c03              LDR      r4,|L42.60|
000030  6023              STR      r3,[r4,#0]
;;;125    }
000032  bd10              POP      {r4,pc}
;;;126    
                          ENDP

                  |L42.52|
                          DCD      0xf01e0000
                  |L42.56|
                          DCD      0x01e10000
                  |L42.60|
                          DCD      0x40088000

                          AREA ||i.ADC_SetTrim||, CODE, READONLY, ALIGN=2

                  ADC_SetTrim PROC
;;;157      */
;;;158    void ADC_SetTrim(uint32_t Trim)
000000  4a04              LDR      r2,|L43.20|
;;;159    {
;;;160      uint32_t tmpreg;
;;;161    
;;;162      /* Check the parameters */
;;;163      assert_param(IS_ADC_VREF_TRIMMING_VALUE(Trim));
;;;164    
;;;165    #if defined(USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;166      tmpreg = MDR_ADC->ADC1_CFG & ~ADC1_CFG_TR_Msk;
000002  6812              LDR      r2,[r2,#0]
000004  f02271f0          BIC      r1,r2,#0x1e00000
;;;167      MDR_ADC->ADC1_CFG = tmpreg + (Trim << ADC1_CFG_TR_Pos);
000008  eb015240          ADD      r2,r1,r0,LSL #21
00000c  4b01              LDR      r3,|L43.20|
00000e  601a              STR      r2,[r3,#0]
;;;168    
;;;169    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
;;;170      tmpreg = MDR_ADC->ADC1_TRIM;
;;;171      tmpreg &= ~ADC1_TRIM_TS_TRIM_Msk;
;;;172      tmpreg |= Trim << ADC1_TRIM_TS_TRIM_Pos;
;;;173      MDR_ADC->ADC1_TRIM = tmpreg;
;;;174    #endif
;;;175    }
000010  4770              BX       lr
;;;176    
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40088000

                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;132      */
;;;133    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;134    {
;;;135    
;;;136    #if defined( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;137      ADC_InitStruct->ADC_SynchronousMode     = ADC_SyncMode_Independent;
000002  6001              STR      r1,[r0,#0]
;;;138    #endif
;;;139    
;;;140      ADC_InitStruct->ADC_StartDelay        	= 0;
000004  6041              STR      r1,[r0,#4]
;;;141      ADC_InitStruct->ADC_TempSensor        	= ADC_TEMP_SENSOR_Disable;
000006  6081              STR      r1,[r0,#8]
;;;142      ADC_InitStruct->ADC_TempSensorAmplifier   = ADC_TEMP_SENSOR_AMPLIFIER_Disable;
000008  60c1              STR      r1,[r0,#0xc]
;;;143      ADC_InitStruct->ADC_TempSensorConversion  = ADC_TEMP_SENSOR_CONVERSION_Disable;
00000a  6101              STR      r1,[r0,#0x10]
;;;144      ADC_InitStruct->ADC_IntVRefConversion     = ADC_VREF_CONVERSION_Disable;
00000c  6141              STR      r1,[r0,#0x14]
;;;145      ADC_InitStruct->ADC_IntVRefTrimming     	= 0;
00000e  6181              STR      r1,[r0,#0x18]
;;;146    
;;;147    #if defined ( USE_MDR1986VE3 ) || defined ( USE_MDR1986VE1T )
;;;148      ADC_InitStruct->ADC_IntVRefAmplifier    	= ADC_INT_VREF_AMPLIFIER_Disable;
;;;149    #endif
;;;150    }
000010  4770              BX       lr
;;;151    
                          ENDP


                          AREA ||i.ADCx_StructInit||, CODE, READONLY, ALIGN=1

                  ADCx_StructInit PROC
;;;301      */
;;;302    void ADCx_StructInit(ADCx_InitTypeDef* ADCx_InitStruct)
000000  2100              MOVS     r1,#0
;;;303    {
;;;304      ADCx_InitStruct->ADC_ClockSource      = ADC_CLOCK_SOURCE_CPU;
000002  6001              STR      r1,[r0,#0]
;;;305      ADCx_InitStruct->ADC_SamplingMode     = ADC_SAMPLING_MODE_SINGLE_CONV;
000004  6041              STR      r1,[r0,#4]
;;;306      ADCx_InitStruct->ADC_ChannelSwitching = ADC_CH_SWITCHING_Disable;
000006  6081              STR      r1,[r0,#8]
;;;307      ADCx_InitStruct->ADC_ChannelNumber    = ADC_CH_ADC0;
000008  60c1              STR      r1,[r0,#0xc]
;;;308      ADCx_InitStruct->ADC_Channels         = 0;
00000a  6101              STR      r1,[r0,#0x10]
;;;309      ADCx_InitStruct->ADC_LevelControl     = ADC_LEVEL_CONTROL_Disable;
00000c  6141              STR      r1,[r0,#0x14]
;;;310      ADCx_InitStruct->ADC_LowLevel         = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;311      ADCx_InitStruct->ADC_HighLevel        = 0;
000010  8341              STRH     r1,[r0,#0x1a]
;;;312      ADCx_InitStruct->ADC_VRefSource       = ADC_VREF_SOURCE_INTERNAL;
000012  61c1              STR      r1,[r0,#0x1c]
;;;313      ADCx_InitStruct->ADC_IntVRefSource    = ADC_INT_VREF_SOURCE_INEXACT;
000014  6201              STR      r1,[r0,#0x20]
;;;314      ADCx_InitStruct->ADC_Prescaler        = ADC_CLK_div_None;
000016  6241              STR      r1,[r0,#0x24]
;;;315      ADCx_InitStruct->ADC_DelayGo          = 0;
000018  6281              STR      r1,[r0,#0x28]
;;;316    }
00001a  4770              BX       lr
;;;317    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH|
#line 462
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_adc_c_e11a2ea2____RRX|
#line 649
|__asm___15_MDR32F9Qx_adc_c_e11a2ea2____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
