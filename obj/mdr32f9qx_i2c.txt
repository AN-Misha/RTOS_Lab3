; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_i2c.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_i2c.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_i2c.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_i2c.c]
                          THUMB

                          AREA ||i.I2C_CheckEvent||, CODE, READONLY, ALIGN=1

                  I2C_CheckEvent PROC
;;;302      */
;;;303    ErrorStatus I2C_CheckEvent(uint32_t Event)
000000  b530              PUSH     {r4,r5,lr}
;;;304    {
000002  4604              MOV      r4,r0
;;;305      ErrorStatus errstatus;
;;;306    
;;;307      assert_param(IS_I2C_FLAGS(Event));
;;;308    
;;;309      if ((I2C_GetLastEvent() & Event) == Event)
000004  f7fffffe          BL       I2C_GetLastEvent
000008  4020              ANDS     r0,r0,r4
00000a  42a0              CMP      r0,r4
00000c  d101              BNE      |L1.18|
;;;310      {
;;;311        errstatus = SUCCESS;
00000e  2501              MOVS     r5,#1
000010  e000              B        |L1.20|
                  |L1.18|
;;;312      }
;;;313      else
;;;314      {
;;;315        errstatus = ERROR;
000012  2500              MOVS     r5,#0
                  |L1.20|
;;;316      }
;;;317    
;;;318      return errstatus;
000014  4628              MOV      r0,r5
;;;319    }
000016  bd30              POP      {r4,r5,pc}
;;;320    
                          ENDP


                          AREA ||i.I2C_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  I2C_ClearITPendingBit PROC
;;;191      */
;;;192    void I2C_ClearITPendingBit(void)
000000  4802              LDR      r0,|L2.12|
;;;193    {
;;;194      MDR_I2C_TypeDef *I2Cx;
;;;195    
;;;196      I2Cx = MDR_I2C;
;;;197    
;;;198      I2Cx->CMD |= I2C_CMD_CLRINT;
000002  6981              LDR      r1,[r0,#0x18]
000004  f0410101          ORR      r1,r1,#1
000008  6181              STR      r1,[r0,#0x18]
;;;199    }
00000a  4770              BX       lr
;;;200    
                          ENDP

                  |L2.12|
                          DCD      0x40050000

                          AREA ||i.I2C_Cmd||, CODE, READONLY, ALIGN=2

                  I2C_Cmd PROC
;;;100      */
;;;101    void I2C_Cmd(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;102    {
;;;103      MDR_I2C_TypeDef *I2Cx;
;;;104      uint32_t tmpreg_CTR;
;;;105    
;;;106      /* Check the parameters */
;;;107      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;108    
;;;109      I2Cx = MDR_I2C;
000002  4a05              LDR      r2,|L3.24|
;;;110    
;;;111      tmpreg_CTR = I2Cx->CTR;
000004  6890              LDR      r0,[r2,#8]
;;;112    
;;;113      /* Form new value */
;;;114      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L3.14|
;;;115      {
;;;116        /* Enable I2C by setting the EN_I2C bit in the CTR register */
;;;117        tmpreg_CTR |= I2C_CTR_EN_I2C;
000008  f0400080          ORR      r0,r0,#0x80
00000c  e001              B        |L3.18|
                  |L3.14|
;;;118      }
;;;119      else
;;;120      {
;;;121        /* Disable I2C by resetting the EN_I2C bit in the CTR register */
;;;122        tmpreg_CTR &= ~I2C_CTR_EN_I2C;
00000e  f0200080          BIC      r0,r0,#0x80
                  |L3.18|
;;;123      }
;;;124    
;;;125      /* Configure CTR register with new value */
;;;126      I2Cx->CTR = tmpreg_CTR;
000012  6090              STR      r0,[r2,#8]
;;;127    }
000014  4770              BX       lr
;;;128    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      0x40050000

                          AREA ||i.I2C_DeInit||, CODE, READONLY, ALIGN=2

                  I2C_DeInit PROC
;;;29       */
;;;30     void I2C_DeInit(void)
000000  4804              LDR      r0,|L4.20|
;;;31     {
;;;32       MDR_I2C_TypeDef *I2Cx;
;;;33     
;;;34       I2Cx = MDR_I2C;
;;;35     
;;;36       I2Cx->CTR = 0;
000002  2100              MOVS     r1,#0
000004  6081              STR      r1,[r0,#8]
;;;37       I2Cx->STA = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;38       I2Cx->CMD = I2C_CMD_CLRINT;
000008  2101              MOVS     r1,#1
00000a  6181              STR      r1,[r0,#0x18]
;;;39       I2Cx->PRL = 0;
00000c  2100              MOVS     r1,#0
00000e  6001              STR      r1,[r0,#0]
;;;40       I2Cx->PRH = 0;
000010  6041              STR      r1,[r0,#4]
;;;41     }
000012  4770              BX       lr
;;;42     
                          ENDP

                  |L4.20|
                          DCD      0x40050000

                          AREA ||i.I2C_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetFlagStatus PROC
;;;367      */
;;;368    FlagStatus I2C_GetFlagStatus(uint32_t Flag)
000000  b530              PUSH     {r4,r5,lr}
;;;369    {
000002  4605              MOV      r5,r0
;;;370      FlagStatus bitstatus;
;;;371    
;;;372      assert_param(IS_I2C_FLAG(Flag));
;;;373    
;;;374      if ((I2C_GetLastEvent() & Flag) != 0)
000004  f7fffffe          BL       I2C_GetLastEvent
000008  4028              ANDS     r0,r0,r5
00000a  b108              CBZ      r0,|L5.16|
;;;375      {
;;;376        bitstatus = SET;
00000c  2401              MOVS     r4,#1
00000e  e000              B        |L5.18|
                  |L5.16|
;;;377      }
;;;378      else
;;;379      {
;;;380        bitstatus = RESET;
000010  2400              MOVS     r4,#0
                  |L5.18|
;;;381      }
;;;382    
;;;383      return bitstatus;
000012  4620              MOV      r0,r4
;;;384    }
000014  bd30              POP      {r4,r5,pc}
;;;385    
                          ENDP


                          AREA ||i.I2C_GetITStatus||, CODE, READONLY, ALIGN=2

                  I2C_GetITStatus PROC
;;;167      */
;;;168    ITStatus I2C_GetITStatus(void)
000000  4904              LDR      r1,|L6.20|
;;;169    {
;;;170      MDR_I2C_TypeDef *I2Cx;
;;;171      ITStatus bitstatus;
;;;172    
;;;173      I2Cx = MDR_I2C;
;;;174    
;;;175      if ((I2Cx->STA & I2C_STA_INT) == I2C_STA_INT)
000002  690a              LDR      r2,[r1,#0x10]
000004  f0020201          AND      r2,r2,#1
000008  b10a              CBZ      r2,|L6.14|
;;;176      {
;;;177        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L6.16|
                  |L6.14|
;;;178      }
;;;179      else
;;;180      {
;;;181        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L6.16|
;;;182      }
;;;183    
;;;184      return bitstatus;
;;;185    }
000010  4770              BX       lr
;;;186    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40050000

                          AREA ||i.I2C_GetLastEvent||, CODE, READONLY, ALIGN=2

                  I2C_GetLastEvent PROC
;;;328      */
;;;329    uint32_t I2C_GetLastEvent(void)
000000  4904              LDR      r1,|L7.20|
;;;330    {
;;;331      MDR_I2C_TypeDef *I2Cx;
;;;332      uint32_t event;
;;;333    
;;;334      I2Cx = MDR_I2C;
;;;335    
;;;336      event = I2Cx->CMD | (I2Cx->STA << 8);
000002  698a              LDR      r2,[r1,#0x18]
000004  690b              LDR      r3,[r1,#0x10]
000006  ea422003          ORR      r0,r2,r3,LSL #8
;;;337      event |= ~event << 16;
00000a  43c2              MVNS     r2,r0
00000c  ea404002          ORR      r0,r0,r2,LSL #16
;;;338    
;;;339      return event;
;;;340    }
000010  4770              BX       lr
;;;341    
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40050000

                          AREA ||i.I2C_GetReceivedData||, CODE, READONLY, ALIGN=2

                  I2C_GetReceivedData PROC
;;;278      */
;;;279    uint8_t I2C_GetReceivedData(void)
000000  4901              LDR      r1,|L8.8|
;;;280    {
;;;281      MDR_I2C_TypeDef *I2Cx;
;;;282    
;;;283      I2Cx = MDR_I2C;
;;;284    
;;;285      return I2Cx->RXD;
000002  68c8              LDR      r0,[r1,#0xc]
000004  b2c0              UXTB     r0,r0
;;;286    }
000006  4770              BX       lr
;;;287    
                          ENDP

                  |L8.8|
                          DCD      0x40050000

                          AREA ||i.I2C_ITConfig||, CODE, READONLY, ALIGN=2

                  I2C_ITConfig PROC
;;;134      */
;;;135    void I2C_ITConfig(FunctionalState NewState)
000000  4601              MOV      r1,r0
;;;136    {
;;;137      MDR_I2C_TypeDef *I2Cx;
;;;138      uint32_t tmpreg_CTR;
;;;139    
;;;140      /* Check the parameters */
;;;141      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;142    
;;;143      I2Cx = MDR_I2C;
000002  4a05              LDR      r2,|L9.24|
;;;144    
;;;145      tmpreg_CTR = I2Cx->CTR;
000004  6890              LDR      r0,[r2,#8]
;;;146    
;;;147      /* Form new value */
;;;148      if (NewState != DISABLE)
000006  b111              CBZ      r1,|L9.14|
;;;149      {
;;;150        /* Enable the I2C interrupts by setting the EN_INT bit in the CTR register */
;;;151        tmpreg_CTR |= I2C_CTR_EN_INT;
000008  f0400040          ORR      r0,r0,#0x40
00000c  e001              B        |L9.18|
                  |L9.14|
;;;152      }
;;;153      else
;;;154      {
;;;155        /* Disable the I2C interrupts by resetting the EN_INT bit in the CTR register */
;;;156        tmpreg_CTR &= ~I2C_CTR_EN_INT;
00000e  f0200040          BIC      r0,r0,#0x40
                  |L9.18|
;;;157      }
;;;158    
;;;159      /* Configure CTR register with new value */
;;;160      I2Cx->CTR = tmpreg_CTR;
000012  6090              STR      r0,[r2,#8]
;;;161    }
000014  4770              BX       lr
;;;162    
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x40050000

                          AREA ||i.I2C_Init||, CODE, READONLY, ALIGN=2

                  I2C_Init PROC
;;;49       */
;;;50     void I2C_Init(const I2C_InitTypeDef* I2C_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;51     {
000002  4601              MOV      r1,r0
;;;52       MDR_I2C_TypeDef *I2Cx;
;;;53       uint32_t tmpreg_CTR;
;;;54       uint32_t tmpreg_PR;
;;;55     
;;;56       /* Check the parameters */
;;;57       assert_param(IS_I2C_SPEED(I2C_InitStruct->I2C_Speed));
;;;58       assert_param(IS_I2C_CLKDIV(I2C_InitStruct->I2C_ClkDiv));
;;;59     
;;;60       I2Cx = MDR_I2C;
000004  4808              LDR      r0,|L10.40|
;;;61     
;;;62       /* Form new values */
;;;63       tmpreg_CTR = I2Cx->CTR;
000006  6882              LDR      r2,[r0,#8]
;;;64     
;;;65       if ((I2C_InitStruct->I2C_Speed & I2C_SPEED_Msk) != I2C_SPEED_UP_TO_400KHz)
000008  790c              LDRB     r4,[r1,#4]
00000a  f0040420          AND      r4,r4,#0x20
00000e  b114              CBZ      r4,|L10.22|
;;;66       {
;;;67         tmpreg_CTR |= I2C_CTR_S_I2C;
000010  f0420220          ORR      r2,r2,#0x20
000014  e001              B        |L10.26|
                  |L10.22|
;;;68       }
;;;69       else
;;;70       {
;;;71         tmpreg_CTR &= ~I2C_CTR_S_I2C;
000016  f0220220          BIC      r2,r2,#0x20
                  |L10.26|
;;;72       }
;;;73     
;;;74       /* Configure I2C registers with new values */
;;;75       I2Cx->CTR = tmpreg_CTR;
00001a  6082              STR      r2,[r0,#8]
;;;76     
;;;77       tmpreg_PR = I2C_InitStruct->I2C_ClkDiv;
00001c  680b              LDR      r3,[r1,#0]
;;;78       I2Cx->PRL = tmpreg_PR;
00001e  6003              STR      r3,[r0,#0]
;;;79       I2Cx->PRH = tmpreg_PR >> 8;
000020  0a1c              LSRS     r4,r3,#8
000022  6044              STR      r4,[r0,#4]
;;;80     }
000024  bd10              POP      {r4,pc}
;;;81     
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x40050000

                          AREA ||i.I2C_Send7bitAddress||, CODE, READONLY, ALIGN=2

                  I2C_Send7bitAddress PROC
;;;212      */
;;;213    void I2C_Send7bitAddress(uint8_t Address, uint32_t Direction)
000000  4a03              LDR      r2,|L11.16|
;;;214    {
;;;215      MDR_I2C_TypeDef *I2Cx;
;;;216    
;;;217      assert_param(IS_I2C_DIRECTION(Direction));
;;;218    
;;;219      I2Cx = MDR_I2C;
;;;220    
;;;221      I2Cx->TXD = (Address & ~I2C_Direction_Msk) | Direction;
000002  f0200301          BIC      r3,r0,#1
000006  430b              ORRS     r3,r3,r1
000008  6153              STR      r3,[r2,#0x14]
;;;222      I2Cx->CMD = I2C_CMD_START | I2C_CMD_WR;
00000a  2390              MOVS     r3,#0x90
00000c  6193              STR      r3,[r2,#0x18]
;;;223    }
00000e  4770              BX       lr
;;;224    
                          ENDP

                  |L11.16|
                          DCD      0x40050000

                          AREA ||i.I2C_SendByte||, CODE, READONLY, ALIGN=2

                  I2C_SendByte PROC
;;;229      */
;;;230    void I2C_SendByte(uint8_t ByteToSend)
000000  4601              MOV      r1,r0
;;;231    {
;;;232      MDR_I2C_TypeDef *I2Cx;
;;;233    
;;;234      I2Cx = MDR_I2C;
000002  4802              LDR      r0,|L12.12|
;;;235    
;;;236      I2Cx->TXD = ByteToSend;
000004  6141              STR      r1,[r0,#0x14]
;;;237      I2Cx->CMD = I2C_CMD_WR;
000006  2210              MOVS     r2,#0x10
000008  6182              STR      r2,[r0,#0x18]
;;;238    }
00000a  4770              BX       lr
;;;239    
                          ENDP

                  |L12.12|
                          DCD      0x40050000

                          AREA ||i.I2C_SendSTOP||, CODE, READONLY, ALIGN=2

                  I2C_SendSTOP PROC
;;;244      */
;;;245    void I2C_SendSTOP(void)
000000  4801              LDR      r0,|L13.8|
;;;246    {
;;;247      MDR_I2C_TypeDef *I2Cx;
;;;248    
;;;249      I2Cx = MDR_I2C;
;;;250    
;;;251      I2Cx->CMD = I2C_CMD_STOP;
000002  2140              MOVS     r1,#0x40
000004  6181              STR      r1,[r0,#0x18]
;;;252    }
000006  4770              BX       lr
;;;253    
                          ENDP

                  |L13.8|
                          DCD      0x40050000

                          AREA ||i.I2C_StartReceiveData||, CODE, READONLY, ALIGN=2

                  I2C_StartReceiveData PROC
;;;262      */
;;;263    void I2C_StartReceiveData(uint32_t Acknowlage)
000000  4902              LDR      r1,|L14.12|
;;;264    {
;;;265      MDR_I2C_TypeDef *I2Cx;
;;;266    
;;;267      assert_param(IS_I2C_SEND_ACKNOWLAGE(Acknowlage));
;;;268    
;;;269      I2Cx = MDR_I2C;
;;;270    
;;;271      I2Cx->CMD = I2C_CMD_RD | Acknowlage;
000002  f0400220          ORR      r2,r0,#0x20
000006  618a              STR      r2,[r1,#0x18]
;;;272    }
000008  4770              BX       lr
;;;273    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x40050000

                          AREA ||i.I2C_StructInit||, CODE, READONLY, ALIGN=1

                  I2C_StructInit PROC
;;;87       */
;;;88     void I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct)
000000  2100              MOVS     r1,#0
;;;89     {
;;;90       /* Reset I2C initialization structure parameters values */
;;;91       I2C_InitStruct->I2C_Speed  = I2C_SPEED_UP_TO_400KHz;
000002  6041              STR      r1,[r0,#4]
;;;92       I2C_InitStruct->I2C_ClkDiv = 1;
000004  2101              MOVS     r1,#1
000006  6001              STR      r1,[r0,#0]
;;;93     }
000008  4770              BX       lr
;;;94     
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_i2c_c_7174d409____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_i2c_c_7174d409____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_i2c_c_7174d409____REVSH|
#line 482
|__asm___15_MDR32F9Qx_i2c_c_7174d409____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_i2c_c_7174d409____RRX|
#line 669
|__asm___15_MDR32F9Qx_i2c_c_7174d409____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
