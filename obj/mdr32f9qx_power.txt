; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_power.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_power.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_power.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_power.c]
                          THUMB

                          AREA ||i.POWER_ClearFlag||, CODE, READONLY, ALIGN=2

                  POWER_ClearFlag PROC
;;;302      */
;;;303    void POWER_ClearFlag(uint32_t POWER_FLAG)
000000  4902              LDR      r1,|L1.12|
;;;304    {
;;;305      /* Check the parameters */
;;;306      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;307    
;;;308      MDR_POWER->PVDCS &= (uint32_t) ~POWER_FLAG;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L1.12|
000008  6011              STR      r1,[r2,#0]
;;;309    }
00000a  4770              BX       lr
;;;310    
                          ENDP

                  |L1.12|
                          DCD      0x40058000

                          AREA ||i.POWER_DUccMode||, CODE, READONLY, ALIGN=2

                  POWER_DUccMode PROC
;;;103      */
;;;104    void POWER_DUccMode(uint32_t DUccMode)
000000  4a04              LDR      r2,|L2.20|
;;;105    {
;;;106      uint32_t tmpreg;
;;;107      /* Check the parameters */
;;;108      assert_param(IS_POWER_DUCC_MODE(DUccMode));
;;;109      /* Clear POWER_REG0E[5:0] bits */
;;;110      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUcc_Mask);
000002  6b92              LDR      r2,[r2,#0x38]
000004  f022013f          BIC      r1,r2,#0x3f
;;;111      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;112      tmpreg |= DUcc_Mask & DUccMode;
000008  f000023f          AND      r2,r0,#0x3f
00000c  4311              ORRS     r1,r1,r2
;;;113      MDR_BKP -> REG_0E = tmpreg;
00000e  4a01              LDR      r2,|L2.20|
000010  6391              STR      r1,[r2,#0x38]
;;;114    }
000012  4770              BX       lr
;;;115    
                          ENDP

                  |L2.20|
                          DCD      0x400d8000

                          AREA ||i.POWER_DUccStandby||, CODE, READONLY, ALIGN=2

                  POWER_DUccStandby PROC
;;;146      */
;;;147    void POWER_DUccStandby ( void )
000000  2001              MOVS     r0,#1
;;;148    {
;;;149    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;150    *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000002  4901              LDR      r1,|L3.8|
000004  6008              STR      r0,[r1,#0]
;;;151    #elif defined (USE_MDR1986VE3)
;;;152    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;153    #endif
;;;154    
;;;155    }
000006  4770              BX       lr
;;;156    
                          ENDP

                  |L3.8|
                          DCD      0x43b007f8

                          AREA ||i.POWER_DUccTrim||, CODE, READONLY, ALIGN=2

                  POWER_DUccTrim PROC
;;;129      */
;;;130    void POWER_DUccTrim(uint32_t DUccTrim)
000000  4a04              LDR      r2,|L4.20|
;;;131    {
;;;132      uint32_t tmpreg;
;;;133      /* Check the parameters */
;;;134      assert_param(IS_POWER_DUCC_TRIM(DUccTrim));
;;;135      /* Clear POWER_REG0E[5:0] bits */
;;;136      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUccTrim_Mask);
000002  6b92              LDR      r2,[r2,#0x38]
000004  f42261e0          BIC      r1,r2,#0x700
;;;137      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;138      tmpreg |= DUccTrim_Mask & DUccTrim;
000008  f40062e0          AND      r2,r0,#0x700
00000c  4311              ORRS     r1,r1,r2
;;;139      MDR_BKP -> REG_0E = tmpreg;
00000e  4a01              LDR      r2,|L4.20|
000010  6391              STR      r1,[r2,#0x38]
;;;140    }
000012  4770              BX       lr
;;;141    
                          ENDP

                  |L4.20|
                          DCD      0x400d8000

                          AREA ||i.POWER_DeInit||, CODE, READONLY, ALIGN=2

                  POWER_DeInit PROC
;;;84       */
;;;85     void POWER_DeInit(void)
000000  2000              MOVS     r0,#0
;;;86     {
;;;87       MDR_POWER -> PVDCS = (uint32_t) 0x00000000;
000002  4901              LDR      r1,|L5.8|
000004  6008              STR      r0,[r1,#0]
;;;88     }
000006  4770              BX       lr
;;;89     
                          ENDP

                  |L5.8|
                          DCD      0x40058000

                          AREA ||i.POWER_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  POWER_EnterSTANDBYMode PROC
;;;427      */
;;;428    void POWER_EnterSTANDBYMode ( void )
000000  2001              MOVS     r0,#1
;;;429    {
;;;430    	/* Select STANDBY mode */
;;;431    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;432    	*(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000002  4905              LDR      r1,|L6.24|
000004  6008              STR      r0,[r1,#0]
;;;433    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;434    	*(__IO uint32_t *) SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000006  4905              LDR      r1,|L6.28|
000008  6808              LDR      r0,[r1,#0]
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410104          ORR      r1,r1,#4
000010  6001              STR      r1,[r0,#0]
;;;435    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;436    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;437    #endif
;;;438    	/* Request Wait For Interrupt */
;;;439    	__WFI();
000012  bf30              WFI      
;;;440    }
000014  4770              BX       lr
;;;441    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x43b007f8
                  |L6.28|
                          DCD      0xe000ed10

                          AREA ||i.POWER_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  POWER_EnterSTOPMode PROC
;;;375      */
;;;376    void POWER_EnterSTOPMode(FunctionalState POWER_Regulator_state, uint8_t POWER_STOPentry)
000000  b908              CBNZ     r0,|L7.6|
;;;377    {
;;;378      /* Check the parameters */
;;;379      assert_param(IS_FUNCTIONAL_STATE(POWER_Regulator_state));
;;;380      assert_param(IS_POWER_STOP_ENTRY(POWER_STOPentry));
;;;381    
;;;382      /* Set UDcc stanby status */
;;;383    
;;;384       *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) (!POWER_Regulator_state);
000002  2201              MOVS     r2,#1
000004  e000              B        |L7.8|
                  |L7.6|
000006  2200              MOVS     r2,#0
                  |L7.8|
000008  4b0e              LDR      r3,|L7.68|
00000a  601a              STR      r2,[r3,#0]
;;;385       /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;386       *(__IO uint32_t *) SCB -> SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000c  4b0e              LDR      r3,|L7.72|
00000e  681a              LDR      r2,[r3,#0]
000010  6813              LDR      r3,[r2,#0]
000012  f0430304          ORR      r3,r3,#4
000016  6013              STR      r3,[r2,#0]
;;;387    
;;;388       if(POWER_Regulator_state == ENABLE){
000018  2801              CMP      r0,#1
00001a  d106              BNE      |L7.42|
;;;389    	   MDR_BKP->REG_0F &= ~BKP_REG_0F_STANDBY;
00001c  4a0b              LDR      r2,|L7.76|
00001e  6bd2              LDR      r2,[r2,#0x3c]
000020  f0224280          BIC      r2,r2,#0x40000000
000024  4b09              LDR      r3,|L7.76|
000026  63da              STR      r2,[r3,#0x3c]
000028  e005              B        |L7.54|
                  |L7.42|
;;;390       }
;;;391       else{
;;;392    	   MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
00002a  4a08              LDR      r2,|L7.76|
00002c  6bd2              LDR      r2,[r2,#0x3c]
00002e  f0424280          ORR      r2,r2,#0x40000000
000032  4b06              LDR      r3,|L7.76|
000034  63da              STR      r2,[r3,#0x3c]
                  |L7.54|
;;;393       }
;;;394      /* Select STOP mode entry --------------------------------------------------*/
;;;395      if(POWER_STOPentry == POWER_STOPentry_WFI)
000036  2901              CMP      r1,#1
000038  d101              BNE      |L7.62|
;;;396      {
;;;397        /* Request Wait For Interrupt */
;;;398        __WFI();
00003a  bf30              WFI      
00003c  e000              B        |L7.64|
                  |L7.62|
;;;399      }
;;;400      else
;;;401      {
;;;402        /* Request Wait For Event */
;;;403        __WFE();
00003e  bf20              WFE      
                  |L7.64|
;;;404      }
;;;405    }
000040  4770              BX       lr
;;;406    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x43b007f8
                  |L7.72|
                          DCD      0xe000ed10
                  |L7.76|
                          DCD      0x400d8000

                          AREA ||i.POWER_FlagPORstatus||, CODE, READONLY, ALIGN=2

                  POWER_FlagPORstatus PROC
;;;229      */
;;;230    ErrorStatus POWER_FlagPORstatus(void)
000000  2000              MOVS     r0,#0
;;;231    {
;;;232      ErrorStatus state = ERROR;
;;;233    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;234      if (*(__IO uint32_t *) BKP_FPOR_BB == 0)
000002  4902              LDR      r1,|L8.12|
000004  6809              LDR      r1,[r1,#0]
000006  b901              CBNZ     r1,|L8.10|
;;;235      {
;;;236        state = SUCCESS;
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;237      }
;;;238    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;239      if (( MDR_BKP->REG_0E & BKP_REG_0E_FPOR ) == BKP_REG_0E_FPOR) {
;;;240    	  state = SUCCESS;
;;;241      }
;;;242    #endif
;;;243      return state;
;;;244    }
00000a  4770              BX       lr
;;;245    
                          ENDP

                  |L8.12|
                          DCD      0x43b0072c

                          AREA ||i.POWER_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  POWER_GetFlagStatus PROC
;;;276      */
;;;277    FlagStatus POWER_GetFlagStatus(uint32_t POWER_FLAG)
000000  4601              MOV      r1,r0
;;;278    {
;;;279      FlagStatus status;
;;;280      /* Check the parameters */
;;;281      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;282    
;;;283      if ((MDR_POWER->PVDCS & POWER_FLAG) != (uint32_t)RESET)
000002  4a04              LDR      r2,|L9.20|
000004  6812              LDR      r2,[r2,#0]
000006  400a              ANDS     r2,r2,r1
000008  b10a              CBZ      r2,|L9.14|
;;;284      {
;;;285        status = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L9.16|
                  |L9.14|
;;;286      }
;;;287      else
;;;288      {
;;;289        status = RESET;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;290      }
;;;291      /* Return the flag status */
;;;292      return status;
;;;293    }
000010  4770              BX       lr
;;;294    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40058000

                          AREA ||i.POWER_PVBDlevelConfig||, CODE, READONLY, ALIGN=2

                  POWER_PVBDlevelConfig PROC
;;;196      */
;;;197    void POWER_PVBDlevelConfig(uint32_t POWER_PVBDlevel)
000000  4601              MOV      r1,r0
;;;198    {
;;;199      uint32_t tmpreg;
;;;200      /* Check the parameters */
;;;201      assert_param(IS_POWER_PVBD_LEVEL(POWER_PVBDlevel));
;;;202      tmpreg = MDR_POWER->PVDCS;
000002  4a05              LDR      r2,|L10.24|
000004  6810              LDR      r0,[r2,#0]
;;;203      /* Clear PBLS[2:1] bits */
;;;204      tmpreg &= (uint32_t) ~POWER_PVDCS_PBLS_Msk;
000006  f0200006          BIC      r0,r0,#6
;;;205      /* Set PBLS[2:1] bits according to POWER_PVBDlevel value */
;;;206      tmpreg |= (POWER_PVBDlevel & POWER_PVDCS_PBLS_Msk);
00000a  f0010206          AND      r2,r1,#6
00000e  4310              ORRS     r0,r0,r2
;;;207      /* Store the new value */
;;;208      MDR_POWER->PVDCS = tmpreg;
000010  4a01              LDR      r2,|L10.24|
000012  6010              STR      r0,[r2,#0]
;;;209    }
000014  4770              BX       lr
;;;210    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40058000

                          AREA ||i.POWER_PVD_INVconfig||, CODE, READONLY, ALIGN=2

                  POWER_PVD_INVconfig PROC
;;;347      */
;;;348    void POWER_PVD_INVconfig(uint32_t POWER_INV, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_POWER_PVD_INV(POWER_INV));
;;;352      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;353    
;;;354      if (NewState != DISABLE)
;;;355      {
;;;356        MDR_POWER->PVDCS |= POWER_INV;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;357      }
;;;358      else
;;;359      {
;;;360        MDR_POWER->PVDCS &= (uint32_t)~POWER_INV;
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;361      }
;;;362    }
000018  4770              BX       lr
;;;363    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40058000

                          AREA ||i.POWER_PVD_ITconfig||, CODE, READONLY, ALIGN=2

                  POWER_PVD_ITconfig PROC
;;;320      */
;;;321    void POWER_PVD_ITconfig(uint32_t POWER_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L12.14|
;;;322    {
;;;323      /* Check the parameters */
;;;324      assert_param(IS_POWER_PVD_IT(POWER_IT));
;;;325      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;326    
;;;327      if (NewState != DISABLE)
;;;328      {
;;;329        MDR_POWER->PVDCS |= POWER_IT;
000002  4a06              LDR      r2,|L12.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L12.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;330      }
;;;331      else
;;;332      {
;;;333        MDR_POWER->PVDCS &= (uint32_t)~POWER_IT;
00000e  4a03              LDR      r2,|L12.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L12.28|
000016  601a              STR      r2,[r3,#0]
                  |L12.24|
;;;334      }
;;;335    }
000018  4770              BX       lr
;;;336    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40058000

                          AREA ||i.POWER_PVDenable||, CODE, READONLY, ALIGN=2

                  POWER_PVDenable PROC
;;;251      */
;;;252    void POWER_PVDenable ( FunctionalState NewState )
000000  4901              LDR      r1,|L13.8|
;;;253    {
;;;254    	/* Check the parameters */
;;;255    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;256    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;257    	*(__IO uint32_t *) POWER_PVDEN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;258    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;259    	if(NewState != DISABLE){
;;;260    		MDR_POWER->PVDCS |= POWER_PVDCS_PVDEN;
;;;261    	}
;;;262    	else {
;;;263    		MDR_POWER->PVDCS &= ~POWER_PVDCS_PVDEN;
;;;264    	}
;;;265    #endif
;;;266    }
000004  4770              BX       lr
;;;267    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x42b00000

                          AREA ||i.POWER_PVDlevelConfig||, CODE, READONLY, ALIGN=2

                  POWER_PVDlevelConfig PROC
;;;171      */
;;;172    void POWER_PVDlevelConfig(uint32_t POWER_PVDlevel)
000000  4601              MOV      r1,r0
;;;173    {
;;;174      uint32_t tmpreg;
;;;175      /* Check the parameters */
;;;176      assert_param(IS_POWER_PVD_LEVEL(POWER_PVDlevel));
;;;177      tmpreg = MDR_POWER->PVDCS;
000002  4a05              LDR      r2,|L14.24|
000004  6810              LDR      r0,[r2,#0]
;;;178      /* Clear PLS[5:3] bits */
;;;179      tmpreg &= (uint32_t) ~POWER_PVDCS_PLS_Msk;
000006  f0200038          BIC      r0,r0,#0x38
;;;180      /* Set PLS[5:3] bits according to POWER_PVDlevel value */
;;;181      tmpreg |= (POWER_PVDlevel & POWER_PVDCS_PLS_Msk);
00000a  f0010238          AND      r2,r1,#0x38
00000e  4310              ORRS     r0,r0,r2
;;;182      /* Store the new value */
;;;183      MDR_POWER->PVDCS = tmpreg;
000010  4a01              LDR      r2,|L14.24|
000012  6010              STR      r0,[r2,#0]
;;;184    }
000014  4770              BX       lr
;;;185    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40058000

                          AREA ||i.POWER_SetFlagPOR||, CODE, READONLY, ALIGN=2

                  POWER_SetFlagPOR PROC
;;;215      */
;;;216    void POWER_SetFlagPOR ( void )
000000  2001              MOVS     r0,#1
;;;217    {
;;;218    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;219    	*(__IO uint32_t *) BKP_FPOR_BB = (uint32_t) 0x01;
000002  4901              LDR      r1,|L15.8|
000004  6008              STR      r0,[r1,#0]
;;;220    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;221    	MDR_BKP->REG_0E |= BKP_REG_0E_FPOR;
;;;222    #endif
;;;223    }
000006  4770              BX       lr
;;;224    
                          ENDP

                  |L15.8|
                          DCD      0x43b0072c

;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_power.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH|
#line 482
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____RRX|
#line 669
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
