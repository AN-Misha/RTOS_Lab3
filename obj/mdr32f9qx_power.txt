; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_power.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_power.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_power.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_power.c]
                          THUMB

                          AREA ||i.POWER_ClearFlag||, CODE, READONLY, ALIGN=2

                  POWER_ClearFlag PROC
;;;321      */
;;;322    void POWER_ClearFlag(uint32_t POWER_FLAG)
000000  4902              LDR      r1,|L1.12|
;;;323    {
;;;324      /* Check the parameters */
;;;325      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;326    
;;;327      MDR_POWER->PVDCS &= (uint32_t) ~POWER_FLAG;
000002  6809              LDR      r1,[r1,#0]
000004  4381              BICS     r1,r1,r0
000006  4a01              LDR      r2,|L1.12|
000008  6011              STR      r1,[r2,#0]
;;;328    }
00000a  4770              BX       lr
;;;329    
                          ENDP

                  |L1.12|
                          DCD      0x40058000

                          AREA ||i.POWER_DUccMode||, CODE, READONLY, ALIGN=2

                  POWER_DUccMode PROC
;;;122      */
;;;123    void POWER_DUccMode(uint32_t DUccMode)
000000  4a04              LDR      r2,|L2.20|
;;;124    {
;;;125      uint32_t tmpreg;
;;;126      /* Check the parameters */
;;;127      assert_param(IS_POWER_DUCC_MODE(DUccMode));
;;;128      /* Clear POWER_REG0E[5:0] bits */
;;;129      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUcc_Mask);
000002  6b92              LDR      r2,[r2,#0x38]
000004  f022013f          BIC      r1,r2,#0x3f
;;;130      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;131      tmpreg |= DUcc_Mask & DUccMode;
000008  f000023f          AND      r2,r0,#0x3f
00000c  4311              ORRS     r1,r1,r2
;;;132      MDR_BKP -> REG_0E = tmpreg;
00000e  4a01              LDR      r2,|L2.20|
000010  6391              STR      r1,[r2,#0x38]
;;;133    }
000012  4770              BX       lr
;;;134    
                          ENDP

                  |L2.20|
                          DCD      0x400d8000

                          AREA ||i.POWER_DUccStandby||, CODE, READONLY, ALIGN=2

                  POWER_DUccStandby PROC
;;;165      */
;;;166    void POWER_DUccStandby ( void )
000000  2001              MOVS     r0,#1
;;;167    {
;;;168    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;169    *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000002  4901              LDR      r1,|L3.8|
000004  6008              STR      r0,[r1,#0]
;;;170    #elif defined (USE_MDR1986VE3)
;;;171    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;172    #endif
;;;173    
;;;174    }
000006  4770              BX       lr
;;;175    
                          ENDP

                  |L3.8|
                          DCD      0x43b007f8

                          AREA ||i.POWER_DUccTrim||, CODE, READONLY, ALIGN=2

                  POWER_DUccTrim PROC
;;;148      */
;;;149    void POWER_DUccTrim(uint32_t DUccTrim)
000000  4a04              LDR      r2,|L4.20|
;;;150    {
;;;151      uint32_t tmpreg;
;;;152      /* Check the parameters */
;;;153      assert_param(IS_POWER_DUCC_TRIM(DUccTrim));
;;;154      /* Clear POWER_REG0E[5:0] bits */
;;;155      tmpreg  = MDR_BKP -> REG_0E & (uint32_t) (~DUccTrim_Mask);
000002  6b92              LDR      r2,[r2,#0x38]
000004  f42261e0          BIC      r1,r2,#0x700
;;;156      /* Set POWER_REG0E[5:0] bits according to DUcc mode */
;;;157      tmpreg |= DUccTrim_Mask & DUccTrim;
000008  f40062e0          AND      r2,r0,#0x700
00000c  4311              ORRS     r1,r1,r2
;;;158      MDR_BKP -> REG_0E = tmpreg;
00000e  4a01              LDR      r2,|L4.20|
000010  6391              STR      r1,[r2,#0x38]
;;;159    }
000012  4770              BX       lr
;;;160    
                          ENDP

                  |L4.20|
                          DCD      0x400d8000

                          AREA ||i.POWER_DeInit||, CODE, READONLY, ALIGN=2

                  POWER_DeInit PROC
;;;103      */
;;;104    void POWER_DeInit(void)
000000  2000              MOVS     r0,#0
;;;105    {
;;;106      MDR_POWER -> PVDCS = (uint32_t) 0x00000000;
000002  4901              LDR      r1,|L5.8|
000004  6008              STR      r0,[r1,#0]
;;;107    }
000006  4770              BX       lr
;;;108    
                          ENDP

                  |L5.8|
                          DCD      0x40058000

                          AREA ||i.POWER_EnterSTANDBYMode||, CODE, READONLY, ALIGN=2

                  POWER_EnterSTANDBYMode PROC
;;;446      */
;;;447    void POWER_EnterSTANDBYMode ( void )
000000  2001              MOVS     r0,#1
;;;448    {
;;;449    	/* Select STANDBY mode */
;;;450    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;451    	*(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) 0x01;
000002  4905              LDR      r1,|L6.24|
000004  6008              STR      r0,[r1,#0]
;;;452    	/* Set SLEEPDEEP bit of Cortex System Control Register */
;;;453    	*(__IO uint32_t *) SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000006  4905              LDR      r1,|L6.28|
000008  6808              LDR      r0,[r1,#0]
00000a  6801              LDR      r1,[r0,#0]
00000c  f0410104          ORR      r1,r1,#4
000010  6001              STR      r1,[r0,#0]
;;;454    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;455    	MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
;;;456    #endif
;;;457    	/* Request Wait For Interrupt */
;;;458    	__WFI();
000012  bf30              WFI      
;;;459    }
000014  4770              BX       lr
;;;460    
                          ENDP

000016  0000              DCW      0x0000
                  |L6.24|
                          DCD      0x43b007f8
                  |L6.28|
                          DCD      0xe000ed10

                          AREA ||i.POWER_EnterSTOPMode||, CODE, READONLY, ALIGN=2

                  POWER_EnterSTOPMode PROC
;;;394      */
;;;395    void POWER_EnterSTOPMode(FunctionalState POWER_Regulator_state, uint8_t POWER_STOPentry)
000000  b908              CBNZ     r0,|L7.6|
;;;396    {
;;;397      /* Check the parameters */
;;;398      assert_param(IS_FUNCTIONAL_STATE(POWER_Regulator_state));
;;;399      assert_param(IS_POWER_STOP_ENTRY(POWER_STOPentry));
;;;400    
;;;401      /* Set UDcc stanby status */
;;;402    
;;;403       *(__IO uint32_t *) BKP_STANDBY_BB = (uint32_t) (!POWER_Regulator_state);
000002  2201              MOVS     r2,#1
000004  e000              B        |L7.8|
                  |L7.6|
000006  2200              MOVS     r2,#0
                  |L7.8|
000008  4b0e              LDR      r3,|L7.68|
00000a  601a              STR      r2,[r3,#0]
;;;404       /* Set SLEEPDEEP bit of Cortex System Control Register */
;;;405       *(__IO uint32_t *) SCB -> SCR |= SCB_SCR_SLEEPDEEP_Msk;
00000c  4b0e              LDR      r3,|L7.72|
00000e  681a              LDR      r2,[r3,#0]
000010  6813              LDR      r3,[r2,#0]
000012  f0430304          ORR      r3,r3,#4
000016  6013              STR      r3,[r2,#0]
;;;406    
;;;407       if(POWER_Regulator_state == ENABLE){
000018  2801              CMP      r0,#1
00001a  d106              BNE      |L7.42|
;;;408    	   MDR_BKP->REG_0F &= ~BKP_REG_0F_STANDBY;
00001c  4a0b              LDR      r2,|L7.76|
00001e  6bd2              LDR      r2,[r2,#0x3c]
000020  f0224280          BIC      r2,r2,#0x40000000
000024  4b09              LDR      r3,|L7.76|
000026  63da              STR      r2,[r3,#0x3c]
000028  e005              B        |L7.54|
                  |L7.42|
;;;409       }
;;;410       else{
;;;411    	   MDR_BKP->REG_0F |= BKP_REG_0F_STANDBY;
00002a  4a08              LDR      r2,|L7.76|
00002c  6bd2              LDR      r2,[r2,#0x3c]
00002e  f0424280          ORR      r2,r2,#0x40000000
000032  4b06              LDR      r3,|L7.76|
000034  63da              STR      r2,[r3,#0x3c]
                  |L7.54|
;;;412       }
;;;413      /* Select STOP mode entry --------------------------------------------------*/
;;;414      if(POWER_STOPentry == POWER_STOPentry_WFI)
000036  2901              CMP      r1,#1
000038  d101              BNE      |L7.62|
;;;415      {
;;;416        /* Request Wait For Interrupt */
;;;417        __WFI();
00003a  bf30              WFI      
00003c  e000              B        |L7.64|
                  |L7.62|
;;;418      }
;;;419      else
;;;420      {
;;;421        /* Request Wait For Event */
;;;422        __WFE();
00003e  bf20              WFE      
                  |L7.64|
;;;423      }
;;;424    }
000040  4770              BX       lr
;;;425    #elif defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3)
                          ENDP

000042  0000              DCW      0x0000
                  |L7.68|
                          DCD      0x43b007f8
                  |L7.72|
                          DCD      0xe000ed10
                  |L7.76|
                          DCD      0x400d8000

                          AREA ||i.POWER_FlagPORstatus||, CODE, READONLY, ALIGN=2

                  POWER_FlagPORstatus PROC
;;;248      */
;;;249    ErrorStatus POWER_FlagPORstatus(void)
000000  2000              MOVS     r0,#0
;;;250    {
;;;251      ErrorStatus state = ERROR;
;;;252    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;253      if (*(__IO uint32_t *) BKP_FPOR_BB == 0)
000002  4902              LDR      r1,|L8.12|
000004  6809              LDR      r1,[r1,#0]
000006  b901              CBNZ     r1,|L8.10|
;;;254      {
;;;255        state = SUCCESS;
000008  2001              MOVS     r0,#1
                  |L8.10|
;;;256      }
;;;257    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;258      if (( MDR_BKP->REG_0E & BKP_REG_0E_FPOR ) == BKP_REG_0E_FPOR) {
;;;259    	  state = SUCCESS;
;;;260      }
;;;261    #endif
;;;262      return state;
;;;263    }
00000a  4770              BX       lr
;;;264    
                          ENDP

                  |L8.12|
                          DCD      0x43b0072c

                          AREA ||i.POWER_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  POWER_GetFlagStatus PROC
;;;295      */
;;;296    FlagStatus POWER_GetFlagStatus(uint32_t POWER_FLAG)
000000  4601              MOV      r1,r0
;;;297    {
;;;298      FlagStatus status;
;;;299      /* Check the parameters */
;;;300      assert_param(IS_POWER_FLAG(POWER_FLAG));
;;;301    
;;;302      if ((MDR_POWER->PVDCS & POWER_FLAG) != (uint32_t)RESET)
000002  4a04              LDR      r2,|L9.20|
000004  6812              LDR      r2,[r2,#0]
000006  400a              ANDS     r2,r2,r1
000008  b10a              CBZ      r2,|L9.14|
;;;303      {
;;;304        status = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L9.16|
                  |L9.14|
;;;305      }
;;;306      else
;;;307      {
;;;308        status = RESET;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;309      }
;;;310      /* Return the flag status */
;;;311      return status;
;;;312    }
000010  4770              BX       lr
;;;313    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40058000

                          AREA ||i.POWER_PVBDlevelConfig||, CODE, READONLY, ALIGN=2

                  POWER_PVBDlevelConfig PROC
;;;215      */
;;;216    void POWER_PVBDlevelConfig(uint32_t POWER_PVBDlevel)
000000  4601              MOV      r1,r0
;;;217    {
;;;218      uint32_t tmpreg;
;;;219      /* Check the parameters */
;;;220      assert_param(IS_POWER_PVBD_LEVEL(POWER_PVBDlevel));
;;;221      tmpreg = MDR_POWER->PVDCS;
000002  4a05              LDR      r2,|L10.24|
000004  6810              LDR      r0,[r2,#0]
;;;222      /* Clear PBLS[2:1] bits */
;;;223      tmpreg &= (uint32_t) ~POWER_PVDCS_PBLS_Msk;
000006  f0200006          BIC      r0,r0,#6
;;;224      /* Set PBLS[2:1] bits according to POWER_PVBDlevel value */
;;;225      tmpreg |= (POWER_PVBDlevel & POWER_PVDCS_PBLS_Msk);
00000a  f0010206          AND      r2,r1,#6
00000e  4310              ORRS     r0,r0,r2
;;;226      /* Store the new value */
;;;227      MDR_POWER->PVDCS = tmpreg;
000010  4a01              LDR      r2,|L10.24|
000012  6010              STR      r0,[r2,#0]
;;;228    }
000014  4770              BX       lr
;;;229    
                          ENDP

000016  0000              DCW      0x0000
                  |L10.24|
                          DCD      0x40058000

                          AREA ||i.POWER_PVD_INVconfig||, CODE, READONLY, ALIGN=2

                  POWER_PVD_INVconfig PROC
;;;366      */
;;;367    void POWER_PVD_INVconfig(uint32_t POWER_INV, FunctionalState NewState)
000000  b129              CBZ      r1,|L11.14|
;;;368    {
;;;369      /* Check the parameters */
;;;370      assert_param(IS_POWER_PVD_INV(POWER_INV));
;;;371      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;372    
;;;373      if (NewState != DISABLE)
;;;374      {
;;;375        MDR_POWER->PVDCS |= POWER_INV;
000002  4a06              LDR      r2,|L11.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L11.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L11.24|
                  |L11.14|
;;;376      }
;;;377      else
;;;378      {
;;;379        MDR_POWER->PVDCS &= (uint32_t)~POWER_INV;
00000e  4a03              LDR      r2,|L11.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L11.28|
000016  601a              STR      r2,[r3,#0]
                  |L11.24|
;;;380      }
;;;381    }
000018  4770              BX       lr
;;;382    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40058000

                          AREA ||i.POWER_PVD_ITconfig||, CODE, READONLY, ALIGN=2

                  POWER_PVD_ITconfig PROC
;;;339      */
;;;340    void POWER_PVD_ITconfig(uint32_t POWER_IT, FunctionalState NewState)
000000  b129              CBZ      r1,|L12.14|
;;;341    {
;;;342      /* Check the parameters */
;;;343      assert_param(IS_POWER_PVD_IT(POWER_IT));
;;;344      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;345    
;;;346      if (NewState != DISABLE)
;;;347      {
;;;348        MDR_POWER->PVDCS |= POWER_IT;
000002  4a06              LDR      r2,|L12.28|
000004  6812              LDR      r2,[r2,#0]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L12.28|
00000a  601a              STR      r2,[r3,#0]
00000c  e004              B        |L12.24|
                  |L12.14|
;;;349      }
;;;350      else
;;;351      {
;;;352        MDR_POWER->PVDCS &= (uint32_t)~POWER_IT;
00000e  4a03              LDR      r2,|L12.28|
000010  6812              LDR      r2,[r2,#0]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L12.28|
000016  601a              STR      r2,[r3,#0]
                  |L12.24|
;;;353      }
;;;354    }
000018  4770              BX       lr
;;;355    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      0x40058000

                          AREA ||i.POWER_PVDenable||, CODE, READONLY, ALIGN=2

                  POWER_PVDenable PROC
;;;270      */
;;;271    void POWER_PVDenable ( FunctionalState NewState )
000000  4901              LDR      r1,|L13.8|
;;;272    {
;;;273    	/* Check the parameters */
;;;274    	assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;275    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;276    	*(__IO uint32_t *) POWER_PVDEN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;277    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;278    	if(NewState != DISABLE){
;;;279    		MDR_POWER->PVDCS |= POWER_PVDCS_PVDEN;
;;;280    	}
;;;281    	else {
;;;282    		MDR_POWER->PVDCS &= ~POWER_PVDCS_PVDEN;
;;;283    	}
;;;284    #endif
;;;285    }
000004  4770              BX       lr
;;;286    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x42b00000

                          AREA ||i.POWER_PVDlevelConfig||, CODE, READONLY, ALIGN=2

                  POWER_PVDlevelConfig PROC
;;;190      */
;;;191    void POWER_PVDlevelConfig(uint32_t POWER_PVDlevel)
000000  4601              MOV      r1,r0
;;;192    {
;;;193      uint32_t tmpreg;
;;;194      /* Check the parameters */
;;;195      assert_param(IS_POWER_PVD_LEVEL(POWER_PVDlevel));
;;;196      tmpreg = MDR_POWER->PVDCS;
000002  4a05              LDR      r2,|L14.24|
000004  6810              LDR      r0,[r2,#0]
;;;197      /* Clear PLS[5:3] bits */
;;;198      tmpreg &= (uint32_t) ~POWER_PVDCS_PLS_Msk;
000006  f0200038          BIC      r0,r0,#0x38
;;;199      /* Set PLS[5:3] bits according to POWER_PVDlevel value */
;;;200      tmpreg |= (POWER_PVDlevel & POWER_PVDCS_PLS_Msk);
00000a  f0010238          AND      r2,r1,#0x38
00000e  4310              ORRS     r0,r0,r2
;;;201      /* Store the new value */
;;;202      MDR_POWER->PVDCS = tmpreg;
000010  4a01              LDR      r2,|L14.24|
000012  6010              STR      r0,[r2,#0]
;;;203    }
000014  4770              BX       lr
;;;204    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      0x40058000

                          AREA ||i.POWER_SetFlagPOR||, CODE, READONLY, ALIGN=2

                  POWER_SetFlagPOR PROC
;;;234      */
;;;235    void POWER_SetFlagPOR ( void )
000000  2001              MOVS     r0,#1
;;;236    {
;;;237    #if defined (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;238    	*(__IO uint32_t *) BKP_FPOR_BB = (uint32_t) 0x01;
000002  4901              LDR      r1,|L15.8|
000004  6008              STR      r0,[r1,#0]
;;;239    #elif defined (USE_MDR1986VE3) || defined (USE_MDR1986VE1T)
;;;240    	MDR_BKP->REG_0E |= BKP_REG_0E_FPOR;
;;;241    #endif
;;;242    }
000006  4770              BX       lr
;;;243    
                          ENDP

                  |L15.8|
                          DCD      0x43b0072c

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_power.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH|
#line 462
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_MDR32F9Qx_power_c_8d54e3c7____RRX|
#line 649
|__asm___17_MDR32F9Qx_power_c_8d54e3c7____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
