; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_ssp.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_ssp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_ssp.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_ssp.c]
                          THUMB

                          AREA ||i.SSP_BRGInit||, CODE, READONLY, ALIGN=2

                  SSP_BRGInit PROC
;;;396      */
;;;397    void SSP_BRGInit ( MDR_SSP_TypeDef* SSPx, uint32_t SSP_BRG ) {
000000  4602              MOV      r2,r0
;;;398    	uint32_t tmpreg;
;;;399    
;;;400    	/* Check the parameters */
;;;401    	assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;402    	assert_param(IS_SSP_CLOCK_BRG(SSP_BRG));
;;;403    
;;;404    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;405    	if ( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3)) {
;;;406    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;407    	}
;;;408    	else
;;;409    #endif	// #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;410    #if defined (USE_MDR1901VC1T)
;;;411    	if(SSPx == MDR_SSP4)
;;;412    		tmpreg = MDR_RST_CLK->SPP2_CLOCK;
;;;413    	else
;;;414    #endif
;;;415    		tmpreg = MDR_RST_CLK->SSP_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6ad8              LDR      r0,[r3,#0x2c]
;;;416    
;;;417    
;;;418    
;;;419    	if (SSPx == MDR_SSP1) {
000006  4b0b              LDR      r3,|L1.52|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;420    		tmpreg |= RST_CLK_SSP_CLOCK_SSP1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;421    		tmpreg &= ~RST_CLK_SSP_CLOCK_SSP1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;422    		tmpreg |= SSP_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;423    	}
;;;424    	else if (SSPx == MDR_SSP2) {
000018  4b07              LDR      r3,|L1.56|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;425    			tmpreg |= RST_CLK_SSP_CLOCK_SSP2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;426    			tmpreg &= ~RST_CLK_SSP_CLOCK_SSP2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;427    			tmpreg |= (SSP_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;428    		}
;;;429    #if defined (USE_MDR1986VE1T) || defined (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
;;;430    	else if(SSPx == MDR_SSP3) {
;;;431    			tmpreg |= RST_CLK_SSP_CLOCK_SSP3_CLK_EN;
;;;432    			tmpreg &= ~RST_CLK_SSP_CLOCK_SSP3_BRG_Msk;
;;;433    			tmpreg |= (SSP_BRG << RST_CLK_SSP_CLOCK_SSP3_BRG_Pos);
;;;434    		}
;;;435    #endif      
;;;436    #if defined (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
;;;437    	else if(SSPx == MDR_SSP4) {
;;;438    			tmpreg |= SSP4_CLK_EN;
;;;439    			tmpreg &= ~SSP4_BRG_Mask;
;;;440    			tmpreg |= (SSP_BRG << SSP4_BRG_Pos);
;;;441    		}
;;;442    #endif  
;;;443    
;;;444    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;445    	if( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3) ){
;;;446    		MDR_RST_CLK->UART_SSP_CLOCK = tmpreg;
;;;447    	}
;;;448    	else
;;;449    #endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;450    #if defined (USE_MDR1901VC1T)
;;;451    	if(SSPx == MDR_SSP4)
;;;452    		MDR_RST_CLK->SPP2_CLOCK = tmpreg;
;;;453    #endif
;;;454    		MDR_RST_CLK->SSP_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  62d8              STR      r0,[r3,#0x2c]
;;;455    
;;;456    }
00002e  4770              BX       lr
;;;457    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40040000
                  |L1.56|
                          DCD      0x400a0000

                          AREA ||i.SSP_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SSP_ClearITPendingBit PROC
;;;269      */
;;;270    void SSP_ClearITPendingBit(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  6a02              LDR      r2,[r0,#0x20]
;;;271    {
;;;272      /* Check the parameters */
;;;273      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;274      assert_param(IS_SSP_RESET_IT(SSP_IT));
;;;275    
;;;276      SSPx->ICR |= SSP_IT;
000002  430a              ORRS     r2,r2,r1
000004  6202              STR      r2,[r0,#0x20]
;;;277    }
000006  4770              BX       lr
;;;278    
                          ENDP


                          AREA ||i.SSP_Cmd||, CODE, READONLY, ALIGN=1

                  SSP_Cmd PROC
;;;142      */
;;;143    void SSP_Cmd(MDR_SSP_TypeDef* SSPx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;144    {
;;;145      /* Check the parameters */
;;;146      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;147      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;148    
;;;149      if (NewState != DISABLE)
;;;150      {
;;;151        /* Enable the selected SSP by setting the SSE bit in the CR1 register */
;;;152        SSPx->CR1 |= CR1_EN_Set;
000002  6842              LDR      r2,[r0,#4]
000004  f0420202          ORR      r2,r2,#2
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;153      }
;;;154      else
;;;155      {
;;;156        /* Disable the selected SSP by clearing the SSE bit in the CR1 register */
;;;157        SSPx->CR1 &= CR1_EN_Reset;
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L3.22|
;;;158      }
;;;159    }
000016  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i.SSP_DMACmd||, CODE, READONLY, ALIGN=1

                  SSP_DMACmd PROC
;;;292      */
;;;293    void SSP_DMACmd(MDR_SSP_TypeDef* SSPx, uint32_t SSP_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;294    {
;;;295      /* Check the parameters */
;;;296      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;297      assert_param(IS_SSP_DMAREQ(SSP_DMAReq));
;;;298      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;299    
;;;300      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L4.12|
;;;301      {
;;;302        /* Enable the DMA transfer for selected requests in the SSP DMACR register */
;;;303        SSPx->DMACR |= SSP_DMAReq;
000004  6a43              LDR      r3,[r0,#0x24]
000006  430b              ORRS     r3,r3,r1
000008  6243              STR      r3,[r0,#0x24]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;304      }
;;;305      else
;;;306      {
;;;307        /* Disable the DMA transfer for selected requests in the SSP DMACR register */
;;;308        SSPx->DMACR &= (uint16_t)~SSP_DMAReq;
00000c  6a43              LDR      r3,[r0,#0x24]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  6243              STR      r3,[r0,#0x24]
                  |L4.22|
;;;309      }
;;;310    }
000016  bd10              POP      {r4,pc}
;;;311    
                          ENDP


                          AREA ||i.SSP_DeInit||, CODE, READONLY, ALIGN=1

                  SSP_DeInit PROC
;;;50       */
;;;51     void SSP_DeInit(MDR_SSP_TypeDef* SSPx)
000000  2100              MOVS     r1,#0
;;;52     {
;;;53       /* Check the parameters */
;;;54       assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;55     
;;;56       SSPx->CR0   = 0;
000002  6001              STR      r1,[r0,#0]
;;;57       SSPx->CR1   = 0;
000004  6041              STR      r1,[r0,#4]
;;;58       SSPx->CPSR  = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;59       SSPx->IMSC  = 0;
000008  6141              STR      r1,[r0,#0x14]
;;;60       SSPx->DMACR = 0;
00000a  6241              STR      r1,[r0,#0x24]
;;;61     
;;;62       /* Clear SSP ICR[RTIC] and SSP ICR[RORIC] bits */
;;;63       SSPx->ICR = SSP_IT_RT | SSP_IT_ROR;
00000c  2103              MOVS     r1,#3
00000e  6201              STR      r1,[r0,#0x20]
;;;64     
;;;65     }
000010  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.SSP_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SSP_GetFlagStatus PROC
;;;358      */
;;;359    FlagStatus SSP_GetFlagStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_FLAG)
000000  4602              MOV      r2,r0
;;;360    {
;;;361      FlagStatus bitstatus;
;;;362    
;;;363      /* Check the parameters */
;;;364      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;365      assert_param(IS_SSP_FLAG(SSP_FLAG));
;;;366    
;;;367      if (SSPx->SR & SSP_FLAG)
000002  68d3              LDR      r3,[r2,#0xc]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;368      {
;;;369        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;370      }
;;;371      else
;;;372      {
;;;373        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;374      }
;;;375    
;;;376      return (bitstatus);
;;;377    }
00000e  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.SSP_GetITStatus||, CODE, READONLY, ALIGN=1

                  SSP_GetITStatus PROC
;;;205      */
;;;206    ITStatus SSP_GetITStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  4602              MOV      r2,r0
;;;207    {
;;;208      ITStatus bitstatus;
;;;209    
;;;210      /* Check the parameters */
;;;211      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;212      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;213    
;;;214      if ((SSPx->RIS & SSP_IT) == SSP_IT)
000002  6993              LDR      r3,[r2,#0x18]
000004  400b              ANDS     r3,r3,r1
000006  428b              CMP      r3,r1
000008  d101              BNE      |L7.14|
;;;215      {
;;;216        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L7.16|
                  |L7.14|
;;;217      }
;;;218      else
;;;219      {
;;;220        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;221      }
;;;222    
;;;223      return (bitstatus);
;;;224    }
000010  4770              BX       lr
;;;225    
                          ENDP


                          AREA ||i.SSP_GetITStatusMasked||, CODE, READONLY, ALIGN=1

                  SSP_GetITStatusMasked PROC
;;;238      */
;;;239    ITStatus SSP_GetITStatusMasked(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  4602              MOV      r2,r0
;;;240    {
;;;241      ITStatus bitstatus;
;;;242    
;;;243      /* Check the parameters */
;;;244      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;245      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;246    
;;;247      if (SSPx->MIS & SSP_IT)
000002  69d3              LDR      r3,[r2,#0x1c]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L8.12|
;;;248      {
;;;249        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L8.14|
                  |L8.12|
;;;250      }
;;;251      else
;;;252      {
;;;253        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;254      }
;;;255    
;;;256      return (bitstatus);
;;;257    }
00000e  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.SSP_ITConfig||, CODE, READONLY, ALIGN=1

                  SSP_ITConfig PROC
;;;175      */
;;;176    void SSP_ITConfig(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L9.10|
;;;177    {
;;;178      /* Check the parameters */
;;;179      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;180      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;181      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;182    
;;;183      if (NewState != DISABLE)
;;;184      {
;;;185        SSPx->IMSC |= SSP_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L9.16|
                  |L9.10|
;;;186      }
;;;187      else
;;;188      {
;;;189        SSPx->IMSC &= ~SSP_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L9.16|
;;;190      }
;;;191    }
000010  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.SSP_Init||, CODE, READONLY, ALIGN=1

                  SSP_Init PROC
;;;76       */
;;;77     void SSP_Init(MDR_SSP_TypeDef* SSPx, const SSP_InitTypeDef* SSP_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;78     {
;;;79       uint32_t tmpreg;
;;;80     
;;;81       /* Check the parameters */
;;;82       assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;83       assert_param(IS_SSP_SPEED_FACTOR(SSP_InitStruct->SSP_SCR));
;;;84       assert_param(IS_SSP_SPEED_DIVIDER(SSP_InitStruct->SSP_CPSDVSR));
;;;85       assert_param(IS_SSP_MODE(SSP_InitStruct->SSP_Mode));
;;;86       assert_param(IS_SSP_WORD_LENGTH(SSP_InitStruct->SSP_WordLength));
;;;87       assert_param(IS_SSP_SPH(SSP_InitStruct->SSP_SPH));
;;;88       assert_param(IS_SSP_SPO(SSP_InitStruct->SSP_SPO));
;;;89       assert_param(IS_SSP_FRF(SSP_InitStruct->SSP_FRF));
;;;90       assert_param(IS_SSP_HARDWARE_FLOW_CONTROL(SSP_InitStruct->SSP_HardwareFlowControl));
;;;91     
;;;92       /* SSPx CPSR Configuration */
;;;93       SSPx->CPSR = SSP_InitStruct->SSP_CPSDVSR;
000002  884b              LDRH     r3,[r1,#2]
000004  6103              STR      r3,[r0,#0x10]
;;;94     
;;;95       /* SSPx CR0 Configuration */
;;;96       tmpreg = (SSP_InitStruct->SSP_SCR << SSP_CR0_SCR_Pos)
000006  890b              LDRH     r3,[r1,#8]
000008  880c              LDRH     r4,[r1,#0]
00000a  eb032304          ADD      r3,r3,r4,LSL #8
00000e  894c              LDRH     r4,[r1,#0xa]
000010  4423              ADD      r3,r3,r4
000012  898c              LDRH     r4,[r1,#0xc]
000014  4423              ADD      r3,r3,r4
000016  88cc              LDRH     r4,[r1,#6]
000018  191a              ADDS     r2,r3,r4
;;;97              + SSP_InitStruct->SSP_SPH
;;;98              + SSP_InitStruct->SSP_SPO
;;;99              + SSP_InitStruct->SSP_FRF
;;;100             + SSP_InitStruct->SSP_WordLength;
;;;101      SSPx->CR0 = tmpreg;
00001a  6002              STR      r2,[r0,#0]
;;;102    
;;;103      /* SSPx CR1 Configuration */
;;;104      tmpreg = SSP_InitStruct->SSP_HardwareFlowControl + SSP_InitStruct->SSP_Mode;
00001c  89cb              LDRH     r3,[r1,#0xe]
00001e  888c              LDRH     r4,[r1,#4]
000020  191a              ADDS     r2,r3,r4
;;;105      SSPx->CR1 = tmpreg;
000022  6042              STR      r2,[r0,#4]
;;;106    }
000024  bd10              POP      {r4,pc}
;;;107    
                          ENDP


                          AREA ||i.SSP_ReceiveData||, CODE, READONLY, ALIGN=1

                  SSP_ReceiveData PROC
;;;336      */
;;;337    uint16_t SSP_ReceiveData(MDR_SSP_TypeDef* SSPx)
000000  4601              MOV      r1,r0
;;;338    {
;;;339      /* Check the parameters */
;;;340      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;341    
;;;342      /* Receive Data */
;;;343      return ((uint16_t)(SSPx->DR));
000002  6888              LDR      r0,[r1,#8]
000004  b280              UXTH     r0,r0
;;;344    }
000006  4770              BX       lr
;;;345    
                          ENDP


                          AREA ||i.SSP_SendData||, CODE, READONLY, ALIGN=1

                  SSP_SendData PROC
;;;319      */
;;;320    void SSP_SendData(MDR_SSP_TypeDef* SSPx, uint16_t Data)
000000  6081              STR      r1,[r0,#8]
;;;321    {
;;;322      /* Check the parameters */
;;;323      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;324    
;;;325      /* Transmit Data */
;;;326      SSPx->DR = Data;
;;;327    
;;;328    }
000002  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.SSP_StructInit||, CODE, READONLY, ALIGN=1

                  SSP_StructInit PROC
;;;113      */
;;;114    void SSP_StructInit(SSP_InitTypeDef* SSP_InitStruct)
000000  2100              MOVS     r1,#0
;;;115    {
;;;116      /* SSP_InitStruct members default value */
;;;117      /* Initialize the SPI_Mode member */
;;;118      SSP_InitStruct->SSP_Mode = SSP_ModeMaster;
000002  8081              STRH     r1,[r0,#4]
;;;119      /* initialize the SSP_WordLength member */
;;;120      SSP_InitStruct->SSP_WordLength = SSP_WordLength8b;
000004  2107              MOVS     r1,#7
000006  80c1              STRH     r1,[r0,#6]
;;;121      /* Initialize the SSP_SPO member */
;;;122      SSP_InitStruct->SSP_SPO = SSP_SPO_Low;
000008  2100              MOVS     r1,#0
00000a  8141              STRH     r1,[r0,#0xa]
;;;123      /* Initialize the SSP_SPH member */
;;;124      SSP_InitStruct->SSP_SPH = SSP_SPH_1Edge;
00000c  8101              STRH     r1,[r0,#8]
;;;125      /* Initialize the SSP_FRF member */
;;;126      SSP_InitStruct->SSP_FRF = SSP_FRF_SPI_Motorola;
00000e  8181              STRH     r1,[r0,#0xc]
;;;127      /* Initialize the SSP max speed */
;;;128      SSP_InitStruct->SSP_CPSDVSR = 2;
000010  2102              MOVS     r1,#2
000012  8041              STRH     r1,[r0,#2]
;;;129      SSP_InitStruct->SSP_SCR = 0;
000014  2100              MOVS     r1,#0
000016  8001              STRH     r1,[r0,#0]
;;;130      
;;;131      SSP_InitStruct->SSP_HardwareFlowControl = 0;
000018  81c1              STRH     r1,[r0,#0xe]
;;;132    }
00001a  4770              BX       lr
;;;133    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_ssp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH|
#line 482
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____RRX|
#line 669
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
