; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_ssp.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_ssp.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_ssp.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_ssp.c]
                          THUMB

                          AREA ||i.SSP_BRGInit||, CODE, READONLY, ALIGN=2

                  SSP_BRGInit PROC
;;;414      */
;;;415    void SSP_BRGInit ( MDR_SSP_TypeDef* SSPx, uint32_t SSP_BRG ) {
000000  4602              MOV      r2,r0
;;;416    	uint32_t tmpreg;
;;;417    
;;;418    	/* Check the parameters */
;;;419    	assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;420    	assert_param(IS_SSP_CLOCK_BRG(SSP_BRG));
;;;421    
;;;422    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;423    	if ( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3)) {
;;;424    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;425    	}
;;;426    	else
;;;427    #endif	// #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;428    #if defined (USE_MDR1901VC1T)
;;;429    	if(SSPx == MDR_SSP4)
;;;430    		tmpreg = MDR_RST_CLK->SPP2_CLOCK;
;;;431    	else
;;;432    #endif
;;;433    		tmpreg = MDR_RST_CLK->SSP_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6ad8              LDR      r0,[r3,#0x2c]
;;;434    
;;;435    
;;;436    
;;;437    	if (SSPx == MDR_SSP1) {
000006  4b0b              LDR      r3,|L1.52|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;438    		tmpreg |= RST_CLK_SSP_CLOCK_SSP1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;439    		tmpreg &= ~RST_CLK_SSP_CLOCK_SSP1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;440    		tmpreg |= SSP_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;441    	}
;;;442    	else{
;;;443    		if (SSPx == MDR_SSP2) {
000018  4b07              LDR      r3,|L1.56|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;444    			tmpreg |= RST_CLK_SSP_CLOCK_SSP2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;445    			tmpreg &= ~RST_CLK_SSP_CLOCK_SSP2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;446    			tmpreg |= (SSP_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;447    		}
;;;448    #if defined  (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
;;;449    		else{
;;;450    			if(SSPx == MDR_SSP3) {
;;;451    				tmpreg |= RST_CLK_SSP_CLOCK_SSP3_CLK_EN;
;;;452    				tmpreg &= ~RST_CLK_SSP_CLOCK_SSP3_BRG_Msk;
;;;453    				tmpreg |= (SSP_BRG << RST_CLK_SSP_CLOCK_SSP3_BRG_Pos);
;;;454    			}
;;;455    
;;;456    			else{
;;;457    				if(SSPx == MDR_SSP4) {
;;;458    					tmpreg |= SSP4_CLK_EN;
;;;459    					tmpreg &= ~SSP4_BRG_Mask;
;;;460    					tmpreg |= (SSP_BRG << SSP4_BRG_Pos);
;;;461    				}
;;;462    			}
;;;463    		}
;;;464    #endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;465    	}
;;;466    #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;467    	if( (SSPx != MDR_SSP1) && (SSPx != MDR_SSP2) && (SSPx != MDR_SSP3) ){
;;;468    		MDR_RST_CLK->UART_SSP_CLOCK = tmpreg;
;;;469    	}
;;;470    	else
;;;471    #endif // #ifdef USE_MDR1986VE3 /* For Cortex M1 */
;;;472    #if defined (USE_MDR1901VC1T)
;;;473    	if(SSPx == MDR_SSP4)
;;;474    		MDR_RST_CLK->SPP2_CLOCK = tmpreg;
;;;475    #endif
;;;476    		MDR_RST_CLK->SSP_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  62d8              STR      r0,[r3,#0x2c]
;;;477    
;;;478    }
00002e  4770              BX       lr
;;;479    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40040000
                  |L1.56|
                          DCD      0x400a0000

                          AREA ||i.SSP_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SSP_ClearITPendingBit PROC
;;;287      */
;;;288    void SSP_ClearITPendingBit(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  6a02              LDR      r2,[r0,#0x20]
;;;289    {
;;;290      /* Check the parameters */
;;;291      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;292      assert_param(IS_SSP_RESET_IT(SSP_IT));
;;;293    
;;;294      SSPx->ICR |= SSP_IT;
000002  430a              ORRS     r2,r2,r1
000004  6202              STR      r2,[r0,#0x20]
;;;295    }
000006  4770              BX       lr
;;;296    
                          ENDP


                          AREA ||i.SSP_Cmd||, CODE, READONLY, ALIGN=1

                  SSP_Cmd PROC
;;;160      */
;;;161    void SSP_Cmd(MDR_SSP_TypeDef* SSPx, FunctionalState NewState)
000000  b121              CBZ      r1,|L3.12|
;;;162    {
;;;163      /* Check the parameters */
;;;164      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;165      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;166    
;;;167      if (NewState != DISABLE)
;;;168      {
;;;169        /* Enable the selected SSP by setting the SSE bit in the CR1 register */
;;;170        SSPx->CR1 |= CR1_EN_Set;
000002  6842              LDR      r2,[r0,#4]
000004  f0420202          ORR      r2,r2,#2
000008  6042              STR      r2,[r0,#4]
00000a  e004              B        |L3.22|
                  |L3.12|
;;;171      }
;;;172      else
;;;173      {
;;;174        /* Disable the selected SSP by clearing the SSE bit in the CR1 register */
;;;175        SSPx->CR1 &= CR1_EN_Reset;
00000c  6842              LDR      r2,[r0,#4]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  401a              ANDS     r2,r2,r3
000014  6042              STR      r2,[r0,#4]
                  |L3.22|
;;;176      }
;;;177    }
000016  4770              BX       lr
;;;178    
                          ENDP


                          AREA ||i.SSP_DMACmd||, CODE, READONLY, ALIGN=1

                  SSP_DMACmd PROC
;;;310      */
;;;311    void SSP_DMACmd(MDR_SSP_TypeDef* SSPx, uint32_t SSP_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;312    {
;;;313      /* Check the parameters */
;;;314      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;315      assert_param(IS_SSP_DMAREQ(SSP_DMAReq));
;;;316      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;317    
;;;318      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L4.12|
;;;319      {
;;;320        /* Enable the DMA transfer for selected requests in the SSP DMACR register */
;;;321        SSPx->DMACR |= SSP_DMAReq;
000004  6a43              LDR      r3,[r0,#0x24]
000006  430b              ORRS     r3,r3,r1
000008  6243              STR      r3,[r0,#0x24]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;322      }
;;;323      else
;;;324      {
;;;325        /* Disable the DMA transfer for selected requests in the SSP DMACR register */
;;;326        SSPx->DMACR &= (uint16_t)~SSP_DMAReq;
00000c  6a43              LDR      r3,[r0,#0x24]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  6243              STR      r3,[r0,#0x24]
                  |L4.22|
;;;327      }
;;;328    }
000016  bd10              POP      {r4,pc}
;;;329    
                          ENDP


                          AREA ||i.SSP_DeInit||, CODE, READONLY, ALIGN=1

                  SSP_DeInit PROC
;;;69       */
;;;70     void SSP_DeInit(MDR_SSP_TypeDef* SSPx)
000000  2100              MOVS     r1,#0
;;;71     {
;;;72       /* Check the parameters */
;;;73       assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;74     
;;;75       SSPx->CR0   = 0;
000002  6001              STR      r1,[r0,#0]
;;;76       SSPx->CR1   = 0;
000004  6041              STR      r1,[r0,#4]
;;;77       SSPx->CPSR  = 0;
000006  6101              STR      r1,[r0,#0x10]
;;;78       SSPx->IMSC  = 0;
000008  6141              STR      r1,[r0,#0x14]
;;;79       SSPx->DMACR = 0;
00000a  6241              STR      r1,[r0,#0x24]
;;;80     
;;;81       /* Clear SSP ICR[RTIC] and SSP ICR[RORIC] bits */
;;;82       SSPx->ICR = SSP_IT_RT | SSP_IT_ROR;
00000c  2103              MOVS     r1,#3
00000e  6201              STR      r1,[r0,#0x20]
;;;83     
;;;84     }
000010  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.SSP_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SSP_GetFlagStatus PROC
;;;376      */
;;;377    FlagStatus SSP_GetFlagStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_FLAG)
000000  4602              MOV      r2,r0
;;;378    {
;;;379      FlagStatus bitstatus;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;383      assert_param(IS_SSP_FLAG(SSP_FLAG));
;;;384    
;;;385      if (SSPx->SR & SSP_FLAG)
000002  68d3              LDR      r3,[r2,#0xc]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L6.12|
;;;386      {
;;;387        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L6.14|
                  |L6.12|
;;;388      }
;;;389      else
;;;390      {
;;;391        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L6.14|
;;;392      }
;;;393    
;;;394      return (bitstatus);
;;;395    }
00000e  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.SSP_GetITStatus||, CODE, READONLY, ALIGN=1

                  SSP_GetITStatus PROC
;;;223      */
;;;224    ITStatus SSP_GetITStatus(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  4602              MOV      r2,r0
;;;225    {
;;;226      ITStatus bitstatus;
;;;227    
;;;228      /* Check the parameters */
;;;229      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;230      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;231    
;;;232      if ((SSPx->RIS & SSP_IT) == SSP_IT)
000002  6993              LDR      r3,[r2,#0x18]
000004  400b              ANDS     r3,r3,r1
000006  428b              CMP      r3,r1
000008  d101              BNE      |L7.14|
;;;233      {
;;;234        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L7.16|
                  |L7.14|
;;;235      }
;;;236      else
;;;237      {
;;;238        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L7.16|
;;;239      }
;;;240    
;;;241      return (bitstatus);
;;;242    }
000010  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.SSP_GetITStatusMasked||, CODE, READONLY, ALIGN=1

                  SSP_GetITStatusMasked PROC
;;;256      */
;;;257    ITStatus SSP_GetITStatusMasked(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT)
000000  4602              MOV      r2,r0
;;;258    {
;;;259      ITStatus bitstatus;
;;;260    
;;;261      /* Check the parameters */
;;;262      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;263      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;264    
;;;265      if (SSPx->MIS & SSP_IT)
000002  69d3              LDR      r3,[r2,#0x1c]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L8.12|
;;;266      {
;;;267        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L8.14|
                  |L8.12|
;;;268      }
;;;269      else
;;;270      {
;;;271        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;272      }
;;;273    
;;;274      return (bitstatus);
;;;275    }
00000e  4770              BX       lr
;;;276    
                          ENDP


                          AREA ||i.SSP_ITConfig||, CODE, READONLY, ALIGN=1

                  SSP_ITConfig PROC
;;;193      */
;;;194    void SSP_ITConfig(MDR_SSP_TypeDef* SSPx, uint32_t SSP_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L9.10|
;;;195    {
;;;196      /* Check the parameters */
;;;197      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;198      assert_param(IS_SSP_CONFIG_IT(SSP_IT));
;;;199      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;200    
;;;201      if (NewState != DISABLE)
;;;202      {
;;;203        SSPx->IMSC |= SSP_IT;
000002  6943              LDR      r3,[r0,#0x14]
000004  430b              ORRS     r3,r3,r1
000006  6143              STR      r3,[r0,#0x14]
000008  e002              B        |L9.16|
                  |L9.10|
;;;204      }
;;;205      else
;;;206      {
;;;207        SSPx->IMSC &= ~SSP_IT;
00000a  6943              LDR      r3,[r0,#0x14]
00000c  438b              BICS     r3,r3,r1
00000e  6143              STR      r3,[r0,#0x14]
                  |L9.16|
;;;208      }
;;;209    }
000010  4770              BX       lr
;;;210    
                          ENDP


                          AREA ||i.SSP_Init||, CODE, READONLY, ALIGN=1

                  SSP_Init PROC
;;;95       */
;;;96     void SSP_Init(MDR_SSP_TypeDef* SSPx, const SSP_InitTypeDef* SSP_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;97     {
;;;98       uint32_t tmpreg;
;;;99     
;;;100      /* Check the parameters */
;;;101      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;102      assert_param(IS_SSP_SPEED_FACTOR(SSP_InitStruct->SSP_SCR));
;;;103      assert_param(IS_SSP_SPEED_DIVIDER(SSP_InitStruct->SSP_CPSDVSR));
;;;104      assert_param(IS_SSP_MODE(SSP_InitStruct->SSP_Mode));
;;;105      assert_param(IS_SSP_WORD_LENGTH(SSP_InitStruct->SSP_WordLength));
;;;106      assert_param(IS_SSP_SPH(SSP_InitStruct->SSP_SPH));
;;;107      assert_param(IS_SSP_SPO(SSP_InitStruct->SSP_SPO));
;;;108      assert_param(IS_SSP_FRF(SSP_InitStruct->SSP_FRF));
;;;109      assert_param(IS_SSP_HARDWARE_FLOW_CONTROL(SSP_InitStruct->SSP_HardwareFlowControl));
;;;110    
;;;111      /* SSPx CPSR Configuration */
;;;112      SSPx->CPSR = SSP_InitStruct->SSP_CPSDVSR;
000002  884b              LDRH     r3,[r1,#2]
000004  6103              STR      r3,[r0,#0x10]
;;;113    
;;;114      /* SSPx CR0 Configuration */
;;;115      tmpreg = (SSP_InitStruct->SSP_SCR << SSP_CR0_SCR_Pos)
000006  890b              LDRH     r3,[r1,#8]
000008  880c              LDRH     r4,[r1,#0]
00000a  eb032304          ADD      r3,r3,r4,LSL #8
00000e  894c              LDRH     r4,[r1,#0xa]
000010  4423              ADD      r3,r3,r4
000012  898c              LDRH     r4,[r1,#0xc]
000014  4423              ADD      r3,r3,r4
000016  88cc              LDRH     r4,[r1,#6]
000018  191a              ADDS     r2,r3,r4
;;;116             + SSP_InitStruct->SSP_SPH
;;;117             + SSP_InitStruct->SSP_SPO
;;;118             + SSP_InitStruct->SSP_FRF
;;;119             + SSP_InitStruct->SSP_WordLength;
;;;120      SSPx->CR0 = tmpreg;
00001a  6002              STR      r2,[r0,#0]
;;;121    
;;;122      /* SSPx CR1 Configuration */
;;;123      tmpreg = SSP_InitStruct->SSP_HardwareFlowControl + SSP_InitStruct->SSP_Mode;
00001c  89cb              LDRH     r3,[r1,#0xe]
00001e  888c              LDRH     r4,[r1,#4]
000020  191a              ADDS     r2,r3,r4
;;;124      SSPx->CR1 = tmpreg;
000022  6042              STR      r2,[r0,#4]
;;;125    }
000024  bd10              POP      {r4,pc}
;;;126    
                          ENDP


                          AREA ||i.SSP_ReceiveData||, CODE, READONLY, ALIGN=1

                  SSP_ReceiveData PROC
;;;354      */
;;;355    uint16_t SSP_ReceiveData(MDR_SSP_TypeDef* SSPx)
000000  4601              MOV      r1,r0
;;;356    {
;;;357      /* Check the parameters */
;;;358      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;359    
;;;360      /* Receive Data */
;;;361      return ((uint16_t)(SSPx->DR));
000002  6888              LDR      r0,[r1,#8]
000004  b280              UXTH     r0,r0
;;;362    }
000006  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i.SSP_SendData||, CODE, READONLY, ALIGN=1

                  SSP_SendData PROC
;;;337      */
;;;338    void SSP_SendData(MDR_SSP_TypeDef* SSPx, uint16_t Data)
000000  6081              STR      r1,[r0,#8]
;;;339    {
;;;340      /* Check the parameters */
;;;341      assert_param(IS_SSP_ALL_PERIPH(SSPx));
;;;342    
;;;343      /* Transmit Data */
;;;344      SSPx->DR = Data;
;;;345    
;;;346    }
000002  4770              BX       lr
;;;347    
                          ENDP


                          AREA ||i.SSP_StructInit||, CODE, READONLY, ALIGN=1

                  SSP_StructInit PROC
;;;132      */
;;;133    void SSP_StructInit(SSP_InitTypeDef* SSP_InitStruct)
000000  2100              MOVS     r1,#0
;;;134    {
;;;135      /* SSP_InitStruct members default value */
;;;136      /* Initialize the SPI_Mode member */
;;;137      SSP_InitStruct->SSP_Mode = SSP_ModeMaster;
000002  8081              STRH     r1,[r0,#4]
;;;138      /* initialize the SSP_WordLength member */
;;;139      SSP_InitStruct->SSP_WordLength = SSP_WordLength8b;
000004  2107              MOVS     r1,#7
000006  80c1              STRH     r1,[r0,#6]
;;;140      /* Initialize the SSP_SPO member */
;;;141      SSP_InitStruct->SSP_SPO = SSP_SPO_Low;
000008  2100              MOVS     r1,#0
00000a  8141              STRH     r1,[r0,#0xa]
;;;142      /* Initialize the SSP_SPH member */
;;;143      SSP_InitStruct->SSP_SPH = SSP_SPH_1Edge;
00000c  8101              STRH     r1,[r0,#8]
;;;144      /* Initialize the SSP_FRF member */
;;;145      SSP_InitStruct->SSP_FRF = SSP_FRF_SPI_Motorola;
00000e  8181              STRH     r1,[r0,#0xc]
;;;146      /* Initialize the SSP max speed */
;;;147      SSP_InitStruct->SSP_CPSDVSR = 2;
000010  2102              MOVS     r1,#2
000012  8041              STRH     r1,[r0,#2]
;;;148      SSP_InitStruct->SSP_SCR = 0;
000014  2100              MOVS     r1,#0
000016  8001              STRH     r1,[r0,#0]
;;;149    
;;;150    }
000018  4770              BX       lr
;;;151    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_ssp.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH|
#line 462
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_MDR32F9Qx_ssp_c_f8d46607____RRX|
#line 649
|__asm___15_MDR32F9Qx_ssp_c_f8d46607____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
