; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_uart.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_uart.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_uart.c]
                          THUMB

                          AREA ||i.UART_BRGInit||, CODE, READONLY, ALIGN=2

                  UART_BRGInit PROC
;;;618      */
;;;619    void UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG)
000000  4602              MOV      r2,r0
;;;620    {
;;;621      uint32_t tmpreg;
;;;622    
;;;623      /* Check the parameters */
;;;624      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;625      assert_param(IS_UART_CLOCK_BRG(UART_BRG));
;;;626    
;;;627    
;;;628    #if defined (USE_MDR1986VE3)
;;;629      if((UARTx == MDR_UART3) || (UARTx == MDR_UART4))
;;;630    	  tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;631      else
;;;632    #endif
;;;633      tmpreg = MDR_RST_CLK->UART_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6a98              LDR      r0,[r3,#0x28]
;;;634    
;;;635    
;;;636      if (UARTx == MDR_UART1)
000006  4b0b              LDR      r3,|L1.52|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;637      {
;;;638        tmpreg |= RST_CLK_UART_CLOCK_UART1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;639        tmpreg &= ~RST_CLK_UART_CLOCK_UART1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;640        tmpreg |= UART_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;641      }
;;;642      else if (UARTx == MDR_UART2)
000018  4b07              LDR      r3,|L1.56|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;643      {
;;;644        tmpreg |= RST_CLK_UART_CLOCK_UART2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;645        tmpreg &= ~RST_CLK_UART_CLOCK_UART2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;646        tmpreg |= (UART_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;647      }
;;;648    #if defined (USE_MDR1901VC1T)
;;;649      else if( UARTx == MDR_UART3)
;;;650      {
;;;651    	  tmpreg |= RST_CLK_UART_CLOCK_UART3_CLK_EN;
;;;652    	  tmpreg &= ~ RST_CLK_UART_CLOCK_UART3_BRG_Msk;
;;;653    	  tmpreg |= (UART_BRG << RST_CLK_UART_CLOCK_UART3_BRG_Pos);
;;;654      }
;;;655    #endif
;;;656    #if defined (USE_MDR1986VE3)
;;;657      else if(UARTx == MDR_UART3)
;;;658      {
;;;659    	  tmpreg |= RST_CLK_UART_SSP_CLOCK_UART3_CLK_EN;
;;;660    	  tmpreg &= ~RST_CLK_UART_SSP_CLOCK_UART3_BRG_Msk;
;;;661    	  tmpreg |= (UART_BRG << RST_CLK_UART_SSP_CLOCK_UART3_BRG_Pos);
;;;662      }
;;;663      else if(UARTx == MDR_UART4)
;;;664      {
;;;665    	  tmpreg |= RST_CLK_UART_SSP_CLOCK_UART4_CLK_EN;
;;;666    	  tmpreg &= ~RST_CLK_UART_SSP_CLOCK_UART4_BRG_Msk;
;;;667    	  tmpreg |= (UART_BRG << RST_CLK_UART_SSP_CLOCK_UART4_BRG_Pos);
;;;668      }
;;;669    #endif
;;;670    
;;;671    #if defined (USE_MDR1986VE3)
;;;672      if((UARTx == MDR_UART3) || (UARTx == MDR_UART4))
;;;673    	  MDR_RST_CLK->UART_SSP_CLOCK = tmpreg;
;;;674      else
;;;675    #endif
;;;676      MDR_RST_CLK->UART_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  6298              STR      r0,[r3,#0x28]
;;;677    }
00002e  4770              BX       lr
;;;678    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40030000
                  |L1.56|
                          DCD      0x40038000

                          AREA ||i.UART_BreakLine||, CODE, READONLY, ALIGN=1

                  UART_BreakLine PROC
;;;488      */
;;;489    void UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;490    {
;;;491      /* Check the parameters */
;;;492      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;493      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;494    
;;;495      if (NewState != DISABLE)
;;;496      {
;;;497        /* Set BRK bit in the UART LCR_H register */
;;;498        UARTx->LCR_H |= LCR_H_BRK_Set;
000002  6ac2              LDR      r2,[r0,#0x2c]
000004  f0420201          ORR      r2,r2,#1
000008  62c2              STR      r2,[r0,#0x2c]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;499      }
;;;500      else
;;;501      {
;;;502        /* Reset BRK bit in the UART LCR_H register */
;;;503        UARTx->LCR_H |= LCR_H_BRK_Reset;
00000c  6ac2              LDR      r2,[r0,#0x2c]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  431a              ORRS     r2,r2,r3
000014  62c2              STR      r2,[r0,#0x2c]
                  |L2.22|
;;;504      }
;;;505    }
000016  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.UART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  UART_ClearITPendingBit PROC
;;;369      */
;;;370    void UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  6c42              LDR      r2,[r0,#0x44]
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;374      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;375    
;;;376      UARTx->ICR |= UART_IT;
000002  430a              ORRS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;377    }
000006  4770              BX       lr
;;;378    
                          ENDP


                          AREA ||i.UART_Cmd||, CODE, READONLY, ALIGN=1

                  UART_Cmd PROC
;;;212      */
;;;213    void UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;214    {
;;;215      /* Check the parameters */
;;;216      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;217      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;218    
;;;219      if (NewState != DISABLE)
;;;220      {
;;;221        /* Enable the selected UART by setting the UARTEN bit in the CR register */
;;;222        UARTx->CR |= CR_EN_Set;
000002  6b02              LDR      r2,[r0,#0x30]
000004  f0420201          ORR      r2,r2,#1
000008  6302              STR      r2,[r0,#0x30]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;223      }
;;;224      else
;;;225      {
;;;226        /* Disable the selected UART by clearing the UARTEN bit in the CR register */
;;;227        UARTx->CR &= CR_EN_Reset;
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6302              STR      r2,[r0,#0x30]
                  |L4.22|
;;;228      }
;;;229    }
000016  4770              BX       lr
;;;230    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;424      */
;;;425    void UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;426    {
;;;427      /* Check the parameters */
;;;428      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;429      assert_param(IS_UART_DMAREQ(UART_DMAReq));
;;;430      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;431    
;;;432      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L5.12|
;;;433      {
;;;434        /* Enable the DMA transfer for selected requests and DMAONERR bit
;;;435           in the UART DMACR register */
;;;436        UARTx->DMACR |= UART_DMAReq;
000004  6c83              LDR      r3,[r0,#0x48]
000006  430b              ORRS     r3,r3,r1
000008  6483              STR      r3,[r0,#0x48]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;437      }
;;;438      else
;;;439      {
;;;440        /* Disable the DMA transfer for selected requests and DMAONERR bit
;;;441           in the UART DMACR register */
;;;442        UARTx->DMACR &= (uint16_t)~UART_DMAReq;
00000c  6c83              LDR      r3,[r0,#0x48]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  6483              STR      r3,[r0,#0x48]
                  |L5.22|
;;;443      }
;;;444    }
000016  bd10              POP      {r4,pc}
;;;445    
                          ENDP


                          AREA ||i.UART_DMAConfig||, CODE, READONLY, ALIGN=1

                  UART_DMAConfig PROC
;;;399      */
;;;400    void UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL)
000000  ea4203c1          ORR      r3,r2,r1,LSL #3
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;404      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_RB_LVL));
;;;405      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_TB_LVL));
;;;406    
;;;407      UARTx->IFLS = (UART_IT_RB_LVL << 3) | UART_IT_TB_LVL;
000004  6343              STR      r3,[r0,#0x34]
;;;408    }
000006  4770              BX       lr
;;;409    
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=1

                  UART_DeInit PROC
;;;68       */
;;;69     void UART_DeInit(MDR_UART_TypeDef* UARTx)
000000  2100              MOVS     r1,#0
;;;70     {
;;;71       /* Check the parameters */
;;;72       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;73     
;;;74       /* Clear UART CR */
;;;75       UARTx->CR = 0;
000002  6301              STR      r1,[r0,#0x30]
;;;76       UARTx->LCR_H = 0;
000004  62c1              STR      r1,[r0,#0x2c]
;;;77       UARTx->RSR_ECR = 0;
000006  6041              STR      r1,[r0,#4]
;;;78       UARTx->FR = UART_FLAG_TXFE | UART_FLAG_RXFE;
000008  2190              MOVS     r1,#0x90
00000a  6181              STR      r1,[r0,#0x18]
;;;79       UARTx->ILPR = 0;
00000c  2100              MOVS     r1,#0
00000e  6201              STR      r1,[r0,#0x20]
;;;80       UARTx->IBRD = 0;
000010  6241              STR      r1,[r0,#0x24]
;;;81       UARTx->FBRD = 0;
000012  6281              STR      r1,[r0,#0x28]
;;;82       UARTx->IFLS = UART_IT_FIFO_LVL_8words;
000014  2102              MOVS     r1,#2
000016  6341              STR      r1,[r0,#0x34]
;;;83       UARTx->IMSC = 0;
000018  2100              MOVS     r1,#0
00001a  6381              STR      r1,[r0,#0x38]
;;;84       UARTx->DMACR = 0;
00001c  6481              STR      r1,[r0,#0x48]
;;;85       /* Set UART CR[RXE] and UART CR[TXE] bits */
;;;86       UARTx->CR = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
00001e  f44f7140          MOV      r1,#0x300
000022  6301              STR      r1,[r0,#0x30]
;;;87     }
000024  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;581      */
;;;582    FlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG)
000000  4602              MOV      r2,r0
;;;583    {
;;;584      FlagStatus bitstatus;
;;;585    
;;;586      /* Check the parameters */
;;;587      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;588      assert_param(IS_UART_FLAG(UART_FLAG));
;;;589    
;;;590      if (UARTx->FR & UART_FLAG)
000002  6993              LDR      r3,[r2,#0x18]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L8.12|
;;;591      {
;;;592        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L8.14|
                  |L8.12|
;;;593      }
;;;594      else
;;;595      {
;;;596        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;597      }
;;;598      return bitstatus;
;;;599    }
00000e  4770              BX       lr
;;;600    
                          ENDP


                          AREA ||i.UART_GetITStatus||, CODE, READONLY, ALIGN=1

                  UART_GetITStatus PROC
;;;289      */
;;;290    ITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  4602              MOV      r2,r0
;;;291    {
;;;292      ITStatus bitstatus;
;;;293    
;;;294      /* Check the parameters */
;;;295      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;296      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;297    
;;;298      if ((UARTx->RIS & UART_IT) == UART_IT)
000002  6bd3              LDR      r3,[r2,#0x3c]
000004  400b              ANDS     r3,r3,r1
000006  428b              CMP      r3,r1
000008  d101              BNE      |L9.14|
;;;299      {
;;;300        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L9.16|
                  |L9.14|
;;;301      }
;;;302      else
;;;303      {
;;;304        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;305      }
;;;306    
;;;307      return bitstatus;
;;;308    }
000010  4770              BX       lr
;;;309    
                          ENDP


                          AREA ||i.UART_GetITStatusMasked||, CODE, READONLY, ALIGN=1

                  UART_GetITStatusMasked PROC
;;;329      */
;;;330    ITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  4602              MOV      r2,r0
;;;331    {
;;;332      ITStatus bitstatus;
;;;333    
;;;334      /* Check the parameters */
;;;335      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;336      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;337    
;;;338      if (UARTx->MIS & UART_IT)
000002  6c13              LDR      r3,[r2,#0x40]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L10.12|
;;;339      {
;;;340        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L10.14|
                  |L10.12|
;;;341      }
;;;342      else
;;;343      {
;;;344        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;345      }
;;;346    
;;;347      return bitstatus;
;;;348    }
00000e  4770              BX       lr
;;;349    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;252      */
;;;253    void UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L11.10|
;;;254    {
;;;255      /* Check the parameters */
;;;256      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;257      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;258      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;259    
;;;260      if (NewState != DISABLE)
;;;261      {
;;;262        UARTx->IMSC |= UART_IT;
000002  6b83              LDR      r3,[r0,#0x38]
000004  430b              ORRS     r3,r3,r1
000006  6383              STR      r3,[r0,#0x38]
000008  e002              B        |L11.16|
                  |L11.10|
;;;263      }
;;;264      else
;;;265      {
;;;266        UARTx->IMSC &= ~UART_IT;
00000a  6b83              LDR      r3,[r0,#0x38]
00000c  438b              BICS     r3,r3,r1
00000e  6383              STR      r3,[r0,#0x38]
                  |L11.16|
;;;267      }
;;;268    }
000010  4770              BX       lr
;;;269    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;98       */
;;;99     BaudRateStatus UART_Init ( MDR_UART_TypeDef* UARTx,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;100    						   UART_InitTypeDef* UART_InitStruct )
;;;101    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;102    	uint32_t tmpreg, cpuclock;
;;;103    	uint32_t realspeed, speederror;
;;;104    	uint32_t divider;
;;;105    	uint32_t integerdivider;
;;;106    	uint32_t fractionaldivider;
;;;107    	RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;108    
;;;109    	/* Check the parameters */
;;;110    	assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;111    	assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
;;;112    	assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;113    	assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;114    	assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;115    	assert_param(IS_UART_FIFOMODE(UART_InitStruct->UART_FIFOMode));
;;;116    	assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;117    
;;;118    	/* Configure the UART Baud Rate */
;;;119    	RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;120    	cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000010  9f01              LDR      r7,[sp,#4]
;;;121    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;122    	if(( UARTx == MDR_UART3 ) || (UARTx == MDR_UART4))
;;;123    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;124    	else
;;;125    		if(( UARTx == MDR_UART1 ) || (UARTx == MDR_UART2))
;;;126    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;127    			tmpreg = MDR_RST_CLK->UART_CLOCK;
000012  4824              LDR      r0,|L12.164|
000014  6a86              LDR      r6,[r0,#0x28]
;;;128    
;;;129    	if (UARTx == MDR_UART1) {
000016  4824              LDR      r0,|L12.168|
000018  4284              CMP      r4,r0
00001a  d106              BNE      |L12.42|
;;;130    		cpuclock /= (1 << (tmpreg & UART1_BRG_Mask));
00001c  f0060107          AND      r1,r6,#7
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  fbb7f7f0          UDIV     r7,r7,r0
000028  e008              B        |L12.60|
                  |L12.42|
;;;131    	}
;;;132    	else
;;;133    		if (UARTx == MDR_UART2) {
00002a  4820              LDR      r0,|L12.172|
00002c  4284              CMP      r4,r0
00002e  d105              BNE      |L12.60|
;;;134    			cpuclock /= (1 << ((tmpreg & UART2_BRG_Mask) >> UART2_BRG_Offs));
000030  f3c62102          UBFX     r1,r6,#8,#3
000034  2001              MOVS     r0,#1
000036  4088              LSLS     r0,r0,r1
000038  fbb7f7f0          UDIV     r7,r7,r0
                  |L12.60|
;;;135    		}
;;;136    #if defined (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
;;;137    		else
;;;138    			if(UARTx == MDR_UART3) {
;;;139    				cpuclock /= (1 << ((tmpreg & UART3_BRG_Mask ) >> UART3_BRG_Offs));
;;;140    			}
;;;141    #endif
;;;142    #if defined (USE_MDR1986VE3)
;;;143    			else
;;;144    				if(UARTx == MDR_UART4) {
;;;145    					cpuclock /= (1 << ((tmpreg & UART4_BRG_Mask) >> UART4_BRG_Offs));
;;;146    				}
;;;147    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;148    
;;;149    	/* Determine the integer part */
;;;150    	divider = cpuclock / (UART_InitStruct->UART_BaudRate >> 2);
00003c  6828              LDR      r0,[r5,#0]
00003e  0880              LSRS     r0,r0,#2
000040  fbb7f9f0          UDIV     r9,r7,r0
;;;151    	integerdivider = divider >> 6;
000044  ea4f1899          LSR      r8,r9,#6
;;;152    	/* Determine the fractional part */
;;;153    	fractionaldivider = (divider & FBRD_Fract_Mask);
000048  f0090a3f          AND      r10,r9,#0x3f
;;;154    	/* Determine the speed error */
;;;155    	realspeed = (cpuclock * 4) / ((integerdivider * 64) + fractionaldivider);
00004c  00b8              LSLS     r0,r7,#2
00004e  eb0a1188          ADD      r1,r10,r8,LSL #6
000052  fbb0fbf1          UDIV     r11,r0,r1
;;;156    	speederror = ((realspeed - UART_InitStruct->UART_BaudRate) * 128)
000056  6828              LDR      r0,[r5,#0]
000058  ebab0000          SUB      r0,r11,r0
00005c  01c0              LSLS     r0,r0,#7
00005e  6829              LDR      r1,[r5,#0]
000060  fbb0f0f1          UDIV     r0,r0,r1
000064  9006              STR      r0,[sp,#0x18]
;;;157    			/ UART_InitStruct->UART_BaudRate;
;;;158    	if (speederror > 2) {
000066  9806              LDR      r0,[sp,#0x18]
000068  2802              CMP      r0,#2
00006a  d903              BLS      |L12.116|
;;;159    		return BaudRateInvalid;
00006c  2000              MOVS     r0,#0
                  |L12.110|
;;;160    	}
;;;161    	/* Write UART Baud Rate */
;;;162    	UARTx->IBRD = integerdivider;
;;;163    	UARTx->FBRD = fractionaldivider;
;;;164    
;;;165    	/* UART LCR_H configuration */
;;;166    	/* Set the WLEN bits according to UART_WordLength value */
;;;167    	/* Set STP2 bit according to UART_StopBits value */
;;;168    	/* Set PEN, EPS and SPS bits according to UART_Parity value */
;;;169    	/* Set FEN bit according to UART_FIFOMode value */
;;;170    	tmpreg = UARTx->LCR_H;
;;;171    	tmpreg |= UART_InitStruct->UART_WordLength | UART_InitStruct->UART_StopBits
;;;172    			| UART_InitStruct->UART_Parity | UART_InitStruct->UART_FIFOMode;
;;;173    	UARTx->LCR_H = tmpreg;
;;;174    
;;;175    	/* UART CR configuration */
;;;176    	tmpreg = UARTx->CR;
;;;177    	/* Clear UART CR Flow control bits */
;;;178    	tmpreg &= ~CR_FC_Mask;
;;;179    	/* Set UART CR Flow control bits */
;;;180    	tmpreg |= UART_InitStruct->UART_HardwareFlowControl;
;;;181    	/* Write to UART CR */
;;;182    	UARTx->CR = tmpreg;
;;;183    
;;;184    	return BaudRateValid;
;;;185    }
00006e  b007              ADD      sp,sp,#0x1c
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.116|
000074  f8c48024          STR      r8,[r4,#0x24]         ;162
000078  f8c4a028          STR      r10,[r4,#0x28]        ;163
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;170
00007e  88a8              LDRH     r0,[r5,#4]            ;171
000080  88e9              LDRH     r1,[r5,#6]            ;171
000082  4308              ORRS     r0,r0,r1              ;171
000084  8929              LDRH     r1,[r5,#8]            ;171
000086  4308              ORRS     r0,r0,r1              ;171
000088  8969              LDRH     r1,[r5,#0xa]          ;171
00008a  4308              ORRS     r0,r0,r1              ;171
00008c  4306              ORRS     r6,r6,r0              ;171
00008e  62e6              STR      r6,[r4,#0x2c]         ;173
000090  6b26              LDR      r6,[r4,#0x30]         ;176
000092  f64f7080          MOV      r0,#0xff80            ;178
000096  4386              BICS     r6,r6,r0              ;178
000098  89a8              LDRH     r0,[r5,#0xc]          ;180
00009a  4306              ORRS     r6,r6,r0              ;180
00009c  6326              STR      r6,[r4,#0x30]         ;182
00009e  2001              MOVS     r0,#1                 ;184
0000a0  e7e5              B        |L12.110|
;;;186    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L12.164|
                          DCD      0x40020000
                  |L12.168|
                          DCD      0x40030000
                  |L12.172|
                          DCD      0x40038000

                          AREA ||i.UART_IrDACmd||, CODE, READONLY, ALIGN=1

                  UART_IrDACmd PROC
;;;545      */
;;;546    void UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;547    {
;;;548      /* Check the parameters */
;;;549      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;550      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;551    
;;;552      if (NewState != DISABLE)
;;;553      {
;;;554        /* Set SIREN bit in the UART CR register */
;;;555        UARTx->CR |= CR_SIREN_Set;
000002  6b02              LDR      r2,[r0,#0x30]
000004  f0420202          ORR      r2,r2,#2
000008  6302              STR      r2,[r0,#0x30]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;556      }
;;;557      else
;;;558      {
;;;559        /* Reset SIREN bit in the UART CR register */
;;;560        UARTx->CR |= CR_SIREN_Reset;
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  431a              ORRS     r2,r2,r3
000014  6302              STR      r2,[r0,#0x30]
                  |L13.22|
;;;561      }
;;;562    }
000016  4770              BX       lr
;;;563    
                          ENDP


                          AREA ||i.UART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  UART_IrDAConfig PROC
;;;517      */
;;;518    void UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode)
000000  b570              PUSH     {r4-r6,lr}
;;;519    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;520      uint32_t cpuclock;
;;;521      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;522    
;;;523      /* Check the parameters */
;;;524      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;525      assert_param(IS_UART_IRDA_MODE(UART_IrDAMode));
;;;526    
;;;527      if (UART_IrDAMode == UART_IrDAMode_LowPower)
000008  2d04              CMP      r5,#4
00000a  d108              BNE      |L14.30|
;;;528      {
;;;529        /* Configure the UART ILPR */
;;;530        RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;531        cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000012  9e01              LDR      r6,[sp,#4]
;;;532        UARTx->ILPR = cpuclock / IrLPBaud16;
000014  f44f10e1          MOV      r0,#0x1c2000
000018  fbb6f0f0          UDIV     r0,r6,r0
00001c  6220              STR      r0,[r4,#0x20]
                  |L14.30|
;;;533      }
;;;534      UARTx->CR |= UART_IrDAMode;
00001e  6b20              LDR      r0,[r4,#0x30]
000020  4328              ORRS     r0,r0,r5
000022  6320              STR      r0,[r4,#0x30]
;;;535    }
000024  b006              ADD      sp,sp,#0x18
000026  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP


                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;470      */
;;;471    uint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx)
000000  4601              MOV      r1,r0
;;;472    {
;;;473      /* Check the parameters */
;;;474      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;475    
;;;476      /* Receive Data */
;;;477      return (uint16_t)(UARTx->DR);
000002  6808              LDR      r0,[r1,#0]
000004  b280              UXTH     r0,r0
;;;478    }
000006  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;453      */
;;;454    void UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data)
000000  b2ca              UXTB     r2,r1
;;;455    {
;;;456      /* Check the parameters */
;;;457      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;458      assert_param(IS_UART_DATA(Data));
;;;459    
;;;460      /* Transmit Data */
;;;461      UARTx->DR = (Data & (uint16_t)0x0FF);
000002  6002              STR      r2,[r0,#0]
;;;462    }
000004  4770              BX       lr
;;;463    
                          ENDP


                          AREA ||i.UART_StructInit||, CODE, READONLY, ALIGN=1

                  UART_StructInit PROC
;;;192      */
;;;193    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;194    {
;;;195      /* UART_InitStruct members default value */
;;;196      UART_InitStruct->UART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;197      UART_InitStruct->UART_WordLength = UART_WordLength5b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;198      UART_InitStruct->UART_StopBits = UART_StopBits1;
00000a  80c1              STRH     r1,[r0,#6]
;;;199      UART_InitStruct->UART_Parity = UART_Parity_No;
00000c  8101              STRH     r1,[r0,#8]
;;;200      UART_InitStruct->UART_FIFOMode = UART_FIFO_OFF;
00000e  8141              STRH     r1,[r0,#0xa]
;;;201      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
000010  f44f7140          MOV      r1,#0x300
000014  8181              STRH     r1,[r0,#0xc]
;;;202    }
000016  4770              BX       lr
;;;203    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH|
#line 482
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____RRX|
#line 669
|__asm___16_MDR32F9Qx_uart_c_c95a8597____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
