; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_uart.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_uart.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_uart.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_uart.c]
                          THUMB

                          AREA ||i.UART_BRGInit||, CODE, READONLY, ALIGN=2

                  UART_BRGInit PROC
;;;637      */
;;;638    void UART_BRGInit(MDR_UART_TypeDef* UARTx, uint32_t UART_BRG)
000000  4602              MOV      r2,r0
;;;639    {
;;;640      uint32_t tmpreg;
;;;641    
;;;642      /* Check the parameters */
;;;643      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;644      assert_param(IS_UART_CLOCK_BRG(UART_BRG));
;;;645    
;;;646    
;;;647    #if defined (USE_MDR1986VE3)
;;;648      if((UARTx == MDR_UART3) || (UARTx == MDR_UART4))
;;;649    	  tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;650      else
;;;651    #endif
;;;652      tmpreg = MDR_RST_CLK->UART_CLOCK;
000002  4b0b              LDR      r3,|L1.48|
000004  6a98              LDR      r0,[r3,#0x28]
;;;653    
;;;654    
;;;655      if (UARTx == MDR_UART1)
000006  4b0b              LDR      r3,|L1.52|
000008  429a              CMP      r2,r3
00000a  d105              BNE      |L1.24|
;;;656      {
;;;657        tmpreg |= RST_CLK_UART_CLOCK_UART1_CLK_EN;
00000c  f0407080          ORR      r0,r0,#0x1000000
;;;658        tmpreg &= ~RST_CLK_UART_CLOCK_UART1_BRG_Msk;
000010  f02000ff          BIC      r0,r0,#0xff
;;;659        tmpreg |= UART_BRG;
000014  4308              ORRS     r0,r0,r1
000016  e008              B        |L1.42|
                  |L1.24|
;;;660      }
;;;661      else if (UARTx == MDR_UART2)
000018  4b07              LDR      r3,|L1.56|
00001a  429a              CMP      r2,r3
00001c  d105              BNE      |L1.42|
;;;662      {
;;;663        tmpreg |= RST_CLK_UART_CLOCK_UART2_CLK_EN;
00001e  f0407000          ORR      r0,r0,#0x2000000
;;;664        tmpreg &= ~RST_CLK_UART_CLOCK_UART2_BRG_Msk;
000022  f420407f          BIC      r0,r0,#0xff00
;;;665        tmpreg |= (UART_BRG << 8);
000026  ea402001          ORR      r0,r0,r1,LSL #8
                  |L1.42|
;;;666      }
;;;667    #if defined (USE_MDR1901VC1T)
;;;668      else if( UARTx == MDR_UART3)
;;;669      {
;;;670    	  tmpreg |= RST_CLK_UART_CLOCK_UART3_CLK_EN;
;;;671    	  tmpreg &= ~ RST_CLK_UART_CLOCK_UART3_BRG_Msk;
;;;672    	  tmpreg |= (UART_BRG << RST_CLK_UART_CLOCK_UART3_BRG_Pos);
;;;673      }
;;;674    #endif
;;;675    #if defined (USE_MDR1986VE3)
;;;676      else if(UARTx == MDR_UART3)
;;;677      {
;;;678    	  tmpreg |= RST_CLK_UART_SSP_CLOCK_UART3_CLK_EN;
;;;679    	  tmpreg &= ~RST_CLK_UART_SSP_CLOCK_UART3_BRG_Msk;
;;;680    	  tmpreg |= (UART_BRG << RST_CLK_UART_SSP_CLOCK_UART3_BRG_Pos);
;;;681      }
;;;682      else if(UARTx == MDR_UART4)
;;;683      {
;;;684    	  tmpreg |= RST_CLK_UART_SSP_CLOCK_UART4_CLK_EN;
;;;685    	  tmpreg &= ~RST_CLK_UART_SSP_CLOCK_UART4_BRG_Msk;
;;;686    	  tmpreg |= (UART_BRG << RST_CLK_UART_SSP_CLOCK_UART4_BRG_Pos);
;;;687      }
;;;688    #endif
;;;689    
;;;690    #if defined (USE_MDR1986VE3)
;;;691      if((UARTx == MDR_UART3) || (UARTx == MDR_UART4))
;;;692    	  MDR_RST_CLK->UART_SSP_CLOCK = tmpreg;
;;;693      else
;;;694    #endif
;;;695      MDR_RST_CLK->UART_CLOCK = tmpreg;
00002a  4b01              LDR      r3,|L1.48|
00002c  6298              STR      r0,[r3,#0x28]
;;;696    }
00002e  4770              BX       lr
;;;697    
                          ENDP

                  |L1.48|
                          DCD      0x40020000
                  |L1.52|
                          DCD      0x40030000
                  |L1.56|
                          DCD      0x40038000

                          AREA ||i.UART_BreakLine||, CODE, READONLY, ALIGN=1

                  UART_BreakLine PROC
;;;507      */
;;;508    void UART_BreakLine(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L2.12|
;;;509    {
;;;510      /* Check the parameters */
;;;511      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;512      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;513    
;;;514      if (NewState != DISABLE)
;;;515      {
;;;516        /* Set BRK bit in the UART LCR_H register */
;;;517        UARTx->LCR_H |= LCR_H_BRK_Set;
000002  6ac2              LDR      r2,[r0,#0x2c]
000004  f0420201          ORR      r2,r2,#1
000008  62c2              STR      r2,[r0,#0x2c]
00000a  e004              B        |L2.22|
                  |L2.12|
;;;518      }
;;;519      else
;;;520      {
;;;521        /* Reset BRK bit in the UART LCR_H register */
;;;522        UARTx->LCR_H |= LCR_H_BRK_Reset;
00000c  6ac2              LDR      r2,[r0,#0x2c]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  431a              ORRS     r2,r2,r3
000014  62c2              STR      r2,[r0,#0x2c]
                  |L2.22|
;;;523      }
;;;524    }
000016  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.UART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  UART_ClearITPendingBit PROC
;;;388      */
;;;389    void UART_ClearITPendingBit(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  6c42              LDR      r2,[r0,#0x44]
;;;390    {
;;;391      /* Check the parameters */
;;;392      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;393      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;394    
;;;395      UARTx->ICR |= UART_IT;
000002  430a              ORRS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;396    }
000006  4770              BX       lr
;;;397    
                          ENDP


                          AREA ||i.UART_Cmd||, CODE, READONLY, ALIGN=1

                  UART_Cmd PROC
;;;231      */
;;;232    void UART_Cmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L4.12|
;;;233    {
;;;234      /* Check the parameters */
;;;235      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;236      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;237    
;;;238      if (NewState != DISABLE)
;;;239      {
;;;240        /* Enable the selected UART by setting the UARTEN bit in the CR register */
;;;241        UARTx->CR |= CR_EN_Set;
000002  6b02              LDR      r2,[r0,#0x30]
000004  f0420201          ORR      r2,r2,#1
000008  6302              STR      r2,[r0,#0x30]
00000a  e004              B        |L4.22|
                  |L4.12|
;;;242      }
;;;243      else
;;;244      {
;;;245        /* Disable the selected UART by clearing the UARTEN bit in the CR register */
;;;246        UARTx->CR &= CR_EN_Reset;
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  f64f73fe          MOV      r3,#0xfffe
000012  401a              ANDS     r2,r2,r3
000014  6302              STR      r2,[r0,#0x30]
                  |L4.22|
;;;247      }
;;;248    }
000016  4770              BX       lr
;;;249    
                          ENDP


                          AREA ||i.UART_DMACmd||, CODE, READONLY, ALIGN=1

                  UART_DMACmd PROC
;;;443      */
;;;444    void UART_DMACmd(MDR_UART_TypeDef* UARTx, uint32_t UART_DMAReq, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;445    {
;;;446      /* Check the parameters */
;;;447      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;448      assert_param(IS_UART_DMAREQ(UART_DMAReq));
;;;449      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;450    
;;;451      if (NewState != DISABLE)
000002  b11a              CBZ      r2,|L5.12|
;;;452      {
;;;453        /* Enable the DMA transfer for selected requests and DMAONERR bit
;;;454           in the UART DMACR register */
;;;455        UARTx->DMACR |= UART_DMAReq;
000004  6c83              LDR      r3,[r0,#0x48]
000006  430b              ORRS     r3,r3,r1
000008  6483              STR      r3,[r0,#0x48]
00000a  e004              B        |L5.22|
                  |L5.12|
;;;456      }
;;;457      else
;;;458      {
;;;459        /* Disable the DMA transfer for selected requests and DMAONERR bit
;;;460           in the UART DMACR register */
;;;461        UARTx->DMACR &= (uint16_t)~UART_DMAReq;
00000c  6c83              LDR      r3,[r0,#0x48]
00000e  43cc              MVNS     r4,r1
000010  b2a4              UXTH     r4,r4
000012  4023              ANDS     r3,r3,r4
000014  6483              STR      r3,[r0,#0x48]
                  |L5.22|
;;;462      }
;;;463    }
000016  bd10              POP      {r4,pc}
;;;464    
                          ENDP


                          AREA ||i.UART_DMAConfig||, CODE, READONLY, ALIGN=1

                  UART_DMAConfig PROC
;;;418      */
;;;419    void UART_DMAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT_RB_LVL, uint32_t UART_IT_TB_LVL)
000000  ea4203c1          ORR      r3,r2,r1,LSL #3
;;;420    {
;;;421      /* Check the parameters */
;;;422      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;423      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_RB_LVL));
;;;424      assert_param(IS_UART_IT_FIFO_LVL(UART_IT_TB_LVL));
;;;425    
;;;426      UARTx->IFLS = (UART_IT_RB_LVL << 3) | UART_IT_TB_LVL;
000004  6343              STR      r3,[r0,#0x34]
;;;427    }
000006  4770              BX       lr
;;;428    
                          ENDP


                          AREA ||i.UART_DeInit||, CODE, READONLY, ALIGN=1

                  UART_DeInit PROC
;;;87       */
;;;88     void UART_DeInit(MDR_UART_TypeDef* UARTx)
000000  2100              MOVS     r1,#0
;;;89     {
;;;90       /* Check the parameters */
;;;91       assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;92     
;;;93       /* Clear UART CR */
;;;94       UARTx->CR = 0;
000002  6301              STR      r1,[r0,#0x30]
;;;95       UARTx->LCR_H = 0;
000004  62c1              STR      r1,[r0,#0x2c]
;;;96       UARTx->RSR_ECR = 0;
000006  6041              STR      r1,[r0,#4]
;;;97       UARTx->FR = UART_FLAG_TXFE | UART_FLAG_RXFE;
000008  2190              MOVS     r1,#0x90
00000a  6181              STR      r1,[r0,#0x18]
;;;98       UARTx->ILPR = 0;
00000c  2100              MOVS     r1,#0
00000e  6201              STR      r1,[r0,#0x20]
;;;99       UARTx->IBRD = 0;
000010  6241              STR      r1,[r0,#0x24]
;;;100      UARTx->FBRD = 0;
000012  6281              STR      r1,[r0,#0x28]
;;;101      UARTx->IFLS = UART_IT_FIFO_LVL_8words;
000014  2102              MOVS     r1,#2
000016  6341              STR      r1,[r0,#0x34]
;;;102      UARTx->IMSC = 0;
000018  2100              MOVS     r1,#0
00001a  6381              STR      r1,[r0,#0x38]
;;;103      UARTx->DMACR = 0;
00001c  6481              STR      r1,[r0,#0x48]
;;;104      /* Set UART CR[RXE] and UART CR[TXE] bits */
;;;105      UARTx->CR = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
00001e  f44f7140          MOV      r1,#0x300
000022  6301              STR      r1,[r0,#0x30]
;;;106    }
000024  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.UART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  UART_GetFlagStatus PROC
;;;600      */
;;;601    FlagStatus UART_GetFlagStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_FLAG)
000000  4602              MOV      r2,r0
;;;602    {
;;;603      FlagStatus bitstatus;
;;;604    
;;;605      /* Check the parameters */
;;;606      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;607      assert_param(IS_UART_FLAG(UART_FLAG));
;;;608    
;;;609      if (UARTx->FR & UART_FLAG)
000002  6993              LDR      r3,[r2,#0x18]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L8.12|
;;;610      {
;;;611        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L8.14|
                  |L8.12|
;;;612      }
;;;613      else
;;;614      {
;;;615        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;616      }
;;;617      return bitstatus;
;;;618    }
00000e  4770              BX       lr
;;;619    
                          ENDP


                          AREA ||i.UART_GetITStatus||, CODE, READONLY, ALIGN=1

                  UART_GetITStatus PROC
;;;308      */
;;;309    ITStatus UART_GetITStatus(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  4602              MOV      r2,r0
;;;310    {
;;;311      ITStatus bitstatus;
;;;312    
;;;313      /* Check the parameters */
;;;314      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;315      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;316    
;;;317      if ((UARTx->RIS & UART_IT) == UART_IT)
000002  6bd3              LDR      r3,[r2,#0x3c]
000004  400b              ANDS     r3,r3,r1
000006  428b              CMP      r3,r1
000008  d101              BNE      |L9.14|
;;;318      {
;;;319        bitstatus = SET;
00000a  2001              MOVS     r0,#1
00000c  e000              B        |L9.16|
                  |L9.14|
;;;320      }
;;;321      else
;;;322      {
;;;323        bitstatus = RESET;
00000e  2000              MOVS     r0,#0
                  |L9.16|
;;;324      }
;;;325    
;;;326      return bitstatus;
;;;327    }
000010  4770              BX       lr
;;;328    
                          ENDP


                          AREA ||i.UART_GetITStatusMasked||, CODE, READONLY, ALIGN=1

                  UART_GetITStatusMasked PROC
;;;348      */
;;;349    ITStatus UART_GetITStatusMasked(MDR_UART_TypeDef* UARTx, uint32_t UART_IT)
000000  4602              MOV      r2,r0
;;;350    {
;;;351      ITStatus bitstatus;
;;;352    
;;;353      /* Check the parameters */
;;;354      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;355      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;356    
;;;357      if (UARTx->MIS & UART_IT)
000002  6c13              LDR      r3,[r2,#0x40]
000004  400b              ANDS     r3,r3,r1
000006  b10b              CBZ      r3,|L10.12|
;;;358      {
;;;359        bitstatus = SET;
000008  2001              MOVS     r0,#1
00000a  e000              B        |L10.14|
                  |L10.12|
;;;360      }
;;;361      else
;;;362      {
;;;363        bitstatus = RESET;
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;364      }
;;;365    
;;;366      return bitstatus;
;;;367    }
00000e  4770              BX       lr
;;;368    
                          ENDP


                          AREA ||i.UART_ITConfig||, CODE, READONLY, ALIGN=1

                  UART_ITConfig PROC
;;;271      */
;;;272    void UART_ITConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IT, FunctionalState NewState)
000000  b11a              CBZ      r2,|L11.10|
;;;273    {
;;;274      /* Check the parameters */
;;;275      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;276      assert_param(IS_UART_CONFIG_IT(UART_IT));
;;;277      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;278    
;;;279      if (NewState != DISABLE)
;;;280      {
;;;281        UARTx->IMSC |= UART_IT;
000002  6b83              LDR      r3,[r0,#0x38]
000004  430b              ORRS     r3,r3,r1
000006  6383              STR      r3,[r0,#0x38]
000008  e002              B        |L11.16|
                  |L11.10|
;;;282      }
;;;283      else
;;;284      {
;;;285        UARTx->IMSC &= ~UART_IT;
00000a  6b83              LDR      r3,[r0,#0x38]
00000c  438b              BICS     r3,r3,r1
00000e  6383              STR      r3,[r0,#0x38]
                  |L11.16|
;;;286      }
;;;287    }
000010  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.UART_Init||, CODE, READONLY, ALIGN=2

                  UART_Init PROC
;;;117      */
;;;118    BaudRateStatus UART_Init ( MDR_UART_TypeDef* UARTx,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;119    						   UART_InitTypeDef* UART_InitStruct )
;;;120    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
000008  460d              MOV      r5,r1
;;;121    	uint32_t tmpreg, cpuclock;
;;;122    	uint32_t realspeed, speederror;
;;;123    	uint32_t divider;
;;;124    	uint32_t integerdivider;
;;;125    	uint32_t fractionaldivider;
;;;126    	RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;127    
;;;128    	/* Check the parameters */
;;;129    	assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;130    	assert_param(IS_UART_BAUDRATE(UART_InitStruct->UART_BaudRate));
;;;131    	assert_param(IS_UART_WORD_LENGTH(UART_InitStruct->UART_WordLength));
;;;132    	assert_param(IS_UART_STOPBITS(UART_InitStruct->UART_StopBits));
;;;133    	assert_param(IS_UART_PARITY(UART_InitStruct->UART_Parity));
;;;134    	assert_param(IS_UART_FIFOMODE(UART_InitStruct->UART_FIFOMode));
;;;135    	assert_param(IS_UART_HARDWARE_FLOW_CONTROL(UART_InitStruct->UART_HardwareFlowControl));
;;;136    
;;;137    	/* Configure the UART Baud Rate */
;;;138    	RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;139    	cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000010  9f01              LDR      r7,[sp,#4]
;;;140    #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;141    	if(( UARTx == MDR_UART3 ) || (UARTx == MDR_UART4))
;;;142    		tmpreg = MDR_RST_CLK->UART_SSP_CLOCK;
;;;143    	else
;;;144    		if(( UARTx == MDR_UART1 ) || (UARTx == MDR_UART2))
;;;145    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;146    			tmpreg = MDR_RST_CLK->UART_CLOCK;
000012  4824              LDR      r0,|L12.164|
000014  6a86              LDR      r6,[r0,#0x28]
;;;147    
;;;148    	if (UARTx == MDR_UART1) {
000016  4824              LDR      r0,|L12.168|
000018  4284              CMP      r4,r0
00001a  d106              BNE      |L12.42|
;;;149    		cpuclock /= (1 << (tmpreg & UART1_BRG_Mask));
00001c  f0060107          AND      r1,r6,#7
000020  2001              MOVS     r0,#1
000022  4088              LSLS     r0,r0,r1
000024  fbb7f7f0          UDIV     r7,r7,r0
000028  e008              B        |L12.60|
                  |L12.42|
;;;150    	}
;;;151    	else
;;;152    		if (UARTx == MDR_UART2) {
00002a  4820              LDR      r0,|L12.172|
00002c  4284              CMP      r4,r0
00002e  d105              BNE      |L12.60|
;;;153    			cpuclock /= (1 << ((tmpreg & UART2_BRG_Mask) >> UART2_BRG_Offs));
000030  f3c62102          UBFX     r1,r6,#8,#3
000034  2001              MOVS     r0,#1
000036  4088              LSLS     r0,r0,r1
000038  fbb7f7f0          UDIV     r7,r7,r0
                  |L12.60|
;;;154    		}
;;;155    #if defined (USE_MDR1986VE3) || defined (USE_MDR1901VC1T)
;;;156    		else
;;;157    			if(UARTx == MDR_UART3) {
;;;158    				cpuclock /= (1 << ((tmpreg & UART3_BRG_Mask ) >> UART3_BRG_Offs));
;;;159    			}
;;;160    #endif
;;;161    #if defined (USE_MDR1986VE3)
;;;162    			else
;;;163    				if(UARTx == MDR_UART4) {
;;;164    					cpuclock /= (1 << ((tmpreg & UART4_BRG_Mask) >> UART4_BRG_Offs));
;;;165    				}
;;;166    #endif // #if defined (USE_MDR1986VE3) /* For Cortex M1 */
;;;167    
;;;168    	/* Determine the integer part */
;;;169    	divider = cpuclock / (UART_InitStruct->UART_BaudRate >> 2);
00003c  6828              LDR      r0,[r5,#0]
00003e  0880              LSRS     r0,r0,#2
000040  fbb7f9f0          UDIV     r9,r7,r0
;;;170    	integerdivider = divider >> 6;
000044  ea4f1899          LSR      r8,r9,#6
;;;171    	/* Determine the fractional part */
;;;172    	fractionaldivider = (divider & FBRD_Fract_Mask);
000048  f0090a3f          AND      r10,r9,#0x3f
;;;173    	/* Determine the speed error */
;;;174    	realspeed = (cpuclock * 4) / ((integerdivider * 64) + fractionaldivider);
00004c  00b8              LSLS     r0,r7,#2
00004e  eb0a1188          ADD      r1,r10,r8,LSL #6
000052  fbb0fbf1          UDIV     r11,r0,r1
;;;175    	speederror = ((realspeed - UART_InitStruct->UART_BaudRate) * 128)
000056  6828              LDR      r0,[r5,#0]
000058  ebab0000          SUB      r0,r11,r0
00005c  01c0              LSLS     r0,r0,#7
00005e  6829              LDR      r1,[r5,#0]
000060  fbb0f0f1          UDIV     r0,r0,r1
000064  9006              STR      r0,[sp,#0x18]
;;;176    			/ UART_InitStruct->UART_BaudRate;
;;;177    	if (speederror > 2) {
000066  9806              LDR      r0,[sp,#0x18]
000068  2802              CMP      r0,#2
00006a  d903              BLS      |L12.116|
;;;178    		return BaudRateInvalid;
00006c  2000              MOVS     r0,#0
                  |L12.110|
;;;179    	}
;;;180    	/* Write UART Baud Rate */
;;;181    	UARTx->IBRD = integerdivider;
;;;182    	UARTx->FBRD = fractionaldivider;
;;;183    
;;;184    	/* UART LCR_H configuration */
;;;185    	/* Set the WLEN bits according to UART_WordLength value */
;;;186    	/* Set STP2 bit according to UART_StopBits value */
;;;187    	/* Set PEN, EPS and SPS bits according to UART_Parity value */
;;;188    	/* Set FEN bit according to UART_FIFOMode value */
;;;189    	tmpreg = UARTx->LCR_H;
;;;190    	tmpreg |= UART_InitStruct->UART_WordLength | UART_InitStruct->UART_StopBits
;;;191    			| UART_InitStruct->UART_Parity | UART_InitStruct->UART_FIFOMode;
;;;192    	UARTx->LCR_H = tmpreg;
;;;193    
;;;194    	/* UART CR configuration */
;;;195    	tmpreg = UARTx->CR;
;;;196    	/* Clear UART CR Flow control bits */
;;;197    	tmpreg &= ~CR_FC_Mask;
;;;198    	/* Set UART CR Flow control bits */
;;;199    	tmpreg |= UART_InitStruct->UART_HardwareFlowControl;
;;;200    	/* Write to UART CR */
;;;201    	UARTx->CR = tmpreg;
;;;202    
;;;203    	return BaudRateValid;
;;;204    }
00006e  b007              ADD      sp,sp,#0x1c
000070  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.116|
000074  f8c48024          STR      r8,[r4,#0x24]         ;181
000078  f8c4a028          STR      r10,[r4,#0x28]        ;182
00007c  6ae6              LDR      r6,[r4,#0x2c]         ;189
00007e  88a8              LDRH     r0,[r5,#4]            ;190
000080  88e9              LDRH     r1,[r5,#6]            ;190
000082  4308              ORRS     r0,r0,r1              ;190
000084  8929              LDRH     r1,[r5,#8]            ;190
000086  4308              ORRS     r0,r0,r1              ;190
000088  8969              LDRH     r1,[r5,#0xa]          ;190
00008a  4308              ORRS     r0,r0,r1              ;190
00008c  4306              ORRS     r6,r6,r0              ;190
00008e  62e6              STR      r6,[r4,#0x2c]         ;192
000090  6b26              LDR      r6,[r4,#0x30]         ;195
000092  f64f7080          MOV      r0,#0xff80            ;197
000096  4386              BICS     r6,r6,r0              ;197
000098  89a8              LDRH     r0,[r5,#0xc]          ;199
00009a  4306              ORRS     r6,r6,r0              ;199
00009c  6326              STR      r6,[r4,#0x30]         ;201
00009e  2001              MOVS     r0,#1                 ;203
0000a0  e7e5              B        |L12.110|
;;;205    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L12.164|
                          DCD      0x40020000
                  |L12.168|
                          DCD      0x40030000
                  |L12.172|
                          DCD      0x40038000

                          AREA ||i.UART_IrDACmd||, CODE, READONLY, ALIGN=1

                  UART_IrDACmd PROC
;;;564      */
;;;565    void UART_IrDACmd(MDR_UART_TypeDef* UARTx, FunctionalState NewState)
000000  b121              CBZ      r1,|L13.12|
;;;566    {
;;;567      /* Check the parameters */
;;;568      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;569      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;570    
;;;571      if (NewState != DISABLE)
;;;572      {
;;;573        /* Set SIREN bit in the UART CR register */
;;;574        UARTx->CR |= CR_SIREN_Set;
000002  6b02              LDR      r2,[r0,#0x30]
000004  f0420202          ORR      r2,r2,#2
000008  6302              STR      r2,[r0,#0x30]
00000a  e004              B        |L13.22|
                  |L13.12|
;;;575      }
;;;576      else
;;;577      {
;;;578        /* Reset SIREN bit in the UART CR register */
;;;579        UARTx->CR |= CR_SIREN_Reset;
00000c  6b02              LDR      r2,[r0,#0x30]
00000e  f64f73fd          MOV      r3,#0xfffd
000012  431a              ORRS     r2,r2,r3
000014  6302              STR      r2,[r0,#0x30]
                  |L13.22|
;;;580      }
;;;581    }
000016  4770              BX       lr
;;;582    
                          ENDP


                          AREA ||i.UART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  UART_IrDAConfig PROC
;;;536      */
;;;537    void UART_IrDAConfig(MDR_UART_TypeDef* UARTx, uint32_t UART_IrDAMode)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;539      uint32_t cpuclock;
;;;540      RST_CLK_FreqTypeDef RST_CLK_Clocks;
;;;541    
;;;542      /* Check the parameters */
;;;543      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;544      assert_param(IS_UART_IRDA_MODE(UART_IrDAMode));
;;;545    
;;;546      if (UART_IrDAMode == UART_IrDAMode_LowPower)
000008  2d04              CMP      r5,#4
00000a  d108              BNE      |L14.30|
;;;547      {
;;;548        /* Configure the UART ILPR */
;;;549        RST_CLK_GetClocksFreq(&RST_CLK_Clocks);
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       RST_CLK_GetClocksFreq
;;;550        cpuclock = RST_CLK_Clocks.CPU_CLK_Frequency;
000012  9e01              LDR      r6,[sp,#4]
;;;551        UARTx->ILPR = cpuclock / IrLPBaud16;
000014  f44f10e1          MOV      r0,#0x1c2000
000018  fbb6f0f0          UDIV     r0,r6,r0
00001c  6220              STR      r0,[r4,#0x20]
                  |L14.30|
;;;552      }
;;;553      UARTx->CR |= UART_IrDAMode;
00001e  6b20              LDR      r0,[r4,#0x30]
000020  4328              ORRS     r0,r0,r5
000022  6320              STR      r0,[r4,#0x30]
;;;554    }
000024  b006              ADD      sp,sp,#0x18
000026  bd70              POP      {r4-r6,pc}
;;;555    
                          ENDP


                          AREA ||i.UART_ReceiveData||, CODE, READONLY, ALIGN=1

                  UART_ReceiveData PROC
;;;489      */
;;;490    uint16_t UART_ReceiveData(MDR_UART_TypeDef* UARTx)
000000  4601              MOV      r1,r0
;;;491    {
;;;492      /* Check the parameters */
;;;493      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;494    
;;;495      /* Receive Data */
;;;496      return (uint16_t)(UARTx->DR);
000002  6808              LDR      r0,[r1,#0]
000004  b280              UXTH     r0,r0
;;;497    }
000006  4770              BX       lr
;;;498    
                          ENDP


                          AREA ||i.UART_SendData||, CODE, READONLY, ALIGN=1

                  UART_SendData PROC
;;;472      */
;;;473    void UART_SendData(MDR_UART_TypeDef* UARTx, uint16_t Data)
000000  b2ca              UXTB     r2,r1
;;;474    {
;;;475      /* Check the parameters */
;;;476      assert_param(IS_UART_ALL_PERIPH(UARTx));
;;;477      assert_param(IS_UART_DATA(Data));
;;;478    
;;;479      /* Transmit Data */
;;;480      UARTx->DR = (Data & (uint16_t)0x0FF);
000002  6002              STR      r2,[r0,#0]
;;;481    }
000004  4770              BX       lr
;;;482    
                          ENDP


                          AREA ||i.UART_StructInit||, CODE, READONLY, ALIGN=1

                  UART_StructInit PROC
;;;211      */
;;;212    void UART_StructInit(UART_InitTypeDef* UART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;213    {
;;;214      /* UART_InitStruct members default value */
;;;215      UART_InitStruct->UART_BaudRate = 9600;
000004  6001              STR      r1,[r0,#0]
;;;216      UART_InitStruct->UART_WordLength = UART_WordLength5b;
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;217      UART_InitStruct->UART_StopBits = UART_StopBits1;
00000a  80c1              STRH     r1,[r0,#6]
;;;218      UART_InitStruct->UART_Parity = UART_Parity_No;
00000c  8101              STRH     r1,[r0,#8]
;;;219      UART_InitStruct->UART_FIFOMode = UART_FIFO_OFF;
00000e  8141              STRH     r1,[r0,#0xa]
;;;220      UART_InitStruct->UART_HardwareFlowControl = UART_HardwareFlowControl_RXE | UART_HardwareFlowControl_TXE;
000010  f44f7140          MOV      r1,#0x300
000014  8181              STRH     r1,[r0,#0xc]
;;;221    }
000016  4770              BX       lr
;;;222    
                          ENDP


;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH|
#line 462
|__asm___16_MDR32F9Qx_uart_c_c95a8597____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_MDR32F9Qx_uart_c_c95a8597____RRX|
#line 649
|__asm___16_MDR32F9Qx_uart_c_c95a8597____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
