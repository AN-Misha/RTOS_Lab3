; generated by Component: ARM Compiler 5.06 update 5 (build 528) Tool: ArmCC [4d3621]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_rst_clk.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Config -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\CoreSupport -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=524 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_rst_clk.crf C:\Keil_v5\ARM\PACK\Keil\MDR1986BExx\1.4\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||i.RST_CLK_ADCclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkEnable PROC
;;;1116     */
;;;1117   void RST_CLK_ADCclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L1.8|
;;;1118   {
;;;1119   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1120     uint32_t temp = 0;
;;;1121   #endif
;;;1122     /* Check the parameters */
;;;1123     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1124   
;;;1125   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1126     *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1127   #endif
;;;1128   
;;;1129   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1130   
;;;1131     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
;;;1132     /* Form new value */
;;;1133     if (NewState != DISABLE){
;;;1134       /* Enable the ADC CLK by setting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1135       temp |= RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1136     }
;;;1137     else{
;;;1138       /* Disable the ADC CLK by resetting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1139       temp &= ~RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1140     }
;;;1141     /* Configure CPU_CLOCK register with new value */
;;;1142     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
;;;1143   #endif
;;;1144   
;;;1145   }
000004  4770              BX       lr
;;;1146   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x424002b4

                          AREA ||i.RST_CLK_ADCclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkPrescaler PROC
;;;1093     */
;;;1094   void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
000000  4601              MOV      r1,r0
;;;1095   {
;;;1096     uint32_t temp;
;;;1097   
;;;1098     /* Check the parameters */
;;;1099     assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;1100   
;;;1101     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000002  4a04              LDR      r2,|L2.20|
000004  6950              LDR      r0,[r2,#0x14]
;;;1102     /* Clear ADC_C3_SEL bits */
;;;1103     temp &= ADC_C3_SELclr;
000006  f4206070          BIC      r0,r0,#0xf00
;;;1104     /* Set the ADC_C3_SEL bits */
;;;1105     temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
00000a  ea402001          ORR      r0,r0,r1,LSL #8
;;;1106     /* Store the new value */
;;;1107     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00000e  6150              STR      r0,[r2,#0x14]
;;;1108   }
000010  4770              BX       lr
;;;1109   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_ADCclkSelection||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkSelection PROC
;;;1061     */
;;;1062   void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
000000  4601              MOV      r1,r0
;;;1063   {
;;;1064     uint32_t temp;
;;;1065   
;;;1066     /* Check the parameters */
;;;1067     assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;1068   
;;;1069     /* Select ADC_CLK source */
;;;1070     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000002  4a03              LDR      r2,|L3.16|
000004  6950              LDR      r0,[r2,#0x14]
;;;1071     /* Clear ADC_C1,C2 SEL bits */
;;;1072     temp &= ADC_C12_SELclr;
000006  f0200033          BIC      r0,r0,#0x33
;;;1073     /* Set the ADC_C1,C2 SEL bits */
;;;1074     temp |= ADC_CLK;
00000a  4308              ORRS     r0,r0,r1
;;;1075     /* Store the new value */
;;;1076     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00000c  6150              STR      r0,[r2,#0x14]
;;;1077   }
00000e  4770              BX       lr
;;;1078   
                          ENDP

                  |L3.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_CPU_PLLcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLcmd PROC
;;;697      */
;;;698    void RST_CLK_CPU_PLLcmd ( FunctionalState NewState )
000000  4901              LDR      r1,|L4.8|
;;;699    {
;;;700    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;701      uint32_t temp;
;;;702    #endif
;;;703      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;704    
;;;705    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;706      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;707    #endif
;;;708    
;;;709    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;710      temp = MDR_RST_CLK->PLL_CONTROL;
;;;711    
;;;712      if(NewState == ENABLE){
;;;713        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;714      }
;;;715      else{
;;;716        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;717      }
;;;718      MDR_RST_CLK->PLL_CONTROL = temp;
;;;719    
;;;720    #endif
;;;721    }
000004  4770              BX       lr
;;;722    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x42400088

                          AREA ||i.RST_CLK_CPU_PLLconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLconfig PROC
;;;614      */
;;;615    void RST_CLK_CPU_PLLconfig ( uint32_t RST_CLK_CPU_PLLsource,
000000  b510              PUSH     {r4,lr}
;;;616                             uint32_t RST_CLK_CPU_PLLmul )
;;;617    {
000002  4602              MOV      r2,r0
;;;618      uint32_t temp;
;;;619    
;;;620      /* Check the parameters */
;;;621      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;622      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;623    
;;;624      /* Select CPUPLL source */
;;;625      temp = MDR_RST_CLK->CPU_CLOCK;
000004  4b0c              LDR      r3,|L5.56|
000006  68d8              LDR      r0,[r3,#0xc]
;;;626      /* Clear CPU_C1_SEL bits */
;;;627      temp &= CPU_C1_SELclr;
000008  f0200003          BIC      r0,r0,#3
;;;628      /* Set the CPU_C1_SEL bits */
;;;629      temp |= RST_CLK_CPU_PLLsource;
00000c  4310              ORRS     r0,r0,r2
;;;630      /* Store the new value */MDR_RST_CLK->CPU_CLOCK = temp;
00000e  60d8              STR      r0,[r3,#0xc]
;;;631    
;;;632      /* Set CPUPLL multiplier */
;;;633      temp = MDR_RST_CLK->PLL_CONTROL;
000010  6858              LDR      r0,[r3,#4]
;;;634      /* Clear PLLMUL[3:0] bits */
;;;635      temp &= PLLCPUmulclr;
000012  f4206070          BIC      r0,r0,#0xf00
;;;636      /* Set the PLLMUL[3:0] bits */
;;;637      temp |= (RST_CLK_CPU_PLLmul << PLLCPUMUL_OFFSET);
000016  ea402001          ORR      r0,r0,r1,LSL #8
;;;638      /* Store the new value */
;;;639      MDR_RST_CLK->PLL_CONTROL = temp;
00001a  6058              STR      r0,[r3,#4]
;;;640    
;;;641    #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;642      if (*(__IO uint32_t *) PLLCPUON_BB) {
00001c  4b07              LDR      r3,|L5.60|
00001e  681b              LDR      r3,[r3,#0]
000020  b143              CBZ      r3,|L5.52|
;;;643        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x01;
000022  2301              MOVS     r3,#1
000024  4c05              LDR      r4,|L5.60|
000026  1d24              ADDS     r4,r4,#4
000028  6023              STR      r3,[r4,#0]
;;;644        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x00;
00002a  2300              MOVS     r3,#0
00002c  4c03              LDR      r4,|L5.60|
00002e  3c88              SUBS     r4,r4,#0x88
000030  f8c4308c          STR      r3,[r4,#0x8c]
                  |L5.52|
;;;645      }
;;;646    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;647      if( (MDR_RST_CLK->PLL_CONTROL & RST_CLK_PLL_CONTROL_PLL_CPU_ON) == RST_CLK_PLL_CONTROL_PLL_CPU_ON ) {
;;;648        temp = MDR_RST_CLK->PLL_CONTROL;
;;;649        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;650        MDR_RST_CLK->PLL_CONTROL = temp;
;;;651        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;652        MDR_RST_CLK->PLL_CONTROL = temp;
;;;653      }
;;;654    #endif
;;;655    }
000034  bd10              POP      {r4,pc}
;;;656    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40020000
                  |L5.60|
                          DCD      0x42400088

                          AREA ||i.RST_CLK_CPU_PLLstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_CPU_PLLstatus PROC
;;;727      */
;;;728    ErrorStatus RST_CLK_CPU_PLLstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;729    {
;;;730      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;731      ErrorStatus state;
;;;732      FlagStatus flag;
;;;733    
;;;734      /* Wait until CPUPLL is ready or time out is occure */
;;;735      do
000006  bf00              NOP      
                  |L6.8|
;;;736      {
;;;737        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
000008  2021              MOVS     r0,#0x21
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;738        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;739      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L6.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L6.8|
                  |L6.34|
;;;740    
;;;741      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
000022  2021              MOVS     r0,#0x21
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L6.46|
;;;742      {
;;;743        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L6.48|
                  |L6.46|
;;;744      }
;;;745      else
;;;746      {
;;;747        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L6.48|
;;;748      }
;;;749      return state;
000030  4620              MOV      r0,r4
;;;750    }
000032  bd38              POP      {r3-r5,pc}
;;;751    
                          ENDP


                          AREA ||i.RST_CLK_CPU_PLLuse||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLuse PROC
;;;661      */
;;;662    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
000000  4901              LDR      r1,|L7.8|
;;;663    {
;;;664    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;665      uint32_t temp = 0;
;;;666    #endif
;;;667      /* Check the parameters */
;;;668      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;669    
;;;670    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;671      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t) UsePLL;
000002  6008              STR      r0,[r1,#0]
;;;672    #endif
;;;673    
;;;674    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;675    
;;;676      temp = MDR_RST_CLK->CPU_CLOCK;
;;;677      /* Form new value */
;;;678      if (UsePLL != DISABLE){
;;;679        /* Use the CPU PLL output as input for CPU_C3_SEL
;;;680         * by setting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;681        temp |= (1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;682      }
;;;683      else{
;;;684        /* Use the CPU_C1 output as input for CPU_C3_SEL
;;;685         * by resetting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;686        temp &= ~(1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;687      }
;;;688      /* Configure CPU_CLOCK register with new value */
;;;689      MDR_RST_CLK->CPU_CLOCK = temp;
;;;690    #endif
;;;691    }
000004  4770              BX       lr
;;;692    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x42400188

                          AREA ||i.RST_CLK_CPUclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPUclkPrescaler PROC
;;;765      */
;;;766    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
000000  4601              MOV      r1,r0
;;;767    {
;;;768      uint32_t temp;
;;;769    
;;;770      /* Check the parameters */
;;;771      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;772    
;;;773      temp = MDR_RST_CLK->CPU_CLOCK;
000002  4a04              LDR      r2,|L8.20|
000004  68d0              LDR      r0,[r2,#0xc]
;;;774      /* Clear CPU_C3_SEL bits */
;;;775      temp &= CPU_C3_SELclr;
000006  f02000f0          BIC      r0,r0,#0xf0
;;;776      /* Set the CPU_C3_SEL bits */
;;;777      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
00000a  ea401001          ORR      r0,r0,r1,LSL #4
;;;778      /* Store the new value */
;;;779      MDR_RST_CLK->CPU_CLOCK = temp;
00000e  60d0              STR      r0,[r2,#0xc]
;;;780    }
000010  4770              BX       lr
;;;781    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_CPUclkSelection||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPUclkSelection PROC
;;;790      */
;;;791    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
000000  4601              MOV      r1,r0
;;;792    {
;;;793      uint32_t temp;
;;;794    
;;;795      /* Check the parameters */
;;;796      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;797    
;;;798      temp = MDR_RST_CLK->CPU_CLOCK;
000002  4a03              LDR      r2,|L9.16|
000004  68d0              LDR      r0,[r2,#0xc]
;;;799      /* Clear CPU_C3_SEL bits */
;;;800      temp &= CPU_HCLK_SELclr;
000006  f4207040          BIC      r0,r0,#0x300
;;;801      /* Set the CPU_C3_SEL bits */
;;;802      temp |= CPU_CLK;
00000a  4308              ORRS     r0,r0,r1
;;;803      /* Store the new value */
;;;804      MDR_RST_CLK->CPU_CLOCK = temp;
00000c  60d0              STR      r0,[r2,#0xc]
;;;805    }
00000e  4770              BX       lr
;;;806    
                          ENDP

                  |L9.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_DeInit||, CODE, READONLY, ALIGN=2

                  RST_CLK_DeInit PROC
;;;185      */
;;;186    void RST_CLK_DeInit(void)
000000  b500              PUSH     {lr}
;;;187    {
;;;188      RST_CLK_WarmDeInit();
000002  f7fffffe          BL       RST_CLK_WarmDeInit
;;;189      /* Reset REG_0F bits to zero but HSION bit */
;;;190      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
000006  2101              MOVS     r1,#1
000008  06c8              LSLS     r0,r1,#27
00000a  f7fffffe          BL       RST_CLK_PCLKcmd
;;;191      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
00000e  4806              LDR      r0,|L10.40|
000010  6bc0              LDR      r0,[r0,#0x3c]
000012  f4400081          ORR      r0,r0,#0x408000
000016  4904              LDR      r1,|L10.40|
000018  63c8              STR      r0,[r1,#0x3c]
;;;192      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
00001a  4608              MOV      r0,r1
00001c  6bc0              LDR      r0,[r0,#0x3c]
00001e  f4000081          AND      r0,r0,#0x408000
000022  63c8              STR      r0,[r1,#0x3c]
;;;193    }
000024  bd00              POP      {pc}
;;;194    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RST_CLK_GetClocksFreq PROC
;;;1471     */
;;;1472   void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;1473   {
000004  4601              MOV      r1,r0
;;;1474     uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;1475     uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;1476     uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;1477     uint32_t hsi_c1_freq, hse_c1_freq;
;;;1478     uint32_t pll_mul;
;;;1479     uint32_t temp;
;;;1480   
;;;1481     /* Check the parameter */
;;;1482     assert_param(RST_CLK_Clocks != 0);
;;;1483   
;;;1484     /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;1485   
;;;1486     /* Compute CPU_CLK frequency */
;;;1487   
;;;1488     /* Determine CPU_C1 frequency */
;;;1489     if( MDR_RST_CLK->CPU_CLOCK & (2 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
000006  f8dfb264          LDR      r11,|L11.620|
00000a  f8dbb00c          LDR      r11,[r11,#0xc]
00000e  f00b0b02          AND      r11,r11,#2
000012  f1bb0f00          CMP      r11,#0
000016  d001              BEQ      |L11.28|
;;;1490       cpu_c1_freq = HSE_Value;
000018  4b95              LDR      r3,|L11.624|
00001a  e000              B        |L11.30|
                  |L11.28|
;;;1491     }
;;;1492     else {
;;;1493       cpu_c1_freq = HSI_Value;
00001c  4b94              LDR      r3,|L11.624|
                  |L11.30|
;;;1494     }
;;;1495     if( MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
00001e  f8dfb24c          LDR      r11,|L11.620|
000022  f8dbb00c          LDR      r11,[r11,#0xc]
000026  f00b0b01          AND      r11,r11,#1
00002a  f1bb0f00          CMP      r11,#0
00002e  d000              BEQ      |L11.50|
;;;1496       cpu_c1_freq /= 2;
000030  085b              LSRS     r3,r3,#1
                  |L11.50|
;;;1497     }
;;;1498   
;;;1499     /* Determine CPU_C2 frequency */
;;;1500     cpu_c2_freq = cpu_c1_freq;
000032  461c              MOV      r4,r3
;;;1501   
;;;1502     if (MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos)) {
000034  f8dfb234          LDR      r11,|L11.620|
000038  f8dbb00c          LDR      r11,[r11,#0xc]
00003c  f00b0b04          AND      r11,r11,#4
000040  f1bb0f00          CMP      r11,#0
000044  d00d              BEQ      |L11.98|
;;;1503       /* Determine CPU PLL output frequency */
;;;1504       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
000046  f8dfb224          LDR      r11,|L11.620|
00004a  f8dbb004          LDR      r11,[r11,#4]
00004e  f3cb2b03          UBFX     r11,r11,#8,#4
000052  f10b0b01          ADD      r11,r11,#1
000056  f8cdb000          STR      r11,[sp,#0]
;;;1505           >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1506       cpu_c2_freq *= pll_mul;
00005a  f8ddb000          LDR      r11,[sp,#0]
00005e  fb04f40b          MUL      r4,r4,r11
                  |L11.98|
;;;1507     }
;;;1508   
;;;1509     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1510     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos)
000062  f8dfb208          LDR      r11,|L11.620|
000066  f8dbb00c          LDR      r11,[r11,#0xc]
00006a  f3cb2b01          UBFX     r11,r11,#8,#2
00006e  f1bb0f00          CMP      r11,#0
000072  d006              BEQ      |L11.130|
000074  f1bb0f01          CMP      r11,#1
000078  d008              BEQ      |L11.140|
00007a  f1bb0f02          CMP      r11,#2
00007e  d128              BNE      |L11.210|
000080  e022              B        |L11.200|
                  |L11.130|
;;;1511         & (uint32_t) 0x03) {
;;;1512       case 0:
;;;1513         /* HSI */
;;;1514         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
000082  f8dfb1ec          LDR      r11,|L11.624|
000086  f8c1b000          STR      r11,[r1,#0]
;;;1515         break;
00008a  e027              B        |L11.220|
                  |L11.140|
;;;1516       case 1:
;;;1517         /* CPU_C3 */
;;;1518         /* Determine CPU_C3 frequency */
;;;1519         if ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
00008c  f8dfb1dc          LDR      r11,|L11.620|
000090  f8dbb00c          LDR      r11,[r11,#0xc]
000094  f04f0e08          MOV      lr,#8
000098  ea0e1b1b          AND      r11,lr,r11,LSR #4
00009c  f1bb0f00          CMP      r11,#0
0000a0  d101              BNE      |L11.166|
;;;1520             & (uint32_t) 0x08) == 0x00) {
;;;1521           cpu_c3_freq = cpu_c2_freq;
0000a2  46a0              MOV      r8,r4
0000a4  e00d              B        |L11.194|
                  |L11.166|
;;;1522         }
;;;1523         else {
;;;1524           cpu_c3_freq = cpu_c2_freq
0000a6  f8dfb1c4          LDR      r11,|L11.620|
0000aa  f8dbb00c          LDR      r11,[r11,#0xc]
0000ae  f3cb1b02          UBFX     r11,r11,#4,#3
0000b2  f10b0b01          ADD      r11,r11,#1
0000b6  f04f0e01          MOV      lr,#1
0000ba  fa0efe0b          LSL      lr,lr,r11
0000be  fbb4f8fe          UDIV     r8,r4,lr
                  |L11.194|
;;;1525               / (1
;;;1526                   << ((MDR_RST_CLK->CPU_CLOCK
;;;1527                       >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
;;;1528                       & (uint32_t) 0x07) + 1));
;;;1529         }
;;;1530         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
0000c2  f8c18000          STR      r8,[r1,#0]
;;;1531         break;
0000c6  e009              B        |L11.220|
                  |L11.200|
;;;1532       case 2:
;;;1533         /* LSE */
;;;1534         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
0000c8  f44f4b00          MOV      r11,#0x8000
0000cc  f8c1b000          STR      r11,[r1,#0]
;;;1535         break;
0000d0  e004              B        |L11.220|
                  |L11.210|
;;;1536       default: /* case 3 */
;;;1537         /* LSI */
;;;1538         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
0000d2  f6494b40          MOV      r11,#0x9c40
0000d6  f8c1b000          STR      r11,[r1,#0]
;;;1539         break;
0000da  bf00              NOP      
                  |L11.220|
0000dc  bf00              NOP                            ;1515
;;;1540     }
;;;1541   
;;;1542     /* Compute USB_CLK frequency */
;;;1543   
;;;1544     /* Determine USB_C1 frequency */
;;;1545     if( MDR_RST_CLK->USB_CLOCK & (2 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
0000de  f8dfb18c          LDR      r11,|L11.620|
0000e2  f8dbb010          LDR      r11,[r11,#0x10]
0000e6  f00b0b02          AND      r11,r11,#2
0000ea  f1bb0f00          CMP      r11,#0
0000ee  d001              BEQ      |L11.244|
;;;1546       usb_c1_freq = HSE_Value;
0000f0  4d5f              LDR      r5,|L11.624|
0000f2  e000              B        |L11.246|
                  |L11.244|
;;;1547     }
;;;1548     else {
;;;1549       usb_c1_freq = HSI_Value;
0000f4  4d5e              LDR      r5,|L11.624|
                  |L11.246|
;;;1550     }
;;;1551   
;;;1552     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
0000f6  f8dfb174          LDR      r11,|L11.620|
0000fa  f8dbb010          LDR      r11,[r11,#0x10]
0000fe  f00b0b01          AND      r11,r11,#1
000102  f1bb0f00          CMP      r11,#0
000106  d000              BEQ      |L11.266|
;;;1553       usb_c1_freq /= 2;
000108  086d              LSRS     r5,r5,#1
                  |L11.266|
;;;1554     }
;;;1555   
;;;1556     /* Determine USB_C2 frequency */
;;;1557     usb_c2_freq = usb_c1_freq;
00010a  462f              MOV      r7,r5
;;;1558   
;;;1559     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C2_SEL_Pos) ){
00010c  f8dfb15c          LDR      r11,|L11.620|
000110  f8dbb010          LDR      r11,[r11,#0x10]
000114  f00b0b04          AND      r11,r11,#4
000118  f1bb0f00          CMP      r11,#0
00011c  d00d              BEQ      |L11.314|
;;;1560       /* Determine USB PLL output frequency */
;;;1561       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
00011e  f8dfb14c          LDR      r11,|L11.620|
000122  f8dbb004          LDR      r11,[r11,#4]
000126  f3cb1b03          UBFX     r11,r11,#4,#4
00012a  f10b0b01          ADD      r11,r11,#1
00012e  f8cdb000          STR      r11,[sp,#0]
;;;1562           >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1563       usb_c2_freq *= pll_mul;
000132  f8ddb000          LDR      r11,[sp,#0]
000136  fb07f70b          MUL      r7,r7,r11
                  |L11.314|
;;;1564     }
;;;1565   
;;;1566     /* Determine USB_C3 frequency */
;;;1567     usb_c3_freq = usb_c2_freq;
00013a  46b9              MOV      r9,r7
;;;1568     if(MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C3_SEL_Pos)){
00013c  f8dfb12c          LDR      r11,|L11.620|
000140  f8dbb010          LDR      r11,[r11,#0x10]
000144  f00b0b10          AND      r11,r11,#0x10
000148  f1bb0f00          CMP      r11,#0
00014c  d001              BEQ      |L11.338|
;;;1569       usb_c3_freq /= 2;
00014e  ea4f0959          LSR      r9,r9,#1
                  |L11.338|
;;;1570     }
;;;1571   
;;;1572     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
000152  f8c19004          STR      r9,[r1,#4]
;;;1573   
;;;1574     /* Compute RTCHSI_CLK frequency */
;;;1575     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
000156  f8dfb114          LDR      r11,|L11.620|
00015a  f8dbb018          LDR      r11,[r11,#0x18]
00015e  ea4f101b          LSR      r0,r11,#4
;;;1576     if ((temp & 0x08U) == 0) {
000162  f0000b08          AND      r11,r0,#8
000166  f1bb0f00          CMP      r11,#0
00016a  d102              BNE      |L11.370|
;;;1577       hsi_c1_freq = HSI_Value;
00016c  f8dfc100          LDR      r12,|L11.624|
000170  e00b              B        |L11.394|
                  |L11.370|
;;;1578     }
;;;1579     else {
;;;1580       temp = 1 << ((temp & 0x07U) + 1);
000172  f0000b07          AND      r11,r0,#7
000176  f10b0b01          ADD      r11,r11,#1
00017a  f04f0e01          MOV      lr,#1
00017e  fa0ef00b          LSL      r0,lr,r11
;;;1581       hsi_c1_freq = HSI_Value / temp;
000182  f8dfb0ec          LDR      r11,|L11.624|
000186  fbbbfcf0          UDIV     r12,r11,r0
                  |L11.394|
;;;1582     }
;;;1583     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
00018a  f8c1c00c          STR      r12,[r1,#0xc]
;;;1584   
;;;1585     /* Compute RTCHSE_CLK frequency */
;;;1586     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
00018e  f8dfb0dc          LDR      r11,|L11.620|
000192  f8db0018          LDR      r0,[r11,#0x18]
;;;1587     if ((temp & 0x08U) == 0) {
000196  f0000b08          AND      r11,r0,#8
00019a  f1bb0f00          CMP      r11,#0
00019e  d104              BNE      |L11.426|
;;;1588       hse_c1_freq = HSE_Value;
0001a0  f8dfb0cc          LDR      r11,|L11.624|
0001a4  f8cdb004          STR      r11,[sp,#4]
0001a8  e00d              B        |L11.454|
                  |L11.426|
;;;1589     }
;;;1590     else {
;;;1591       temp = 1 << ((temp & 0x07U) + 1);
0001aa  f0000b07          AND      r11,r0,#7
0001ae  f10b0b01          ADD      r11,r11,#1
0001b2  f04f0e01          MOV      lr,#1
0001b6  fa0ef00b          LSL      r0,lr,r11
;;;1592       hse_c1_freq = HSE_Value / temp;
0001ba  f8dfb0b4          LDR      r11,|L11.624|
0001be  fbbbfbf0          UDIV     r11,r11,r0
0001c2  f8cdb004          STR      r11,[sp,#4]
                  |L11.454|
;;;1593     }
;;;1594     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
0001c6  f8ddb004          LDR      r11,[sp,#4]
0001ca  f8c1b010          STR      r11,[r1,#0x10]
;;;1595   
;;;1596     /* Compute ADC_CLK frequency */
;;;1597   
;;;1598     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1599     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos)
0001ce  f8dfb09c          LDR      r11,|L11.620|
0001d2  f8dbb014          LDR      r11,[r11,#0x14]
0001d6  f00b0b03          AND      r11,r11,#3
0001da  f1bb0f00          CMP      r11,#0
0001de  d006              BEQ      |L11.494|
0001e0  f1bb0f01          CMP      r11,#1
0001e4  d005              BEQ      |L11.498|
0001e6  f1bb0f02          CMP      r11,#2
0001ea  d106              BNE      |L11.506|
0001ec  e003              B        |L11.502|
                  |L11.494|
;;;1600         & (uint32_t) 0x03) {
;;;1601       case 0:
;;;1602         /* CPU_C1 */
;;;1603         adc_c1_freq = cpu_c1_freq;
0001ee  461e              MOV      r6,r3
;;;1604         break;
0001f0  e005              B        |L11.510|
                  |L11.498|
;;;1605       case 1:
;;;1606         /* USB_C1 */
;;;1607         adc_c1_freq = usb_c1_freq;
0001f2  462e              MOV      r6,r5
;;;1608         break;
0001f4  e003              B        |L11.510|
                  |L11.502|
;;;1609       case 2:
;;;1610         /* CPU_C2 */
;;;1611         adc_c1_freq = cpu_c2_freq;
0001f6  4626              MOV      r6,r4
;;;1612         break;
0001f8  e001              B        |L11.510|
                  |L11.506|
;;;1613       default: /* case 3 */
;;;1614         /* USB_C2 */
;;;1615         adc_c1_freq = usb_c2_freq;
0001fa  463e              MOV      r6,r7
;;;1616         break;
0001fc  bf00              NOP      
                  |L11.510|
0001fe  bf00              NOP                            ;1604
;;;1617     }
;;;1618   
;;;1619     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1620     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos)
000200  f8dfb068          LDR      r11,|L11.620|
000204  f8dbb014          LDR      r11,[r11,#0x14]
000208  f3cb1b01          UBFX     r11,r11,#4,#2
00020c  f1bb0f00          CMP      r11,#0
000210  d006              BEQ      |L11.544|
000212  f1bb0f01          CMP      r11,#1
000216  d006              BEQ      |L11.550|
000218  f1bb0f02          CMP      r11,#2
00021c  d108              BNE      |L11.560|
00021e  e005              B        |L11.556|
                  |L11.544|
;;;1621         & (uint32_t) 0x03) {
;;;1622       case 0:
;;;1623         /* LSE */
;;;1624         adc_c2_freq = LSE_Value;
000220  f44f4200          MOV      r2,#0x8000
;;;1625         break;
000224  e006              B        |L11.564|
                  |L11.550|
;;;1626       case 1:
;;;1627         /* LSI */
;;;1628         adc_c2_freq = LSI_Value;
000226  f6494240          MOV      r2,#0x9c40
;;;1629         break;
00022a  e003              B        |L11.564|
                  |L11.556|
;;;1630       case 2:
;;;1631         /* ADC_C1 */
;;;1632         adc_c2_freq = adc_c1_freq;
00022c  4632              MOV      r2,r6
;;;1633         break;
00022e  e001              B        |L11.564|
                  |L11.560|
;;;1634       default: /* case 3 */
;;;1635         /* HSI_C1 */
;;;1636         adc_c2_freq = hsi_c1_freq;
000230  4662              MOV      r2,r12
;;;1637         break;
000232  bf00              NOP      
                  |L11.564|
000234  bf00              NOP                            ;1625
;;;1638     }
;;;1639   
;;;1640     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
000236  f8dfb034          LDR      r11,|L11.620|
00023a  f8dbb014          LDR      r11,[r11,#0x14]
00023e  ea4f201b          LSR      r0,r11,#8
;;;1641     if ((temp & 0x08U) == 0) {
000242  f0000b08          AND      r11,r0,#8
000246  f1bb0f00          CMP      r11,#0
00024a  d101              BNE      |L11.592|
;;;1642       adc_c3_freq = adc_c2_freq;
00024c  4692              MOV      r10,r2
00024e  e009              B        |L11.612|
                  |L11.592|
;;;1643     }
;;;1644     else {
;;;1645       temp = 1 << ((temp & 0x07U) + 1);
000250  f0000b07          AND      r11,r0,#7
000254  f10b0b01          ADD      r11,r11,#1
000258  f04f0e01          MOV      lr,#1
00025c  fa0ef00b          LSL      r0,lr,r11
;;;1646       adc_c3_freq = adc_c2_freq / temp;
000260  fbb2faf0          UDIV     r10,r2,r0
                  |L11.612|
;;;1647     }
;;;1648   
;;;1649     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
000264  f8c1a008          STR      r10,[r1,#8]
;;;1650   }
000268  e8bd8ffc          POP      {r2-r11,pc}
;;;1651   
                          ENDP

                  |L11.620|
                          DCD      0x40020000
                  |L11.624|
                          DCD      0x007a1200

                          AREA ||i.RST_CLK_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RST_CLK_GetFlagStatus PROC
;;;1664     */
;;;1665   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1666   {
000002  4601              MOV      r1,r0
;;;1667     uint32_t statusreg;
;;;1668     FlagStatus bitstatus;
;;;1669   
;;;1670     /* Check the parameters */
;;;1671     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1672   
;;;1673     /* Get the register */
;;;1674     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
000004  f00103e0          AND      r3,r1,#0xe0
000008  2b20              CMP      r3,#0x20
00000a  d102              BNE      |L12.18|
;;;1675     {
;;;1676       statusreg = MDR_RST_CLK->CLOCK_STATUS;
00000c  4b07              LDR      r3,|L12.44|
00000e  681a              LDR      r2,[r3,#0]
000010  e001              B        |L12.22|
                  |L12.18|
;;;1677     }
;;;1678     else                                                  /* The flag to check is in REG_0F register */
;;;1679     {
;;;1680       statusreg = MDR_BKP->REG_0F;
000012  4b07              LDR      r3,|L12.48|
000014  6bda              LDR      r2,[r3,#0x3c]
                  |L12.22|
;;;1681     }
;;;1682   
;;;1683     /* Get the flag status on proper position */
;;;1684     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
000016  f001041f          AND      r4,r1,#0x1f
00001a  2301              MOVS     r3,#1
00001c  40a3              LSLS     r3,r3,r4
00001e  4013              ANDS     r3,r3,r2
000020  b10b              CBZ      r3,|L12.38|
;;;1685     {
;;;1686       bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L12.40|
                  |L12.38|
;;;1687     }
;;;1688     else
;;;1689     {
;;;1690       bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L12.40|
;;;1691     }
;;;1692   
;;;1693     /* Return the flag status */
;;;1694     return bitstatus;
;;;1695   }
000028  bd10              POP      {r4,pc}
;;;1696   
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x40020000
                  |L12.48|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_HSEclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSEclkPrescaler PROC
;;;1333     */
;;;1334   void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
000000  4601              MOV      r1,r0
;;;1335   {
;;;1336     uint32_t temp;
;;;1337   
;;;1338     /* Check the parameters */
;;;1339     assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;1340   
;;;1341     temp = MDR_RST_CLK->RTC_CLOCK;
000002  4a03              LDR      r2,|L13.16|
000004  6990              LDR      r0,[r2,#0x18]
;;;1342     /* Clear HSE_SEL bits */
;;;1343     temp &= HSE_SELclr;
000006  f020000f          BIC      r0,r0,#0xf
;;;1344     /* Set the HSE_SEL bits */
;;;1345     temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
00000a  4308              ORRS     r0,r0,r1
;;;1346     /* Store the new value */
;;;1347     MDR_RST_CLK->RTC_CLOCK = temp;
00000c  6190              STR      r0,[r2,#0x18]
;;;1348   }
00000e  4770              BX       lr
;;;1349   
                          ENDP

                  |L13.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSEconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSEconfig PROC
;;;237      */
;;;238    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
000000  490d              LDR      r1,|L14.56|
;;;239    {
;;;240      /* Check the parameters */
;;;241      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;243      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
000002  6889              LDR      r1,[r1,#8]
000004  f0210103          BIC      r1,r1,#3
000008  4a0b              LDR      r2,|L14.56|
00000a  6091              STR      r1,[r2,#8]
;;;244      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;245      switch (RST_CLK_HSE)
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L14.22|
000010  2802              CMP      r0,#2
000012  d10e              BNE      |L14.50|
000014  e006              B        |L14.36|
                  |L14.22|
;;;246      {
;;;247        case RST_CLK_HSE_ON:
;;;248          /* Set HSEON bit */
;;;249          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
000016  4908              LDR      r1,|L14.56|
000018  6889              LDR      r1,[r1,#8]
00001a  f0410101          ORR      r1,r1,#1
00001e  4a06              LDR      r2,|L14.56|
000020  6091              STR      r1,[r2,#8]
;;;250          break;
000022  e007              B        |L14.52|
                  |L14.36|
;;;251    
;;;252        case RST_CLK_HSE_Bypass:
;;;253          /* Set HSEBYP and HSEON bits */
;;;254          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
000024  4904              LDR      r1,|L14.56|
000026  6889              LDR      r1,[r1,#8]
000028  f0410103          ORR      r1,r1,#3
00002c  4a02              LDR      r2,|L14.56|
00002e  6091              STR      r1,[r2,#8]
;;;255          break;
000030  e000              B        |L14.52|
                  |L14.50|
;;;256    
;;;257        default:
;;;258          break;
000032  bf00              NOP      
                  |L14.52|
000034  bf00              NOP                            ;250
;;;259      }
;;;260    }
000036  4770              BX       lr
;;;261    
                          ENDP

                  |L14.56|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSEstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_HSEstatus PROC
;;;302      */
;;;303    ErrorStatus RST_CLK_HSEstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;304    {
;;;305      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;306      ErrorStatus state;
;;;307      FlagStatus flag;
;;;308    
;;;309      /* Wait until HSE is ready or time out is occure */
;;;310      do
000006  bf00              NOP      
                  |L15.8|
;;;311      {
;;;312        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
000008  2022              MOVS     r0,#0x22
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;313        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;314      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L15.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L15.8|
                  |L15.34|
;;;315    
;;;316      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
000022  2022              MOVS     r0,#0x22
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L15.46|
;;;317      {
;;;318        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L15.48|
                  |L15.46|
;;;319      }
;;;320      else
;;;321      {
;;;322        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L15.48|
;;;323      }
;;;324      return state;
000030  4620              MOV      r0,r4
;;;325    }
000032  bd38              POP      {r3-r5,pc}
;;;326    
                          ENDP


                          AREA ||i.RST_CLK_HSIadjust||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIadjust PROC
;;;459      */
;;;460    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
000000  4601              MOV      r1,r0
;;;461    {
;;;462      uint32_t temp;
;;;463      /* Check the parameters */
;;;464      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;465      temp = MDR_BKP->REG_0F;
000002  4a04              LDR      r2,|L16.20|
000004  6bd0              LDR      r0,[r2,#0x3c]
;;;466      /* Clear HSITRIM[5:0] bits */
;;;467      temp &= ~HSITRIM_MASK;
000006  f020507c          BIC      r0,r0,#0x3f000000
;;;468      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;469      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
00000a  ea406001          ORR      r0,r0,r1,LSL #24
;;;470      /* Store the new value */
;;;471      MDR_BKP->REG_0F = temp;
00000e  63d0              STR      r0,[r2,#0x3c]
;;;472    }
000010  4770              BX       lr
;;;473    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_HSIclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIclkPrescaler PROC
;;;1265     */
;;;1266   void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
000000  4601              MOV      r1,r0
;;;1267   {
;;;1268     uint32_t temp;
;;;1269   
;;;1270     /* Check the parameters */
;;;1271     assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;1272   
;;;1273     temp = MDR_RST_CLK->RTC_CLOCK;
000002  4a04              LDR      r2,|L17.20|
000004  6990              LDR      r0,[r2,#0x18]
;;;1274     /* Clear HSI_SEL bits */
;;;1275     temp &= HSI_SELclr;
000006  f02000f0          BIC      r0,r0,#0xf0
;;;1276     /* Set the HSI_SEL bits */
;;;1277     temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
00000a  ea401001          ORR      r0,r0,r1,LSL #4
;;;1278     /* Store the new value */
;;;1279     MDR_RST_CLK->RTC_CLOCK = temp;
00000e  6190              STR      r0,[r2,#0x18]
;;;1280   }
000010  4770              BX       lr
;;;1281   
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSIcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIcmd PROC
;;;424      */
;;;425    void RST_CLK_HSIcmd(FunctionalState NewState)
000000  4901              LDR      r1,|L18.8|
;;;426    {
;;;427    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;428      uint32_t temp = 0;
;;;429    #endif
;;;430      /* Check the parameters */
;;;431      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;432    
;;;433    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;434      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;435    #endif
;;;436    
;;;437    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;438    
;;;439        temp = MDR_BKP->REG_0F;
;;;440      /* Form new value */
;;;441      if (NewState != DISABLE){
;;;442        /* Enable HSI clk by setting the HSE_ON bit in the BKP_REG_0F register */
;;;443        temp |= BKP_REG_0F_HSI_ON;
;;;444      }
;;;445      else{
;;;446        /* Disable HSI clk by resetting the HSE_ON bit in the BKP_REG_0F register */
;;;447        temp &= ~BKP_REG_0F_HSI_ON;
;;;448      }
;;;449      /* Configure REG_0F register with new value */
;;;450      MDR_BKP->REG_0F = temp;
;;;451    #endif /* defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) */
;;;452    }
000004  4770              BX       lr
;;;453    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x43b007d8

                          AREA ||i.RST_CLK_HSIstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_HSIstatus PROC
;;;478      */
;;;479    ErrorStatus RST_CLK_HSIstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;480    {
;;;481      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;482      ErrorStatus state;
;;;483      FlagStatus flag;
;;;484    
;;;485      /* Wait until HSI is ready or time out is occure */
;;;486      do
000006  bf00              NOP      
                  |L19.8|
;;;487      {
;;;488        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
000008  2017              MOVS     r0,#0x17
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;489        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;490      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L19.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L19.8|
                  |L19.34|
;;;491    
;;;492      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
000022  2017              MOVS     r0,#0x17
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L19.46|
;;;493      {
;;;494        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L19.48|
                  |L19.46|
;;;495      }
;;;496      else
;;;497      {
;;;498        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L19.48|
;;;499      }
;;;500      return state;
000030  4620              MOV      r0,r4
;;;501    }
000032  bd38              POP      {r3-r5,pc}
;;;502    
                          ENDP


                          AREA ||i.RST_CLK_LSEconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSEconfig PROC
;;;365      */
;;;366    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
000000  490d              LDR      r1,|L20.56|
;;;367    {
;;;368      /* Check the parameters */
;;;369      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;370      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;371      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
000002  6bc9              LDR      r1,[r1,#0x3c]
000004  f0210103          BIC      r1,r1,#3
000008  4a0b              LDR      r2,|L20.56|
00000a  63d1              STR      r1,[r2,#0x3c]
;;;372      switch (RST_CLK_LSE)
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L20.22|
000010  2802              CMP      r0,#2
000012  d10e              BNE      |L20.50|
000014  e006              B        |L20.36|
                  |L20.22|
;;;373      {
;;;374        case RST_CLK_LSE_ON:
;;;375          /* Set LSEON bit */
;;;376          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
000016  4908              LDR      r1,|L20.56|
000018  6bc9              LDR      r1,[r1,#0x3c]
00001a  f0410101          ORR      r1,r1,#1
00001e  4a06              LDR      r2,|L20.56|
000020  63d1              STR      r1,[r2,#0x3c]
;;;377          break;
000022  e007              B        |L20.52|
                  |L20.36|
;;;378    
;;;379        case RST_CLK_LSE_Bypass:
;;;380          /* Set LSEBYP and LSEON bits */
;;;381          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
000024  4904              LDR      r1,|L20.56|
000026  6bc9              LDR      r1,[r1,#0x3c]
000028  f0410103          ORR      r1,r1,#3
00002c  4a02              LDR      r2,|L20.56|
00002e  63d1              STR      r1,[r2,#0x3c]
;;;382          break;
000030  e000              B        |L20.52|
                  |L20.50|
;;;383    
;;;384        default:
;;;385          break;
000032  bf00              NOP      
                  |L20.52|
000034  bf00              NOP                            ;377
;;;386      }
;;;387    }
000036  4770              BX       lr
;;;388    
                          ENDP

                  |L20.56|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_LSEstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_LSEstatus PROC
;;;393      */
;;;394    ErrorStatus RST_CLK_LSEstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;395    {
;;;396      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;397      ErrorStatus state;
;;;398      FlagStatus flag;
;;;399    
;;;400     /* Wait until LSE is ready or time out is occure */
;;;401     do
000006  bf00              NOP      
                  |L21.8|
;;;402      {
;;;403        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
000008  200d              MOVS     r0,#0xd
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;404        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;405      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L21.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L21.8|
                  |L21.34|
;;;406    
;;;407      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
000022  200d              MOVS     r0,#0xd
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L21.46|
;;;408      {
;;;409        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L21.48|
                  |L21.46|
;;;410      }
;;;411      else
;;;412      {
;;;413        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L21.48|
;;;414      }
;;;415      return state;
000030  4620              MOV      r0,r4
;;;416    }
000032  bd38              POP      {r3-r5,pc}
;;;417    
                          ENDP


                          AREA ||i.RST_CLK_LSIadjust||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSIadjust PROC
;;;544      */
;;;545    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
000000  4601              MOV      r1,r0
;;;546    {
;;;547      uint32_t temp;
;;;548      /* Check the parameters */
;;;549      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;550      temp = MDR_BKP->REG_0F;
000002  4a04              LDR      r2,|L22.20|
000004  6bd0              LDR      r0,[r2,#0x3c]
;;;551      /* Clear LSITRIM[4:0] bits */
;;;552      temp &= ~LSITRIM_MASK;
000006  f42010f8          BIC      r0,r0,#0x1f0000
;;;553      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;554      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
00000a  ea404001          ORR      r0,r0,r1,LSL #16
;;;555      /* Store the new value */
;;;556      MDR_BKP->REG_0F = temp;
00000e  63d0              STR      r0,[r2,#0x3c]
;;;557    }
000010  4770              BX       lr
;;;558    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_LSIcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSIcmd PROC
;;;509      */
;;;510    void RST_CLK_LSIcmd(FunctionalState NewState)
000000  4901              LDR      r1,|L23.8|
;;;511    {
;;;512    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;513      uint32_t temp = 0;
;;;514    #endif
;;;515      /* Check the parameters */
;;;516      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;517    
;;;518    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;519      *(__IO uint32_t *) LSION_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;520    #endif
;;;521    
;;;522    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;523    
;;;524      temp = MDR_BKP->REG_0F;
;;;525      /* Form new value */
;;;526      if (NewState != DISABLE) {
;;;527        /* Enable LSI clk by setting the LSE_ON bit in the BKP_REG_0F register */
;;;528        temp |= BKP_REG_0F_LSI_ON;
;;;529      }
;;;530      else {
;;;531        /* Disable LSI clk by resetting the LSE_ON bit in the BKP_REG_0F register */
;;;532        temp &= ~BKP_REG_0F_LSI_ON;
;;;533      }
;;;534      /* Configure REG_0F register with new value */
;;;535      MDR_BKP->REG_0F = temp;
;;;536    #endif
;;;537    }
000004  4770              BX       lr
;;;538    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x43b007bc

                          AREA ||i.RST_CLK_LSIstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_LSIstatus PROC
;;;563      */
;;;564    ErrorStatus RST_CLK_LSIstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;565    {
;;;566      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;567      ErrorStatus state;
;;;568      FlagStatus flag;
;;;569    
;;;570      /* Wait until LSI is ready or time out is occure */
;;;571      do
000006  bf00              NOP      
                  |L24.8|
;;;572      {
;;;573        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
000008  2015              MOVS     r0,#0x15
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;574        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;575      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L24.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L24.8|
                  |L24.34|
;;;576    
;;;577      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
000022  2015              MOVS     r0,#0x15
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L24.46|
;;;578      {
;;;579        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L24.48|
                  |L24.46|
;;;580      }
;;;581      else
;;;582      {
;;;583        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L24.48|
;;;584      }
;;;585      return (state);
000030  4620              MOV      r0,r4
;;;586    }
000032  bd38              POP      {r3-r5,pc}
;;;587    
                          ENDP


                          AREA ||i.RST_CLK_PCLKcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;1421     */
;;;1422   void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  b129              CBZ      r1,|L25.14|
;;;1423   {
;;;1424     /* Check the parameters */
;;;1425     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1426     assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;1427     if (NewState != DISABLE)
;;;1428     {
;;;1429       MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000002  4a06              LDR      r2,|L25.28|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L25.28|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L25.24|
                  |L25.14|
;;;1430     }
;;;1431     else
;;;1432     {
;;;1433       MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
00000e  4a03              LDR      r2,|L25.28|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L25.28|
000016  61da              STR      r2,[r3,#0x1c]
                  |L25.24|
;;;1434     }
;;;1435   }
000018  4770              BX       lr
;;;1436   
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_RTC_HSEclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_RTC_HSEclkEnable PROC
;;;1356     */
;;;1357   void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;1358   {
;;;1359   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1360     uint32_t temp = 0;
;;;1361   #endif
;;;1362     /* Check the parameters */
;;;1363     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1364   
;;;1365   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1366     *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1367   #endif
;;;1368   
;;;1369   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1370   
;;;1371       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1372     /* Form new value */
;;;1373     if (NewState != DISABLE){
;;;1374       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1375       temp |= RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1376     }
;;;1377     else{
;;;1378       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1379       temp &= ~RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1380     }
;;;1381     /* Configure RTC_CLOCK register with new value */
;;;1382     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1383   
;;;1384   #endif
;;;1385   }
000004  4770              BX       lr
;;;1386   
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42400320

                          AREA ||i.RST_CLK_RTC_HSIclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_RTC_HSIclkEnable PROC
;;;1288     */
;;;1289   void RST_CLK_RTC_HSIclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L27.8|
;;;1290   {
;;;1291   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1292     uint32_t temp = 0;
;;;1293   #endif
;;;1294     /* Check the parameters */
;;;1295     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1296   
;;;1297   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1298     *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1299   #endif
;;;1300   
;;;1301   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1302   
;;;1303       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1304     /* Form new value */
;;;1305     if (NewState != DISABLE){
;;;1306       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1307       temp |= RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1308     }
;;;1309     else{
;;;1310       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1311       temp &= ~RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1312     }
;;;1313     /* Configure RTC_CLOCK register with new value */
;;;1314     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1315   
;;;1316   #endif
;;;1317   }
000004  4770              BX       lr
;;;1318   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x42400324

                          AREA ||i.RST_CLK_USB_PLLcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLcmd PROC
;;;919      */
;;;920    void RST_CLK_USB_PLLcmd ( FunctionalState NewState )
000000  4901              LDR      r1,|L28.8|
;;;921    {
;;;922    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;923      uint32_t temp = 0;
;;;924    #endif
;;;925      /* Check the parameters */
;;;926      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;927    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;928      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;929    #endif
;;;930    
;;;931    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;932    
;;;933      temp = MDR_RST_CLK->PLL_CONTROL;
;;;934      /* Form a new value */
;;;935      if( NewState != DISABLE ) {
;;;936        temp |= RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;937      }
;;;938      else {
;;;939        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;940      }
;;;941      MDR_RST_CLK->PLL_CONTROL = temp;
;;;942    #endif
;;;943    
;;;944    }
000004  4770              BX       lr
;;;945    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42400080

                          AREA ||i.RST_CLK_USB_PLLconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLconfig PROC
;;;833      */
;;;834    void RST_CLK_USB_PLLconfig ( uint32_t RST_CLK_USB_PLLsource,
000000  b510              PUSH     {r4,lr}
;;;835                             uint32_t RST_CLK_USB_PLLmul )
;;;836    {
000002  4602              MOV      r2,r0
;;;837      uint32_t temp;
;;;838    
;;;839      /* Check the parameters */
;;;840      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;841      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;842    
;;;843      /* Select USBPLL source */
;;;844      temp = MDR_RST_CLK->USB_CLOCK;
000004  4b0c              LDR      r3,|L29.56|
000006  6918              LDR      r0,[r3,#0x10]
;;;845      /* Clear USB_C1_SEL bits */
;;;846      temp &= USB_C1_SELclr;
000008  f0200003          BIC      r0,r0,#3
;;;847      /* Set the USB_C1_SEL bits */
;;;848      temp |= RST_CLK_USB_PLLsource;
00000c  4310              ORRS     r0,r0,r2
;;;849      /* Store the new value */
;;;850      MDR_RST_CLK->USB_CLOCK = temp;
00000e  6118              STR      r0,[r3,#0x10]
;;;851    
;;;852      /* Set USBPLL multiplier */
;;;853      temp = MDR_RST_CLK->PLL_CONTROL;
000010  6858              LDR      r0,[r3,#4]
;;;854      /* Clear PLLMUL[3:0] bits */
;;;855      temp &= PLLUSBmulclr;
000012  f02000f0          BIC      r0,r0,#0xf0
;;;856      /* Set the PLLMUL[3:0] bits */
;;;857      temp |= (RST_CLK_USB_PLLmul << PLLUSBMUL_OFFSET);
000016  ea401001          ORR      r0,r0,r1,LSL #4
;;;858      /* Store the new value */
;;;859      MDR_RST_CLK->PLL_CONTROL = temp;
00001a  6058              STR      r0,[r3,#4]
;;;860    
;;;861    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;862      if (*(__IO uint32_t *) PLLUSBON_BB) {
00001c  4b07              LDR      r3,|L29.60|
00001e  681b              LDR      r3,[r3,#0]
000020  b143              CBZ      r3,|L29.52|
;;;863        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x01;
000022  2301              MOVS     r3,#1
000024  4c05              LDR      r4,|L29.60|
000026  1d24              ADDS     r4,r4,#4
000028  6023              STR      r3,[r4,#0]
;;;864        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x00;
00002a  2300              MOVS     r3,#0
00002c  4c03              LDR      r4,|L29.60|
00002e  3c80              SUBS     r4,r4,#0x80
000030  f8c43084          STR      r3,[r4,#0x84]
                  |L29.52|
;;;865      }
;;;866    #endif
;;;867    
;;;868    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;869      if( MDR_RST_CLK->PLL_CONTROL & (RST_CLK_PLL_CONTROL_PLL_USB_ON) ) {
;;;870        temp = MDR_RST_CLK->PLL_CONTROL;
;;;871        temp |= RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;872        MDR_RST_CLK->PLL_CONTROL = temp;
;;;873        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;874        MDR_RST_CLK->PLL_CONTROL = temp;
;;;875      }
;;;876    #endif
;;;877    }
000034  bd10              POP      {r4,pc}
;;;878    
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      0x40020000
                  |L29.60|
                          DCD      0x42400080

                          AREA ||i.RST_CLK_USB_PLLstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_USB_PLLstatus PROC
;;;950      */
;;;951    ErrorStatus RST_CLK_USB_PLLstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;952    {
;;;953      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;954      ErrorStatus state;
;;;955      FlagStatus flag;
;;;956    
;;;957      /* Wait until USBPLL is ready or time out is occure */
;;;958      do
000006  bf00              NOP      
                  |L30.8|
;;;959      {
;;;960        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
000008  2020              MOVS     r0,#0x20
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;961        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;962      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L30.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L30.8|
                  |L30.34|
;;;963    
;;;964      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
000022  2020              MOVS     r0,#0x20
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L30.46|
;;;965      {
;;;966        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L30.48|
                  |L30.46|
;;;967      }
;;;968      else
;;;969      {
;;;970        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L30.48|
;;;971      }
;;;972      return state;
000030  4620              MOV      r0,r4
;;;973    }
000032  bd38              POP      {r3-r5,pc}
;;;974    
                          ENDP


                          AREA ||i.RST_CLK_USB_PLLuse||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLuse PROC
;;;883      */
;;;884    void RST_CLK_USB_PLLuse ( FunctionalState UsePLL )
000000  4901              LDR      r1,|L31.8|
;;;885    {
;;;886    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;887      uint32_t temp = 0;
;;;888    #endif
;;;889      /* Check the parameters */
;;;890      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;891    
;;;892    #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* for Cortex M3 series */
;;;893      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t) UsePLL;
000002  6008              STR      r0,[r1,#0]
;;;894    #endif // #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;895    
;;;896    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;897    
;;;898      temp = MDR_RST_CLK->USB_CLOCK;
;;;899      /* Form new value */
;;;900      if (UsePLL != DISABLE){
;;;901        /* Use the USB PLL output as input for USB_C3_SEL
;;;902         * by setting the USB_C2_SEL bit in the USB_CLOCK register */
;;;903        temp |= (1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;904      }
;;;905      else{
;;;906        /* Use the USB_C1 output as input for USB_C3_SEL
;;;907         * by resetting the USB_C2_SEL bit in the USB_CLOCK register */
;;;908        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;909      }
;;;910      /* Configure USB_CLOCK register with new value */
;;;911      MDR_RST_CLK->USB_CLOCK = temp;
;;;912    #endif
;;;913    }
000004  4770              BX       lr
;;;914    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x42400208

                          AREA ||i.RST_CLK_USBclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_USBclkEnable PROC
;;;1019     */
;;;1020   void RST_CLK_USBclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L32.8|
;;;1021   {
;;;1022   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1023     uint32_t temp = 0;
;;;1024   #endif
;;;1025     /* Check the parameters */
;;;1026     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1027   
;;;1028   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1029     *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1030   #endif
;;;1031   
;;;1032   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1033   
;;;1034     temp = MDR_RST_CLK->USB_CLOCK;
;;;1035   
;;;1036     /* Form new value */
;;;1037     if (NewState != DISABLE){
;;;1038       /* Enable the USB clk by setting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1039       temp |= (1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1040     }
;;;1041     else{
;;;1042       /* Disable the USB clk by resetting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1043       temp &= ~(1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1044     }
;;;1045     /* Configure USB_CLOCK register with new value */
;;;1046     MDR_RST_CLK->USB_CLOCK = temp;
;;;1047   #endif
;;;1048   }
000004  4770              BX       lr
;;;1049   
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42400220

                          AREA ||i.RST_CLK_USBclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_USBclkPrescaler PROC
;;;981      */
;;;982    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;983    {
;;;984    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;985      uint32_t temp = 0;
;;;986    #endif
;;;987      /* Check the parameters */
;;;988      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;989    
;;;990    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;991       *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;992    #endif
;;;993    
;;;994    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;995    
;;;996      temp = MDR_RST_CLK->USB_CLOCK;
;;;997    
;;;998      /* Form new value */
;;;999      if (NewState != DISABLE){
;;;1000       /* Enable the USB prescaler by setting the USB_C3_SEL bit in the USB_CLOCK register */
;;;1001       temp |= (1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;1002     }
;;;1003     else{
;;;1004       /* Disable the USB prescaler by resetting the USB_C3_SEL bit in the USB_CLOCK register */
;;;1005       temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;1006     }
;;;1007     /* Configure USB_CLOCK register with new value */
;;;1008     MDR_RST_CLK->USB_CLOCK = temp;
;;;1009   #endif
;;;1010   
;;;1011   }
000004  4770              BX       lr
;;;1012   
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x42400210

                          AREA ||i.RST_CLK_WarmDeInit||, CODE, READONLY, ALIGN=2

                  RST_CLK_WarmDeInit PROC
;;;200      */
;;;201    void RST_CLK_WarmDeInit(void)
000000  b500              PUSH     {lr}
;;;202    {
;;;203      /* Prepare HSI clk */
;;;204      RST_CLK_HSIcmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RST_CLK_HSIcmd
;;;205      RST_CLK_HSIstatus();
000008  f7fffffe          BL       RST_CLK_HSIstatus
;;;206      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;207    
;;;208      /* Reset CPU_CLOCK bits */
;;;209      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
000012  480e              LDR      r0,|L34.76|
000014  68c0              LDR      r0,[r0,#0xc]
000016  2000              MOVS     r0,#0
000018  490c              LDR      r1,|L34.76|
00001a  60c8              STR      r0,[r1,#0xc]
;;;210    
;;;211      /* Reset PLL_CONTROL bits */
;;;212      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
00001c  4608              MOV      r0,r1
00001e  6840              LDR      r0,[r0,#4]
000020  2000              MOVS     r0,#0
000022  6048              STR      r0,[r1,#4]
;;;213    
;;;214      /* Reset HSEON and HSEBYP bits */
;;;215      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
000024  4608              MOV      r0,r1
000026  6880              LDR      r0,[r0,#8]
000028  2000              MOVS     r0,#0
00002a  6088              STR      r0,[r1,#8]
;;;216    
;;;217      /* Reset USB_CLOCK bits */
;;;218      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
00002c  4608              MOV      r0,r1
00002e  6900              LDR      r0,[r0,#0x10]
000030  2000              MOVS     r0,#0
000032  6108              STR      r0,[r1,#0x10]
;;;219    
;;;220      /* Reset ADC_MCO_CLOCK bits */
;;;221      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
000034  4608              MOV      r0,r1
000036  6940              LDR      r0,[r0,#0x14]
000038  2000              MOVS     r0,#0
00003a  6148              STR      r0,[r1,#0x14]
;;;222    
;;;223      /* Reset RTC_CLOCK bits */
;;;224      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
00003c  4608              MOV      r0,r1
00003e  6980              LDR      r0,[r0,#0x18]
000040  2000              MOVS     r0,#0
000042  6188              STR      r0,[r1,#0x18]
;;;225    
;;;226      /* Reset all clock but RTC_CLK bit */
;;;227      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
000044  4802              LDR      r0,|L34.80|
000046  61c8              STR      r0,[r1,#0x1c]
;;;228    }
000048  bd00              POP      {pc}
;;;229    
                          ENDP

00004a  0000              DCW      0x0000
                  |L34.76|
                          DCD      0x40020000
                  |L34.80|
                          DCD      0x08000010

;*** Start embedded assembler ***

#line 1 "C:\\Keil_v5\\ARM\\PACK\\Keil\\MDR1986BExx\\1.4\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 447 "C:\\Keil_v5\\ARM\\PACK\\ARM\\CMSIS\\5.0.1\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 448

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 462
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 463

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____RRX|
#line 649
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____RRX| PROC
#line 650

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
