; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mdr32f9qx_rst_clk.o --asm_dir=.\obj\ --list_dir=.\obj\ --depend=.\obj\mdr32f9qx_rst_clk.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I"..\CAN TEST" -I.\RTE -I.\RTE\Device -I.\RTE\Device\MDR1986BE92 -I.\rtos -I.\rtos\include -I.\RTE\Device\MDR1986BE92 -I.\RTE\_Target_1 -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\Core\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\ARM\CMSIS\5.5.1\CMSIS\DSP\Include -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Config -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\CoreSupport -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\CMSIS\CM3\DeviceSupport\MDR32F9Qx\inc -IC:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\inc -D__MICROLIB -D__UVISION_VERSION=527 -D_RTE_ -DUSE_MDR32F9Q2_Rev1 --omf_browse=.\obj\mdr32f9qx_rst_clk.crf C:\Users\AN-Mi\AppData\Local\Arm\Packs\Keil\MDR1986BExx\1.51\Libraries\MDR32F9Qx_StdPeriph_Driver\src\MDR32F9Qx_rst_clk.c]
                          THUMB

                          AREA ||i.RST_CLK_ADCclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkEnable PROC
;;;1097     */
;;;1098   void RST_CLK_ADCclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L1.8|
;;;1099   {
;;;1100   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1101     uint32_t temp = 0;
;;;1102   #endif
;;;1103     /* Check the parameters */
;;;1104     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1105   
;;;1106   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1107     *(__IO uint32_t *) ADC_CLK_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1108   #endif
;;;1109   
;;;1110   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1111   
;;;1112     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
;;;1113     /* Form new value */
;;;1114     if (NewState != DISABLE){
;;;1115       /* Enable the ADC CLK by setting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1116       temp |= RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1117     }
;;;1118     else{
;;;1119       /* Disable the ADC CLK by resetting the ADC_CLK_EN bit in the ADC_MCO_CLOCK register */
;;;1120       temp &= ~RST_CLK_ADC_MCO_CLOCK_ADC_CLK_EN;
;;;1121     }
;;;1122     /* Configure CPU_CLOCK register with new value */
;;;1123     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
;;;1124   #endif
;;;1125   
;;;1126   }
000004  4770              BX       lr
;;;1127   
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
                          DCD      0x424002b4

                          AREA ||i.RST_CLK_ADCclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkPrescaler PROC
;;;1074     */
;;;1075   void RST_CLK_ADCclkPrescaler(uint32_t ADCclkDivValue)
000000  4601              MOV      r1,r0
;;;1076   {
;;;1077     uint32_t temp;
;;;1078   
;;;1079     /* Check the parameters */
;;;1080     assert_param(IS_RST_CLK_ADCclkDivValue(ADCclkDivValue));
;;;1081   
;;;1082     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000002  4a04              LDR      r2,|L2.20|
000004  6950              LDR      r0,[r2,#0x14]
;;;1083     /* Clear ADC_C3_SEL bits */
;;;1084     temp &= ADC_C3_SELclr;
000006  f4206070          BIC      r0,r0,#0xf00
;;;1085     /* Set the ADC_C3_SEL bits */
;;;1086     temp |= ADCclkDivValue<<ADC_C3_SEL_OFFSET;
00000a  ea402001          ORR      r0,r0,r1,LSL #8
;;;1087     /* Store the new value */
;;;1088     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00000e  6150              STR      r0,[r2,#0x14]
;;;1089   }
000010  4770              BX       lr
;;;1090   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_ADCclkSelection||, CODE, READONLY, ALIGN=2

                  RST_CLK_ADCclkSelection PROC
;;;1042     */
;;;1043   void RST_CLK_ADCclkSelection(uint32_t ADC_CLK)
000000  4601              MOV      r1,r0
;;;1044   {
;;;1045     uint32_t temp;
;;;1046   
;;;1047     /* Check the parameters */
;;;1048     assert_param(IS_RST_CLK_ADCclk(ADC_CLK));
;;;1049   
;;;1050     /* Select ADC_CLK source */
;;;1051     temp = MDR_RST_CLK->ADC_MCO_CLOCK;
000002  4a03              LDR      r2,|L3.16|
000004  6950              LDR      r0,[r2,#0x14]
;;;1052     /* Clear ADC_C1,C2 SEL bits */
;;;1053     temp &= ADC_C12_SELclr;
000006  f0200033          BIC      r0,r0,#0x33
;;;1054     /* Set the ADC_C1,C2 SEL bits */
;;;1055     temp |= ADC_CLK;
00000a  4308              ORRS     r0,r0,r1
;;;1056     /* Store the new value */
;;;1057     MDR_RST_CLK->ADC_MCO_CLOCK = temp;
00000c  6150              STR      r0,[r2,#0x14]
;;;1058   }
00000e  4770              BX       lr
;;;1059   
                          ENDP

                  |L3.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_CPU_PLLcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLcmd PROC
;;;678      */
;;;679    void RST_CLK_CPU_PLLcmd ( FunctionalState NewState )
000000  4901              LDR      r1,|L4.8|
;;;680    {
;;;681    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;682      uint32_t temp;
;;;683    #endif
;;;684      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;685    
;;;686    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;687      *(__IO uint32_t *) PLLCPUON_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;688    #endif
;;;689    
;;;690    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;691      temp = MDR_RST_CLK->PLL_CONTROL;
;;;692    
;;;693      if(NewState == ENABLE){
;;;694        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;695      }
;;;696      else{
;;;697        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_ON;
;;;698      }
;;;699      MDR_RST_CLK->PLL_CONTROL = temp;
;;;700    
;;;701    #endif
;;;702    }
000004  4770              BX       lr
;;;703    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      0x42400088

                          AREA ||i.RST_CLK_CPU_PLLconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLconfig PROC
;;;595      */
;;;596    void RST_CLK_CPU_PLLconfig ( uint32_t RST_CLK_CPU_PLLsource,
000000  b510              PUSH     {r4,lr}
;;;597                             uint32_t RST_CLK_CPU_PLLmul )
;;;598    {
000002  4602              MOV      r2,r0
;;;599      uint32_t temp;
;;;600    
;;;601      /* Check the parameters */
;;;602      assert_param(IS_RST_CLK_CPU_PLL_SOURCE(RST_CLK_CPU_PLLsource));
;;;603      assert_param(IS_RST_CLK_CPU_PLL_MUL(RST_CLK_CPU_PLLmul));
;;;604    
;;;605      /* Select CPUPLL source */
;;;606      temp = MDR_RST_CLK->CPU_CLOCK;
000004  4b0c              LDR      r3,|L5.56|
000006  68d8              LDR      r0,[r3,#0xc]
;;;607      /* Clear CPU_C1_SEL bits */
;;;608      temp &= CPU_C1_SELclr;
000008  f0200003          BIC      r0,r0,#3
;;;609      /* Set the CPU_C1_SEL bits */
;;;610      temp |= RST_CLK_CPU_PLLsource;
00000c  4310              ORRS     r0,r0,r2
;;;611      /* Store the new value */MDR_RST_CLK->CPU_CLOCK = temp;
00000e  60d8              STR      r0,[r3,#0xc]
;;;612    
;;;613      /* Set CPUPLL multiplier */
;;;614      temp = MDR_RST_CLK->PLL_CONTROL;
000010  6858              LDR      r0,[r3,#4]
;;;615      /* Clear PLLMUL[3:0] bits */
;;;616      temp &= PLLCPUmulclr;
000012  f4206070          BIC      r0,r0,#0xf00
;;;617      /* Set the PLLMUL[3:0] bits */
;;;618      temp |= (RST_CLK_CPU_PLLmul << PLLCPUMUL_OFFSET);
000016  ea402001          ORR      r0,r0,r1,LSL #8
;;;619      /* Store the new value */
;;;620      MDR_RST_CLK->PLL_CONTROL = temp;
00001a  6058              STR      r0,[r3,#4]
;;;621    
;;;622    #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T)
;;;623      if (*(__IO uint32_t *) PLLCPUON_BB) {
00001c  4b07              LDR      r3,|L5.60|
00001e  681b              LDR      r3,[r3,#0]
000020  b143              CBZ      r3,|L5.52|
;;;624        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x01;
000022  2301              MOVS     r3,#1
000024  4c05              LDR      r4,|L5.60|
000026  1d24              ADDS     r4,r4,#4
000028  6023              STR      r3,[r4,#0]
;;;625        *(__IO uint32_t *) PLLCPUPLD_BB = (uint32_t) 0x00;
00002a  2300              MOVS     r3,#0
00002c  4c03              LDR      r4,|L5.60|
00002e  3c88              SUBS     r4,r4,#0x88
000030  f8c4308c          STR      r3,[r4,#0x8c]
                  |L5.52|
;;;626      }
;;;627    #elif defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;628      if( (MDR_RST_CLK->PLL_CONTROL & RST_CLK_PLL_CONTROL_PLL_CPU_ON) == RST_CLK_PLL_CONTROL_PLL_CPU_ON ) {
;;;629        temp = MDR_RST_CLK->PLL_CONTROL;
;;;630        temp |= RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;631        MDR_RST_CLK->PLL_CONTROL = temp;
;;;632        temp &= ~RST_CLK_PLL_CONTROL_PLL_CPU_PLD;
;;;633        MDR_RST_CLK->PLL_CONTROL = temp;
;;;634      }
;;;635    #endif
;;;636    }
000034  bd10              POP      {r4,pc}
;;;637    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      0x40020000
                  |L5.60|
                          DCD      0x42400088

                          AREA ||i.RST_CLK_CPU_PLLstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_CPU_PLLstatus PROC
;;;708      */
;;;709    ErrorStatus RST_CLK_CPU_PLLstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;710    {
;;;711      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;712      ErrorStatus state;
;;;713      FlagStatus flag;
;;;714    
;;;715      /* Wait until CPUPLL is ready or time out is occure */
;;;716      do
000006  bf00              NOP      
                  |L6.8|
;;;717      {
;;;718        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY);
000008  2021              MOVS     r0,#0x21
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;719        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;720      } while ((startCounter < PLLCPUonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L6.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L6.8|
                  |L6.34|
;;;721    
;;;722      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLCPURDY) != RESET)
000022  2021              MOVS     r0,#0x21
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L6.46|
;;;723      {
;;;724        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L6.48|
                  |L6.46|
;;;725      }
;;;726      else
;;;727      {
;;;728        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L6.48|
;;;729      }
;;;730      return state;
000030  4620              MOV      r0,r4
;;;731    }
000032  bd38              POP      {r3-r5,pc}
;;;732    
                          ENDP


                          AREA ||i.RST_CLK_CPU_PLLuse||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPU_PLLuse PROC
;;;642      */
;;;643    void RST_CLK_CPU_PLLuse(FunctionalState UsePLL)
000000  4901              LDR      r1,|L7.8|
;;;644    {
;;;645    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;646      uint32_t temp = 0;
;;;647    #endif
;;;648      /* Check the parameters */
;;;649      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;650    
;;;651    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;652      *(__IO uint32_t *) CPU_C2_SEL_BB = (uint32_t) UsePLL;
000002  6008              STR      r0,[r1,#0]
;;;653    #endif
;;;654    
;;;655    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;656    
;;;657      temp = MDR_RST_CLK->CPU_CLOCK;
;;;658      /* Form new value */
;;;659      if (UsePLL != DISABLE){
;;;660        /* Use the CPU PLL output as input for CPU_C3_SEL
;;;661         * by setting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;662        temp |= (1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;663      }
;;;664      else{
;;;665        /* Use the CPU_C1 output as input for CPU_C3_SEL
;;;666         * by resetting the CPU_C2_SEL bit in the CPU_CLOCK register */
;;;667        temp &= ~(1<< RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos);
;;;668      }
;;;669      /* Configure CPU_CLOCK register with new value */
;;;670      MDR_RST_CLK->CPU_CLOCK = temp;
;;;671    #endif
;;;672    }
000004  4770              BX       lr
;;;673    
                          ENDP

000006  0000              DCW      0x0000
                  |L7.8|
                          DCD      0x42400188

                          AREA ||i.RST_CLK_CPUclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPUclkPrescaler PROC
;;;746      */
;;;747    void RST_CLK_CPUclkPrescaler(uint32_t CPUclkDivValue)
000000  4601              MOV      r1,r0
;;;748    {
;;;749      uint32_t temp;
;;;750    
;;;751      /* Check the parameters */
;;;752      assert_param(IS_RST_CLK_CPUclkDIV(CPUclkDivValue));
;;;753    
;;;754      temp = MDR_RST_CLK->CPU_CLOCK;
000002  4a04              LDR      r2,|L8.20|
000004  68d0              LDR      r0,[r2,#0xc]
;;;755      /* Clear CPU_C3_SEL bits */
;;;756      temp &= CPU_C3_SELclr;
000006  f02000f0          BIC      r0,r0,#0xf0
;;;757      /* Set the CPU_C3_SEL bits */
;;;758      temp |= (CPUclkDivValue << RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos);
00000a  ea401001          ORR      r0,r0,r1,LSL #4
;;;759      /* Store the new value */
;;;760      MDR_RST_CLK->CPU_CLOCK = temp;
00000e  60d0              STR      r0,[r2,#0xc]
;;;761    }
000010  4770              BX       lr
;;;762    
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_CPUclkSelection||, CODE, READONLY, ALIGN=2

                  RST_CLK_CPUclkSelection PROC
;;;771      */
;;;772    void RST_CLK_CPUclkSelection(uint32_t CPU_CLK)
000000  4601              MOV      r1,r0
;;;773    {
;;;774      uint32_t temp;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_RST_CPU_CLK(CPU_CLK));
;;;778    
;;;779      temp = MDR_RST_CLK->CPU_CLOCK;
000002  4a03              LDR      r2,|L9.16|
000004  68d0              LDR      r0,[r2,#0xc]
;;;780      /* Clear CPU_C3_SEL bits */
;;;781      temp &= CPU_HCLK_SELclr;
000006  f4207040          BIC      r0,r0,#0x300
;;;782      /* Set the CPU_C3_SEL bits */
;;;783      temp |= CPU_CLK;
00000a  4308              ORRS     r0,r0,r1
;;;784      /* Store the new value */
;;;785      MDR_RST_CLK->CPU_CLOCK = temp;
00000c  60d0              STR      r0,[r2,#0xc]
;;;786    }
00000e  4770              BX       lr
;;;787    
                          ENDP

                  |L9.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_DeInit||, CODE, READONLY, ALIGN=2

                  RST_CLK_DeInit PROC
;;;166      */
;;;167    void RST_CLK_DeInit(void)
000000  b500              PUSH     {lr}
;;;168    {
;;;169      RST_CLK_WarmDeInit();
000002  f7fffffe          BL       RST_CLK_WarmDeInit
;;;170      /* Reset REG_0F bits to zero but HSION bit */
;;;171      RST_CLK_PCLKcmd(RST_CLK_PCLK_BKP, ENABLE);
000006  2101              MOVS     r1,#1
000008  06c8              LSLS     r0,r1,#27
00000a  f7fffffe          BL       RST_CLK_PCLKcmd
;;;172      MDR_BKP->REG_0F |= (uint32_t)((1<<22)|(1<<15)); /* HSION & LSION */
00000e  4806              LDR      r0,|L10.40|
000010  6bc0              LDR      r0,[r0,#0x3c]
000012  f4400081          ORR      r0,r0,#0x408000
000016  4904              LDR      r1,|L10.40|
000018  63c8              STR      r0,[r1,#0x3c]
;;;173      MDR_BKP->REG_0F &= (uint32_t)((1<<22)|(1<<15));
00001a  4608              MOV      r0,r1
00001c  6bc0              LDR      r0,[r0,#0x3c]
00001e  f4000081          AND      r0,r0,#0x408000
000022  63c8              STR      r0,[r1,#0x3c]
;;;174    }
000024  bd00              POP      {pc}
;;;175    
                          ENDP

000026  0000              DCW      0x0000
                  |L10.40|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RST_CLK_GetClocksFreq PROC
;;;1452     */
;;;1453   void RST_CLK_GetClocksFreq(RST_CLK_FreqTypeDef* RST_CLK_Clocks)
000000  e92d4ffc          PUSH     {r2-r11,lr}
;;;1454   {
000004  4601              MOV      r1,r0
;;;1455     uint32_t cpu_c1_freq, cpu_c2_freq, cpu_c3_freq;
;;;1456     uint32_t usb_c1_freq, usb_c2_freq, usb_c3_freq;
;;;1457     uint32_t adc_c1_freq, adc_c2_freq, adc_c3_freq;
;;;1458     uint32_t hsi_c1_freq, hse_c1_freq;
;;;1459     uint32_t pll_mul;
;;;1460     uint32_t temp;
;;;1461   
;;;1462     /* Check the parameter */
;;;1463     assert_param(RST_CLK_Clocks != 0);
;;;1464   
;;;1465     /* Compute CPU_CLK, USB_CLK, ADC_CLK, RTCHSI, RTCHSE clocks frequencies */
;;;1466   
;;;1467     /* Compute CPU_CLK frequency */
;;;1468   
;;;1469     /* Determine CPU_C1 frequency */
;;;1470     if( MDR_RST_CLK->CPU_CLOCK & (2 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
000006  f8dfb264          LDR      r11,|L11.620|
00000a  f8dbb00c          LDR      r11,[r11,#0xc]
00000e  f00b0b02          AND      r11,r11,#2
000012  f1bb0f00          CMP      r11,#0
000016  d001              BEQ      |L11.28|
;;;1471       cpu_c1_freq = HSE_Value;
000018  4b95              LDR      r3,|L11.624|
00001a  e000              B        |L11.30|
                  |L11.28|
;;;1472     }
;;;1473     else {
;;;1474       cpu_c1_freq = HSI_Value;
00001c  4b94              LDR      r3,|L11.624|
                  |L11.30|
;;;1475     }
;;;1476     if( MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C1_SEL_Pos) ) {
00001e  f8dfb24c          LDR      r11,|L11.620|
000022  f8dbb00c          LDR      r11,[r11,#0xc]
000026  f00b0b01          AND      r11,r11,#1
00002a  f1bb0f00          CMP      r11,#0
00002e  d000              BEQ      |L11.50|
;;;1477       cpu_c1_freq /= 2;
000030  085b              LSRS     r3,r3,#1
                  |L11.50|
;;;1478     }
;;;1479   
;;;1480     /* Determine CPU_C2 frequency */
;;;1481     cpu_c2_freq = cpu_c1_freq;
000032  461c              MOV      r4,r3
;;;1482   
;;;1483     if (MDR_RST_CLK->CPU_CLOCK & (1 << RST_CLK_CPU_CLOCK_CPU_C2_SEL_Pos)) {
000034  f8dfb234          LDR      r11,|L11.620|
000038  f8dbb00c          LDR      r11,[r11,#0xc]
00003c  f00b0b04          AND      r11,r11,#4
000040  f1bb0f00          CMP      r11,#0
000044  d00d              BEQ      |L11.98|
;;;1484       /* Determine CPU PLL output frequency */
;;;1485       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
000046  f8dfb224          LDR      r11,|L11.620|
00004a  f8dbb004          LDR      r11,[r11,#4]
00004e  f3cb2b03          UBFX     r11,r11,#8,#4
000052  f10b0b01          ADD      r11,r11,#1
000056  f8cdb000          STR      r11,[sp,#0]
;;;1486           >> RST_CLK_PLL_CONTROL_PLL_CPU_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1487       cpu_c2_freq *= pll_mul;
00005a  f8ddb000          LDR      r11,[sp,#0]
00005e  fb04f40b          MUL      r4,r4,r11
                  |L11.98|
;;;1488     }
;;;1489   
;;;1490     /*Select CPU_CLK from HSI, CPU_C3, LSE, LSI cases */
;;;1491     switch ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_HCLK_SEL_Pos)
000062  f8dfb208          LDR      r11,|L11.620|
000066  f8dbb00c          LDR      r11,[r11,#0xc]
00006a  f3cb2b01          UBFX     r11,r11,#8,#2
00006e  f1bb0f00          CMP      r11,#0
000072  d006              BEQ      |L11.130|
000074  f1bb0f01          CMP      r11,#1
000078  d008              BEQ      |L11.140|
00007a  f1bb0f02          CMP      r11,#2
00007e  d128              BNE      |L11.210|
000080  e022              B        |L11.200|
                  |L11.130|
;;;1492         & (uint32_t) 0x03) {
;;;1493       case 0:
;;;1494         /* HSI */
;;;1495         RST_CLK_Clocks->CPU_CLK_Frequency = HSI_Value;
000082  f8dfb1ec          LDR      r11,|L11.624|
000086  f8c1b000          STR      r11,[r1,#0]
;;;1496         break;
00008a  e027              B        |L11.220|
                  |L11.140|
;;;1497       case 1:
;;;1498         /* CPU_C3 */
;;;1499         /* Determine CPU_C3 frequency */
;;;1500         if ((MDR_RST_CLK->CPU_CLOCK >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
00008c  f8dfb1dc          LDR      r11,|L11.620|
000090  f8dbb00c          LDR      r11,[r11,#0xc]
000094  f04f0e08          MOV      lr,#8
000098  ea0e1b1b          AND      r11,lr,r11,LSR #4
00009c  f1bb0f00          CMP      r11,#0
0000a0  d101              BNE      |L11.166|
;;;1501             & (uint32_t) 0x08) == 0x00) {
;;;1502           cpu_c3_freq = cpu_c2_freq;
0000a2  46a0              MOV      r8,r4
0000a4  e00d              B        |L11.194|
                  |L11.166|
;;;1503         }
;;;1504         else {
;;;1505           cpu_c3_freq = cpu_c2_freq
0000a6  f8dfb1c4          LDR      r11,|L11.620|
0000aa  f8dbb00c          LDR      r11,[r11,#0xc]
0000ae  f3cb1b02          UBFX     r11,r11,#4,#3
0000b2  f10b0b01          ADD      r11,r11,#1
0000b6  f04f0e01          MOV      lr,#1
0000ba  fa0efe0b          LSL      lr,lr,r11
0000be  fbb4f8fe          UDIV     r8,r4,lr
                  |L11.194|
;;;1506               / (1
;;;1507                   << ((MDR_RST_CLK->CPU_CLOCK
;;;1508                       >> RST_CLK_CPU_CLOCK_CPU_C3_SEL_Pos
;;;1509                       & (uint32_t) 0x07) + 1));
;;;1510         }
;;;1511         RST_CLK_Clocks->CPU_CLK_Frequency = cpu_c3_freq;
0000c2  f8c18000          STR      r8,[r1,#0]
;;;1512         break;
0000c6  e009              B        |L11.220|
                  |L11.200|
;;;1513       case 2:
;;;1514         /* LSE */
;;;1515         RST_CLK_Clocks->CPU_CLK_Frequency = LSE_Value;
0000c8  f44f4b00          MOV      r11,#0x8000
0000cc  f8c1b000          STR      r11,[r1,#0]
;;;1516         break;
0000d0  e004              B        |L11.220|
                  |L11.210|
;;;1517       default: /* case 3 */
;;;1518         /* LSI */
;;;1519         RST_CLK_Clocks->CPU_CLK_Frequency = LSI_Value;
0000d2  f6494b40          MOV      r11,#0x9c40
0000d6  f8c1b000          STR      r11,[r1,#0]
;;;1520         break;
0000da  bf00              NOP      
                  |L11.220|
0000dc  bf00              NOP                            ;1496
;;;1521     }
;;;1522   
;;;1523     /* Compute USB_CLK frequency */
;;;1524   
;;;1525     /* Determine USB_C1 frequency */
;;;1526     if( MDR_RST_CLK->USB_CLOCK & (2 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
0000de  f8dfb18c          LDR      r11,|L11.620|
0000e2  f8dbb010          LDR      r11,[r11,#0x10]
0000e6  f00b0b02          AND      r11,r11,#2
0000ea  f1bb0f00          CMP      r11,#0
0000ee  d001              BEQ      |L11.244|
;;;1527       usb_c1_freq = HSE_Value;
0000f0  4d5f              LDR      r5,|L11.624|
0000f2  e000              B        |L11.246|
                  |L11.244|
;;;1528     }
;;;1529     else {
;;;1530       usb_c1_freq = HSI_Value;
0000f4  4d5e              LDR      r5,|L11.624|
                  |L11.246|
;;;1531     }
;;;1532   
;;;1533     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C1_SEL_Pos) ) {
0000f6  f8dfb174          LDR      r11,|L11.620|
0000fa  f8dbb010          LDR      r11,[r11,#0x10]
0000fe  f00b0b01          AND      r11,r11,#1
000102  f1bb0f00          CMP      r11,#0
000106  d000              BEQ      |L11.266|
;;;1534       usb_c1_freq /= 2;
000108  086d              LSRS     r5,r5,#1
                  |L11.266|
;;;1535     }
;;;1536   
;;;1537     /* Determine USB_C2 frequency */
;;;1538     usb_c2_freq = usb_c1_freq;
00010a  462f              MOV      r7,r5
;;;1539   
;;;1540     if( MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C2_SEL_Pos) ){
00010c  f8dfb15c          LDR      r11,|L11.620|
000110  f8dbb010          LDR      r11,[r11,#0x10]
000114  f00b0b04          AND      r11,r11,#4
000118  f1bb0f00          CMP      r11,#0
00011c  d00d              BEQ      |L11.314|
;;;1541       /* Determine USB PLL output frequency */
;;;1542       pll_mul = ((MDR_RST_CLK->PLL_CONTROL
00011e  f8dfb14c          LDR      r11,|L11.620|
000122  f8dbb004          LDR      r11,[r11,#4]
000126  f3cb1b03          UBFX     r11,r11,#4,#4
00012a  f10b0b01          ADD      r11,r11,#1
00012e  f8cdb000          STR      r11,[sp,#0]
;;;1543           >> RST_CLK_PLL_CONTROL_PLL_USB_MUL_Pos) & (uint32_t) 0x0F) + 1;
;;;1544       usb_c2_freq *= pll_mul;
000132  f8ddb000          LDR      r11,[sp,#0]
000136  fb07f70b          MUL      r7,r7,r11
                  |L11.314|
;;;1545     }
;;;1546   
;;;1547     /* Determine USB_C3 frequency */
;;;1548     usb_c3_freq = usb_c2_freq;
00013a  46b9              MOV      r9,r7
;;;1549     if(MDR_RST_CLK->USB_CLOCK & (1 << RST_CLK_USB_CLOCK_USB_C3_SEL_Pos)){
00013c  f8dfb12c          LDR      r11,|L11.620|
000140  f8dbb010          LDR      r11,[r11,#0x10]
000144  f00b0b10          AND      r11,r11,#0x10
000148  f1bb0f00          CMP      r11,#0
00014c  d001              BEQ      |L11.338|
;;;1550       usb_c3_freq /= 2;
00014e  ea4f0959          LSR      r9,r9,#1
                  |L11.338|
;;;1551     }
;;;1552   
;;;1553     RST_CLK_Clocks->USB_CLK_Frequency = usb_c3_freq;
000152  f8c19004          STR      r9,[r1,#4]
;;;1554   
;;;1555     /* Compute RTCHSI_CLK frequency */
;;;1556     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSI_SEL_Pos;
000156  f8dfb114          LDR      r11,|L11.620|
00015a  f8dbb018          LDR      r11,[r11,#0x18]
00015e  ea4f101b          LSR      r0,r11,#4
;;;1557     if ((temp & 0x08U) == 0) {
000162  f0000b08          AND      r11,r0,#8
000166  f1bb0f00          CMP      r11,#0
00016a  d102              BNE      |L11.370|
;;;1558       hsi_c1_freq = HSI_Value;
00016c  f8dfc100          LDR      r12,|L11.624|
000170  e00b              B        |L11.394|
                  |L11.370|
;;;1559     }
;;;1560     else {
;;;1561       temp = 1 << ((temp & 0x07U) + 1);
000172  f0000b07          AND      r11,r0,#7
000176  f10b0b01          ADD      r11,r11,#1
00017a  f04f0e01          MOV      lr,#1
00017e  fa0ef00b          LSL      r0,lr,r11
;;;1562       hsi_c1_freq = HSI_Value / temp;
000182  f8dfb0ec          LDR      r11,|L11.624|
000186  fbbbfcf0          UDIV     r12,r11,r0
                  |L11.394|
;;;1563     }
;;;1564     RST_CLK_Clocks->RTCHSI_Frequency = hsi_c1_freq;
00018a  f8c1c00c          STR      r12,[r1,#0xc]
;;;1565   
;;;1566     /* Compute RTCHSE_CLK frequency */
;;;1567     temp = MDR_RST_CLK->RTC_CLOCK >> RST_CLK_RTC_CLOCK_HSE_SEL_Pos;
00018e  f8dfb0dc          LDR      r11,|L11.620|
000192  f8db0018          LDR      r0,[r11,#0x18]
;;;1568     if ((temp & 0x08U) == 0) {
000196  f0000b08          AND      r11,r0,#8
00019a  f1bb0f00          CMP      r11,#0
00019e  d104              BNE      |L11.426|
;;;1569       hse_c1_freq = HSE_Value;
0001a0  f8dfb0cc          LDR      r11,|L11.624|
0001a4  f8cdb004          STR      r11,[sp,#4]
0001a8  e00d              B        |L11.454|
                  |L11.426|
;;;1570     }
;;;1571     else {
;;;1572       temp = 1 << ((temp & 0x07U) + 1);
0001aa  f0000b07          AND      r11,r0,#7
0001ae  f10b0b01          ADD      r11,r11,#1
0001b2  f04f0e01          MOV      lr,#1
0001b6  fa0ef00b          LSL      r0,lr,r11
;;;1573       hse_c1_freq = HSE_Value / temp;
0001ba  f8dfb0b4          LDR      r11,|L11.624|
0001be  fbbbfbf0          UDIV     r11,r11,r0
0001c2  f8cdb004          STR      r11,[sp,#4]
                  |L11.454|
;;;1574     }
;;;1575     RST_CLK_Clocks->RTCHSE_Frequency = hse_c1_freq;
0001c6  f8ddb004          LDR      r11,[sp,#4]
0001ca  f8c1b010          STR      r11,[r1,#0x10]
;;;1576   
;;;1577     /* Compute ADC_CLK frequency */
;;;1578   
;;;1579     /* Select ADC_C1 from CPU_C1, LSI, USB_C1, CPU_C2, USB_C2 cases */
;;;1580     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C1_SEL_Pos)
0001ce  f8dfb09c          LDR      r11,|L11.620|
0001d2  f8dbb014          LDR      r11,[r11,#0x14]
0001d6  f00b0b03          AND      r11,r11,#3
0001da  f1bb0f00          CMP      r11,#0
0001de  d006              BEQ      |L11.494|
0001e0  f1bb0f01          CMP      r11,#1
0001e4  d005              BEQ      |L11.498|
0001e6  f1bb0f02          CMP      r11,#2
0001ea  d106              BNE      |L11.506|
0001ec  e003              B        |L11.502|
                  |L11.494|
;;;1581         & (uint32_t) 0x03) {
;;;1582       case 0:
;;;1583         /* CPU_C1 */
;;;1584         adc_c1_freq = cpu_c1_freq;
0001ee  461e              MOV      r6,r3
;;;1585         break;
0001f0  e005              B        |L11.510|
                  |L11.498|
;;;1586       case 1:
;;;1587         /* USB_C1 */
;;;1588         adc_c1_freq = usb_c1_freq;
0001f2  462e              MOV      r6,r5
;;;1589         break;
0001f4  e003              B        |L11.510|
                  |L11.502|
;;;1590       case 2:
;;;1591         /* CPU_C2 */
;;;1592         adc_c1_freq = cpu_c2_freq;
0001f6  4626              MOV      r6,r4
;;;1593         break;
0001f8  e001              B        |L11.510|
                  |L11.506|
;;;1594       default: /* case 3 */
;;;1595         /* USB_C2 */
;;;1596         adc_c1_freq = usb_c2_freq;
0001fa  463e              MOV      r6,r7
;;;1597         break;
0001fc  bf00              NOP      
                  |L11.510|
0001fe  bf00              NOP                            ;1585
;;;1598     }
;;;1599   
;;;1600     /* Select ADC_C2 from LSE, LSI, ADC_C1, HSI_C1 cases */
;;;1601     switch ((MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C2_SEL_Pos)
000200  f8dfb068          LDR      r11,|L11.620|
000204  f8dbb014          LDR      r11,[r11,#0x14]
000208  f3cb1b01          UBFX     r11,r11,#4,#2
00020c  f1bb0f00          CMP      r11,#0
000210  d006              BEQ      |L11.544|
000212  f1bb0f01          CMP      r11,#1
000216  d006              BEQ      |L11.550|
000218  f1bb0f02          CMP      r11,#2
00021c  d108              BNE      |L11.560|
00021e  e005              B        |L11.556|
                  |L11.544|
;;;1602         & (uint32_t) 0x03) {
;;;1603       case 0:
;;;1604         /* LSE */
;;;1605         adc_c2_freq = LSE_Value;
000220  f44f4200          MOV      r2,#0x8000
;;;1606         break;
000224  e006              B        |L11.564|
                  |L11.550|
;;;1607       case 1:
;;;1608         /* LSI */
;;;1609         adc_c2_freq = LSI_Value;
000226  f6494240          MOV      r2,#0x9c40
;;;1610         break;
00022a  e003              B        |L11.564|
                  |L11.556|
;;;1611       case 2:
;;;1612         /* ADC_C1 */
;;;1613         adc_c2_freq = adc_c1_freq;
00022c  4632              MOV      r2,r6
;;;1614         break;
00022e  e001              B        |L11.564|
                  |L11.560|
;;;1615       default: /* case 3 */
;;;1616         /* HSI_C1 */
;;;1617         adc_c2_freq = hsi_c1_freq;
000230  4662              MOV      r2,r12
;;;1618         break;
000232  bf00              NOP      
                  |L11.564|
000234  bf00              NOP                            ;1606
;;;1619     }
;;;1620   
;;;1621     temp = MDR_RST_CLK->ADC_MCO_CLOCK >> RST_CLK_ADC_MCO_CLOCK_ADC_C3_SEL_Pos;
000236  f8dfb034          LDR      r11,|L11.620|
00023a  f8dbb014          LDR      r11,[r11,#0x14]
00023e  ea4f201b          LSR      r0,r11,#8
;;;1622     if ((temp & 0x08U) == 0) {
000242  f0000b08          AND      r11,r0,#8
000246  f1bb0f00          CMP      r11,#0
00024a  d101              BNE      |L11.592|
;;;1623       adc_c3_freq = adc_c2_freq;
00024c  4692              MOV      r10,r2
00024e  e009              B        |L11.612|
                  |L11.592|
;;;1624     }
;;;1625     else {
;;;1626       temp = 1 << ((temp & 0x07U) + 1);
000250  f0000b07          AND      r11,r0,#7
000254  f10b0b01          ADD      r11,r11,#1
000258  f04f0e01          MOV      lr,#1
00025c  fa0ef00b          LSL      r0,lr,r11
;;;1627       adc_c3_freq = adc_c2_freq / temp;
000260  fbb2faf0          UDIV     r10,r2,r0
                  |L11.612|
;;;1628     }
;;;1629   
;;;1630     RST_CLK_Clocks->ADC_CLK_Frequency = adc_c3_freq;
000264  f8c1a008          STR      r10,[r1,#8]
;;;1631   }
000268  e8bd8ffc          POP      {r2-r11,pc}
;;;1632   
                          ENDP

                  |L11.620|
                          DCD      0x40020000
                  |L11.624|
                          DCD      0x007a1200

                          AREA ||i.RST_CLK_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RST_CLK_GetFlagStatus PROC
;;;1645     */
;;;1646   FlagStatus RST_CLK_GetFlagStatus(uint32_t RST_CLK_FLAG)
000000  b510              PUSH     {r4,lr}
;;;1647   {
000002  4601              MOV      r1,r0
;;;1648     uint32_t statusreg;
;;;1649     FlagStatus bitstatus;
;;;1650   
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_RST_CLK_FLAG(RST_CLK_FLAG));
;;;1653   
;;;1654     /* Get the register */
;;;1655     if ((FLAG_SFR_MASK & RST_CLK_FLAG) == (uint32_t)0x20) /* The flag to check is in CLOCK_STATUS register */
000004  f00103e0          AND      r3,r1,#0xe0
000008  2b20              CMP      r3,#0x20
00000a  d102              BNE      |L12.18|
;;;1656     {
;;;1657       statusreg = MDR_RST_CLK->CLOCK_STATUS;
00000c  4b07              LDR      r3,|L12.44|
00000e  681a              LDR      r2,[r3,#0]
000010  e001              B        |L12.22|
                  |L12.18|
;;;1658     }
;;;1659     else                                                  /* The flag to check is in REG_0F register */
;;;1660     {
;;;1661       statusreg = MDR_BKP->REG_0F;
000012  4b07              LDR      r3,|L12.48|
000014  6bda              LDR      r2,[r3,#0x3c]
                  |L12.22|
;;;1662     }
;;;1663   
;;;1664     /* Get the flag status on proper position */
;;;1665     if ((statusreg & ((uint32_t)1 << (RST_CLK_FLAG & FLAG_MASK))) != (uint32_t)0x00)
000016  f001041f          AND      r4,r1,#0x1f
00001a  2301              MOVS     r3,#1
00001c  40a3              LSLS     r3,r3,r4
00001e  4013              ANDS     r3,r3,r2
000020  b10b              CBZ      r3,|L12.38|
;;;1666     {
;;;1667       bitstatus = SET;
000022  2001              MOVS     r0,#1
000024  e000              B        |L12.40|
                  |L12.38|
;;;1668     }
;;;1669     else
;;;1670     {
;;;1671       bitstatus = RESET;
000026  2000              MOVS     r0,#0
                  |L12.40|
;;;1672     }
;;;1673   
;;;1674     /* Return the flag status */
;;;1675     return bitstatus;
;;;1676   }
000028  bd10              POP      {r4,pc}
;;;1677   
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x40020000
                  |L12.48|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_HSEclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSEclkPrescaler PROC
;;;1314     */
;;;1315   void RST_CLK_HSEclkPrescaler(uint32_t HSEclkDivValue)
000000  4601              MOV      r1,r0
;;;1316   {
;;;1317     uint32_t temp;
;;;1318   
;;;1319     /* Check the parameters */
;;;1320     assert_param(IS_RST_CLK_HSEclkDivValue(HSEclkDivValue));
;;;1321   
;;;1322     temp = MDR_RST_CLK->RTC_CLOCK;
000002  4a03              LDR      r2,|L13.16|
000004  6990              LDR      r0,[r2,#0x18]
;;;1323     /* Clear HSE_SEL bits */
;;;1324     temp &= HSE_SELclr;
000006  f020000f          BIC      r0,r0,#0xf
;;;1325     /* Set the HSE_SEL bits */
;;;1326     temp |= HSEclkDivValue<<HSE_SEL_OFFSET;
00000a  4308              ORRS     r0,r0,r1
;;;1327     /* Store the new value */
;;;1328     MDR_RST_CLK->RTC_CLOCK = temp;
00000c  6190              STR      r0,[r2,#0x18]
;;;1329   }
00000e  4770              BX       lr
;;;1330   
                          ENDP

                  |L13.16|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSEconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSEconfig PROC
;;;218      */
;;;219    void RST_CLK_HSEconfig(uint32_t RST_CLK_HSE)
000000  490d              LDR      r1,|L14.56|
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_RST_CLK_HSE(RST_CLK_HSE));
;;;223      /* Reset HSEON and HSEBYP bits before configuring the HSE */
;;;224      MDR_RST_CLK->HS_CONTROL &= ~((uint32_t)(RST_CLK_HSE_ON | RST_CLK_HSE_Bypass));
000002  6889              LDR      r1,[r1,#8]
000004  f0210103          BIC      r1,r1,#3
000008  4a0b              LDR      r2,|L14.56|
00000a  6091              STR      r1,[r2,#8]
;;;225      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;226      switch (RST_CLK_HSE)
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L14.22|
000010  2802              CMP      r0,#2
000012  d10e              BNE      |L14.50|
000014  e006              B        |L14.36|
                  |L14.22|
;;;227      {
;;;228        case RST_CLK_HSE_ON:
;;;229          /* Set HSEON bit */
;;;230          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON;
000016  4908              LDR      r1,|L14.56|
000018  6889              LDR      r1,[r1,#8]
00001a  f0410101          ORR      r1,r1,#1
00001e  4a06              LDR      r2,|L14.56|
000020  6091              STR      r1,[r2,#8]
;;;231          break;
000022  e007              B        |L14.52|
                  |L14.36|
;;;232    
;;;233        case RST_CLK_HSE_Bypass:
;;;234          /* Set HSEBYP and HSEON bits */
;;;235          MDR_RST_CLK->HS_CONTROL |= RST_CLK_HSE_ON | RST_CLK_HSE_Bypass;
000024  4904              LDR      r1,|L14.56|
000026  6889              LDR      r1,[r1,#8]
000028  f0410103          ORR      r1,r1,#3
00002c  4a02              LDR      r2,|L14.56|
00002e  6091              STR      r1,[r2,#8]
;;;236          break;
000030  e000              B        |L14.52|
                  |L14.50|
;;;237    
;;;238        default:
;;;239          break;
000032  bf00              NOP      
                  |L14.52|
000034  bf00              NOP                            ;231
;;;240      }
;;;241    }
000036  4770              BX       lr
;;;242    
                          ENDP

                  |L14.56|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSEstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_HSEstatus PROC
;;;283      */
;;;284    ErrorStatus RST_CLK_HSEstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;285    {
;;;286      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;287      ErrorStatus state;
;;;288      FlagStatus flag;
;;;289    
;;;290      /* Wait until HSE is ready or time out is occure */
;;;291      do
000006  bf00              NOP      
                  |L15.8|
;;;292      {
;;;293        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY);
000008  2022              MOVS     r0,#0x22
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;294        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;295      } while ((startCounter < HSEonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L15.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L15.8|
                  |L15.34|
;;;296    
;;;297      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSERDY) != RESET)
000022  2022              MOVS     r0,#0x22
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L15.46|
;;;298      {
;;;299        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L15.48|
                  |L15.46|
;;;300      }
;;;301      else
;;;302      {
;;;303        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L15.48|
;;;304      }
;;;305      return state;
000030  4620              MOV      r0,r4
;;;306    }
000032  bd38              POP      {r3-r5,pc}
;;;307    
                          ENDP


                          AREA ||i.RST_CLK_HSIadjust||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIadjust PROC
;;;440      */
;;;441    void RST_CLK_HSIadjust(uint32_t HSItrimValue)
000000  4601              MOV      r1,r0
;;;442    {
;;;443      uint32_t temp;
;;;444      /* Check the parameters */
;;;445      assert_param(IS_RCC_CLK_HSI_TRIM_VALUE(HSItrimValue));
;;;446      temp = MDR_BKP->REG_0F;
000002  4a04              LDR      r2,|L16.20|
000004  6bd0              LDR      r0,[r2,#0x3c]
;;;447      /* Clear HSITRIM[5:0] bits */
;;;448      temp &= ~HSITRIM_MASK;
000006  f020507c          BIC      r0,r0,#0x3f000000
;;;449      /* Set the HSITRIM[5:0] bits according to HSItrimValue value */
;;;450      temp |= (uint32_t)HSItrimValue << HSITRIM_OFFSET;
00000a  ea406001          ORR      r0,r0,r1,LSL #24
;;;451      /* Store the new value */
;;;452      MDR_BKP->REG_0F = temp;
00000e  63d0              STR      r0,[r2,#0x3c]
;;;453    }
000010  4770              BX       lr
;;;454    
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_HSIclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIclkPrescaler PROC
;;;1246     */
;;;1247   void RST_CLK_HSIclkPrescaler(uint32_t HSIclkDivValue)
000000  4601              MOV      r1,r0
;;;1248   {
;;;1249     uint32_t temp;
;;;1250   
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_RST_CLK_HSIclkDivValue(HSIclkDivValue));
;;;1253   
;;;1254     temp = MDR_RST_CLK->RTC_CLOCK;
000002  4a04              LDR      r2,|L17.20|
000004  6990              LDR      r0,[r2,#0x18]
;;;1255     /* Clear HSI_SEL bits */
;;;1256     temp &= HSI_SELclr;
000006  f02000f0          BIC      r0,r0,#0xf0
;;;1257     /* Set the HSI_SEL bits */
;;;1258     temp |= HSIclkDivValue<<HSI_SEL_OFFSET;
00000a  ea401001          ORR      r0,r0,r1,LSL #4
;;;1259     /* Store the new value */
;;;1260     MDR_RST_CLK->RTC_CLOCK = temp;
00000e  6190              STR      r0,[r2,#0x18]
;;;1261   }
000010  4770              BX       lr
;;;1262   
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_HSIcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_HSIcmd PROC
;;;405      */
;;;406    void RST_CLK_HSIcmd(FunctionalState NewState)
000000  4901              LDR      r1,|L18.8|
;;;407    {
;;;408    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;409      uint32_t temp = 0;
;;;410    #endif
;;;411      /* Check the parameters */
;;;412      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;413    
;;;414    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;415      *(__IO uint32_t *) HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;416    #endif
;;;417    
;;;418    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;419    
;;;420        temp = MDR_BKP->REG_0F;
;;;421      /* Form new value */
;;;422      if (NewState != DISABLE){
;;;423        /* Enable HSI clk by setting the HSE_ON bit in the BKP_REG_0F register */
;;;424        temp |= BKP_REG_0F_HSI_ON;
;;;425      }
;;;426      else{
;;;427        /* Disable HSI clk by resetting the HSE_ON bit in the BKP_REG_0F register */
;;;428        temp &= ~BKP_REG_0F_HSI_ON;
;;;429      }
;;;430      /* Configure REG_0F register with new value */
;;;431      MDR_BKP->REG_0F = temp;
;;;432    #endif /* defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T) */
;;;433    }
000004  4770              BX       lr
;;;434    
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      0x43b007d8

                          AREA ||i.RST_CLK_HSIstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_HSIstatus PROC
;;;459      */
;;;460    ErrorStatus RST_CLK_HSIstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;461    {
;;;462      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;463      ErrorStatus state;
;;;464      FlagStatus flag;
;;;465    
;;;466      /* Wait until HSI is ready or time out is occure */
;;;467      do
000006  bf00              NOP      
                  |L19.8|
;;;468      {
;;;469        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY);
000008  2017              MOVS     r0,#0x17
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;470        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;471      } while ((startCounter < HSIonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L19.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L19.8|
                  |L19.34|
;;;472    
;;;473      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_HSIRDY) != RESET)
000022  2017              MOVS     r0,#0x17
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L19.46|
;;;474      {
;;;475        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L19.48|
                  |L19.46|
;;;476      }
;;;477      else
;;;478      {
;;;479        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L19.48|
;;;480      }
;;;481      return state;
000030  4620              MOV      r0,r4
;;;482    }
000032  bd38              POP      {r3-r5,pc}
;;;483    
                          ENDP


                          AREA ||i.RST_CLK_LSEconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSEconfig PROC
;;;346      */
;;;347    void RST_CLK_LSEconfig(uint32_t RST_CLK_LSE)
000000  490d              LDR      r1,|L20.56|
;;;348    {
;;;349      /* Check the parameters */
;;;350      assert_param(IS_RST_CLK_LSE(RST_CLK_LSE));
;;;351      /* Reset LSEON and LSEBYP bits before configuring the LSE */
;;;352      MDR_BKP->REG_0F &= ~((uint32_t)(RST_CLK_LSE_ON | RST_CLK_LSE_Bypass));
000002  6bc9              LDR      r1,[r1,#0x3c]
000004  f0210103          BIC      r1,r1,#3
000008  4a0b              LDR      r2,|L20.56|
00000a  63d1              STR      r1,[r2,#0x3c]
;;;353      switch (RST_CLK_LSE)
00000c  2801              CMP      r0,#1
00000e  d002              BEQ      |L20.22|
000010  2802              CMP      r0,#2
000012  d10e              BNE      |L20.50|
000014  e006              B        |L20.36|
                  |L20.22|
;;;354      {
;;;355        case RST_CLK_LSE_ON:
;;;356          /* Set LSEON bit */
;;;357          MDR_BKP->REG_0F |= RST_CLK_LSE_ON;
000016  4908              LDR      r1,|L20.56|
000018  6bc9              LDR      r1,[r1,#0x3c]
00001a  f0410101          ORR      r1,r1,#1
00001e  4a06              LDR      r2,|L20.56|
000020  63d1              STR      r1,[r2,#0x3c]
;;;358          break;
000022  e007              B        |L20.52|
                  |L20.36|
;;;359    
;;;360        case RST_CLK_LSE_Bypass:
;;;361          /* Set LSEBYP and LSEON bits */
;;;362          MDR_BKP->REG_0F |= (RST_CLK_LSE_ON | RST_CLK_LSE_Bypass);
000024  4904              LDR      r1,|L20.56|
000026  6bc9              LDR      r1,[r1,#0x3c]
000028  f0410103          ORR      r1,r1,#3
00002c  4a02              LDR      r2,|L20.56|
00002e  63d1              STR      r1,[r2,#0x3c]
;;;363          break;
000030  e000              B        |L20.52|
                  |L20.50|
;;;364    
;;;365        default:
;;;366          break;
000032  bf00              NOP      
                  |L20.52|
000034  bf00              NOP                            ;358
;;;367      }
;;;368    }
000036  4770              BX       lr
;;;369    
                          ENDP

                  |L20.56|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_LSEstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_LSEstatus PROC
;;;374      */
;;;375    ErrorStatus RST_CLK_LSEstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;376    {
;;;377      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;378      ErrorStatus state;
;;;379      FlagStatus flag;
;;;380    
;;;381     /* Wait until LSE is ready or time out is occure */
;;;382     do
000006  bf00              NOP      
                  |L21.8|
;;;383      {
;;;384        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY);
000008  200d              MOVS     r0,#0xd
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;385        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;386      } while ((startCounter < LSEonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L21.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L21.8|
                  |L21.34|
;;;387    
;;;388      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSERDY) != RESET)
000022  200d              MOVS     r0,#0xd
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L21.46|
;;;389      {
;;;390        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L21.48|
                  |L21.46|
;;;391      }
;;;392      else
;;;393      {
;;;394        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L21.48|
;;;395      }
;;;396      return state;
000030  4620              MOV      r0,r4
;;;397    }
000032  bd38              POP      {r3-r5,pc}
;;;398    
                          ENDP


                          AREA ||i.RST_CLK_LSIadjust||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSIadjust PROC
;;;525      */
;;;526    void RST_CLK_LSIadjust(uint32_t LSItrimValue)
000000  4601              MOV      r1,r0
;;;527    {
;;;528      uint32_t temp;
;;;529      /* Check the parameters */
;;;530      assert_param(IS_RCC_CLK_LSI_TRIM_VALUE(LSItrimValue));
;;;531      temp = MDR_BKP->REG_0F;
000002  4a04              LDR      r2,|L22.20|
000004  6bd0              LDR      r0,[r2,#0x3c]
;;;532      /* Clear LSITRIM[4:0] bits */
;;;533      temp &= ~LSITRIM_MASK;
000006  f42010f8          BIC      r0,r0,#0x1f0000
;;;534      /* Set the LSITRIM[4:0] bits according to LSItrimValue value */
;;;535      temp |= (uint32_t)LSItrimValue << LSITRIM_OFFSET;
00000a  ea404001          ORR      r0,r0,r1,LSL #16
;;;536      /* Store the new value */
;;;537      MDR_BKP->REG_0F = temp;
00000e  63d0              STR      r0,[r2,#0x3c]
;;;538    }
000010  4770              BX       lr
;;;539    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x400d8000

                          AREA ||i.RST_CLK_LSIcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_LSIcmd PROC
;;;490      */
;;;491    void RST_CLK_LSIcmd(FunctionalState NewState)
000000  4901              LDR      r1,|L23.8|
;;;492    {
;;;493    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;494      uint32_t temp = 0;
;;;495    #endif
;;;496      /* Check the parameters */
;;;497      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;498    
;;;499    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;500      *(__IO uint32_t *) LSION_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;501    #endif
;;;502    
;;;503    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;504    
;;;505      temp = MDR_BKP->REG_0F;
;;;506      /* Form new value */
;;;507      if (NewState != DISABLE) {
;;;508        /* Enable LSI clk by setting the LSE_ON bit in the BKP_REG_0F register */
;;;509        temp |= BKP_REG_0F_LSI_ON;
;;;510      }
;;;511      else {
;;;512        /* Disable LSI clk by resetting the LSE_ON bit in the BKP_REG_0F register */
;;;513        temp &= ~BKP_REG_0F_LSI_ON;
;;;514      }
;;;515      /* Configure REG_0F register with new value */
;;;516      MDR_BKP->REG_0F = temp;
;;;517    #endif
;;;518    }
000004  4770              BX       lr
;;;519    
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x43b007bc

                          AREA ||i.RST_CLK_LSIstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_LSIstatus PROC
;;;544      */
;;;545    ErrorStatus RST_CLK_LSIstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;546    {
;;;547      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;548      ErrorStatus state;
;;;549      FlagStatus flag;
;;;550    
;;;551      /* Wait until LSI is ready or time out is occure */
;;;552      do
000006  bf00              NOP      
                  |L24.8|
;;;553      {
;;;554        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY);
000008  2015              MOVS     r0,#0x15
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;555        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;556      } while ((startCounter < LSIonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L24.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L24.8|
                  |L24.34|
;;;557    
;;;558      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_LSIRDY) != RESET)
000022  2015              MOVS     r0,#0x15
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L24.46|
;;;559      {
;;;560        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L24.48|
                  |L24.46|
;;;561      }
;;;562      else
;;;563      {
;;;564        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L24.48|
;;;565      }
;;;566      return (state);
000030  4620              MOV      r0,r4
;;;567    }
000032  bd38              POP      {r3-r5,pc}
;;;568    
                          ENDP


                          AREA ||i.RST_CLK_PCLKcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_PCLKcmd PROC
;;;1402     */
;;;1403   void RST_CLK_PCLKcmd(uint32_t RST_CLK_PCLK, FunctionalState NewState)
000000  b129              CBZ      r1,|L25.14|
;;;1404   {
;;;1405     /* Check the parameters */
;;;1406     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1407     assert_param(IS_RST_CLK_PCLK(RST_CLK_PCLK));
;;;1408     if (NewState != DISABLE)
;;;1409     {
;;;1410       MDR_RST_CLK->PER_CLOCK |= RST_CLK_PCLK;
000002  4a06              LDR      r2,|L25.28|
000004  69d2              LDR      r2,[r2,#0x1c]
000006  4302              ORRS     r2,r2,r0
000008  4b04              LDR      r3,|L25.28|
00000a  61da              STR      r2,[r3,#0x1c]
00000c  e004              B        |L25.24|
                  |L25.14|
;;;1411     }
;;;1412     else
;;;1413     {
;;;1414       MDR_RST_CLK->PER_CLOCK &= ~RST_CLK_PCLK;
00000e  4a03              LDR      r2,|L25.28|
000010  69d2              LDR      r2,[r2,#0x1c]
000012  4382              BICS     r2,r2,r0
000014  4b01              LDR      r3,|L25.28|
000016  61da              STR      r2,[r3,#0x1c]
                  |L25.24|
;;;1415     }
;;;1416   }
000018  4770              BX       lr
;;;1417   
                          ENDP

00001a  0000              DCW      0x0000
                  |L25.28|
                          DCD      0x40020000

                          AREA ||i.RST_CLK_RTC_HSEclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_RTC_HSEclkEnable PROC
;;;1337     */
;;;1338   void RST_CLK_RTC_HSEclkEnable(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;1339   {
;;;1340   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1341     uint32_t temp = 0;
;;;1342   #endif
;;;1343     /* Check the parameters */
;;;1344     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1345   
;;;1346   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1347     *(__IO uint32_t *) HSE_RTC_EN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1348   #endif
;;;1349   
;;;1350   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1351   
;;;1352       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1353     /* Form new value */
;;;1354     if (NewState != DISABLE){
;;;1355       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1356       temp |= RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1357     }
;;;1358     else{
;;;1359       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1360       temp &= ~RST_CLK_RTC_CLOCK_HSE_RTC_EN;
;;;1361     }
;;;1362     /* Configure RTC_CLOCK register with new value */
;;;1363     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1364   
;;;1365   #endif
;;;1366   }
000004  4770              BX       lr
;;;1367   
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42400320

                          AREA ||i.RST_CLK_RTC_HSIclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_RTC_HSIclkEnable PROC
;;;1269     */
;;;1270   void RST_CLK_RTC_HSIclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L27.8|
;;;1271   {
;;;1272   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1273     uint32_t temp = 0;
;;;1274   #endif
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1277   
;;;1278   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1279     *(__IO uint32_t *) HSI_RTC_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1280   #endif
;;;1281   
;;;1282   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1283   
;;;1284       temp = MDR_RST_CLK->RTC_CLOCK;
;;;1285     /* Form new value */
;;;1286     if (NewState != DISABLE){
;;;1287       /* Enable HSI RTC clk by setting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1288       temp |= RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1289     }
;;;1290     else{
;;;1291       /* Disable HSI RTC clk by resetting the HSE_RTC_EN bit in the RTC_CLOCK register */
;;;1292       temp &= ~RST_CLK_RTC_CLOCK_HSI_RTC_EN;
;;;1293     }
;;;1294     /* Configure RTC_CLOCK register with new value */
;;;1295     MDR_RST_CLK->RTC_CLOCK = temp;
;;;1296   
;;;1297   #endif
;;;1298   }
000004  4770              BX       lr
;;;1299   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x42400324

                          AREA ||i.RST_CLK_USB_PLLcmd||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLcmd PROC
;;;900      */
;;;901    void RST_CLK_USB_PLLcmd ( FunctionalState NewState )
000000  4901              LDR      r1,|L28.8|
;;;902    {
;;;903    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;904      uint32_t temp = 0;
;;;905    #endif
;;;906      /* Check the parameters */
;;;907      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;908    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;909      *(__IO uint32_t *) PLLUSBON_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;910    #endif
;;;911    
;;;912    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;913    
;;;914      temp = MDR_RST_CLK->PLL_CONTROL;
;;;915      /* Form a new value */
;;;916      if( NewState != DISABLE ) {
;;;917        temp |= RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;918      }
;;;919      else {
;;;920        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_ON;
;;;921      }
;;;922      MDR_RST_CLK->PLL_CONTROL = temp;
;;;923    #endif
;;;924    
;;;925    }
000004  4770              BX       lr
;;;926    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42400080

                          AREA ||i.RST_CLK_USB_PLLconfig||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLconfig PROC
;;;814      */
;;;815    void RST_CLK_USB_PLLconfig ( uint32_t RST_CLK_USB_PLLsource,
000000  b510              PUSH     {r4,lr}
;;;816                             uint32_t RST_CLK_USB_PLLmul )
;;;817    {
000002  4602              MOV      r2,r0
;;;818      uint32_t temp;
;;;819    
;;;820      /* Check the parameters */
;;;821      assert_param(IS_RST_CLK_USB_PLL_SOURCE(RST_CLK_USB_PLLsource));
;;;822      assert_param(IS_RST_CLK_USB_PLL_MUL(RST_CLK_USB_PLLmul));
;;;823    
;;;824      /* Select USBPLL source */
;;;825      temp = MDR_RST_CLK->USB_CLOCK;
000004  4b0c              LDR      r3,|L29.56|
000006  6918              LDR      r0,[r3,#0x10]
;;;826      /* Clear USB_C1_SEL bits */
;;;827      temp &= USB_C1_SELclr;
000008  f0200003          BIC      r0,r0,#3
;;;828      /* Set the USB_C1_SEL bits */
;;;829      temp |= RST_CLK_USB_PLLsource;
00000c  4310              ORRS     r0,r0,r2
;;;830      /* Store the new value */
;;;831      MDR_RST_CLK->USB_CLOCK = temp;
00000e  6118              STR      r0,[r3,#0x10]
;;;832    
;;;833      /* Set USBPLL multiplier */
;;;834      temp = MDR_RST_CLK->PLL_CONTROL;
000010  6858              LDR      r0,[r3,#4]
;;;835      /* Clear PLLMUL[3:0] bits */
;;;836      temp &= PLLUSBmulclr;
000012  f02000f0          BIC      r0,r0,#0xf0
;;;837      /* Set the PLLMUL[3:0] bits */
;;;838      temp |= (RST_CLK_USB_PLLmul << PLLUSBMUL_OFFSET);
000016  ea401001          ORR      r0,r0,r1,LSL #4
;;;839      /* Store the new value */
;;;840      MDR_RST_CLK->PLL_CONTROL = temp;
00001a  6058              STR      r0,[r3,#4]
;;;841    
;;;842    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;843      if (*(__IO uint32_t *) PLLUSBON_BB) {
00001c  4b07              LDR      r3,|L29.60|
00001e  681b              LDR      r3,[r3,#0]
000020  b143              CBZ      r3,|L29.52|
;;;844        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x01;
000022  2301              MOVS     r3,#1
000024  4c05              LDR      r4,|L29.60|
000026  1d24              ADDS     r4,r4,#4
000028  6023              STR      r3,[r4,#0]
;;;845        *(__IO uint32_t *) PLLUSBRLD_BB = (uint32_t) 0x00;
00002a  2300              MOVS     r3,#0
00002c  4c03              LDR      r4,|L29.60|
00002e  3c80              SUBS     r4,r4,#0x80
000030  f8c43084          STR      r3,[r4,#0x84]
                  |L29.52|
;;;846      }
;;;847    #endif
;;;848    
;;;849    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;850      if( MDR_RST_CLK->PLL_CONTROL & (RST_CLK_PLL_CONTROL_PLL_USB_ON) ) {
;;;851        temp = MDR_RST_CLK->PLL_CONTROL;
;;;852        temp |= RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;853        MDR_RST_CLK->PLL_CONTROL = temp;
;;;854        temp &= ~RST_CLK_PLL_CONTROL_PLL_USB_RLD;
;;;855        MDR_RST_CLK->PLL_CONTROL = temp;
;;;856      }
;;;857    #endif
;;;858    }
000034  bd10              POP      {r4,pc}
;;;859    
                          ENDP

000036  0000              DCW      0x0000
                  |L29.56|
                          DCD      0x40020000
                  |L29.60|
                          DCD      0x42400080

                          AREA ||i.RST_CLK_USB_PLLstatus||, CODE, READONLY, ALIGN=1

                  RST_CLK_USB_PLLstatus PROC
;;;931      */
;;;932    ErrorStatus RST_CLK_USB_PLLstatus(void)
000000  b538              PUSH     {r3-r5,lr}
;;;933    {
;;;934      __IO uint32_t startCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;935      ErrorStatus state;
;;;936      FlagStatus flag;
;;;937    
;;;938      /* Wait until USBPLL is ready or time out is occure */
;;;939      do
000006  bf00              NOP      
                  |L30.8|
;;;940      {
;;;941        flag = RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY);
000008  2020              MOVS     r0,#0x20
00000a  f7fffffe          BL       RST_CLK_GetFlagStatus
00000e  4605              MOV      r5,r0
;;;942        startCounter++;
000010  9800              LDR      r0,[sp,#0]
000012  1c40              ADDS     r0,r0,#1
000014  9000              STR      r0,[sp,#0]
;;;943      } while ((startCounter < PLLUSBonTimeOut) && (flag == RESET));
000016  9800              LDR      r0,[sp,#0]
000018  f5b06fc0          CMP      r0,#0x600
00001c  d201              BCS      |L30.34|
00001e  2d00              CMP      r5,#0
000020  d0f2              BEQ      |L30.8|
                  |L30.34|
;;;944    
;;;945      if (RST_CLK_GetFlagStatus(RST_CLK_FLAG_PLLUSBRDY) != RESET)
000022  2020              MOVS     r0,#0x20
000024  f7fffffe          BL       RST_CLK_GetFlagStatus
000028  b108              CBZ      r0,|L30.46|
;;;946      {
;;;947        state = SUCCESS;
00002a  2401              MOVS     r4,#1
00002c  e000              B        |L30.48|
                  |L30.46|
;;;948      }
;;;949      else
;;;950      {
;;;951        state = ERROR;
00002e  2400              MOVS     r4,#0
                  |L30.48|
;;;952      }
;;;953      return state;
000030  4620              MOV      r0,r4
;;;954    }
000032  bd38              POP      {r3-r5,pc}
;;;955    
                          ENDP


                          AREA ||i.RST_CLK_USB_PLLuse||, CODE, READONLY, ALIGN=2

                  RST_CLK_USB_PLLuse PROC
;;;864      */
;;;865    void RST_CLK_USB_PLLuse ( FunctionalState UsePLL )
000000  4901              LDR      r1,|L31.8|
;;;866    {
;;;867    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;868      uint32_t temp = 0;
;;;869    #endif
;;;870      /* Check the parameters */
;;;871      assert_param(IS_FUNCTIONAL_STATE(UsePLL));
;;;872    
;;;873    #if defined ( USE_MDR1986VE9x ) || defined (USE_MDR1901VC1T) /* for Cortex M3 series */
;;;874      *(__IO uint32_t *) USB_C2_SEL_BB = (uint32_t) UsePLL;
000002  6008              STR      r0,[r1,#0]
;;;875    #endif // #ifdef USE_MDR1986VE9x /* for Cortex M3 series */
;;;876    
;;;877    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;878    
;;;879      temp = MDR_RST_CLK->USB_CLOCK;
;;;880      /* Form new value */
;;;881      if (UsePLL != DISABLE){
;;;882        /* Use the USB PLL output as input for USB_C3_SEL
;;;883         * by setting the USB_C2_SEL bit in the USB_CLOCK register */
;;;884        temp |= (1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;885      }
;;;886      else{
;;;887        /* Use the USB_C1 output as input for USB_C3_SEL
;;;888         * by resetting the USB_C2_SEL bit in the USB_CLOCK register */
;;;889        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C2_SEL_Pos);
;;;890      }
;;;891      /* Configure USB_CLOCK register with new value */
;;;892      MDR_RST_CLK->USB_CLOCK = temp;
;;;893    #endif
;;;894    }
000004  4770              BX       lr
;;;895    
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x42400208

                          AREA ||i.RST_CLK_USBclkEnable||, CODE, READONLY, ALIGN=2

                  RST_CLK_USBclkEnable PROC
;;;1000     */
;;;1001   void RST_CLK_USBclkEnable ( FunctionalState NewState )
000000  4901              LDR      r1,|L32.8|
;;;1002   {
;;;1003   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1004     uint32_t temp = 0;
;;;1005   #endif
;;;1006     /* Check the parameters */
;;;1007     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1008   
;;;1009   #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;1010     *(__IO uint32_t *) USB_CLK_EN_BB = (uint32_t) NewState;
000002  6008              STR      r0,[r1,#0]
;;;1011   #endif
;;;1012   
;;;1013   #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;1014   
;;;1015     temp = MDR_RST_CLK->USB_CLOCK;
;;;1016   
;;;1017     /* Form new value */
;;;1018     if (NewState != DISABLE){
;;;1019       /* Enable the USB clk by setting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1020       temp |= (1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1021     }
;;;1022     else{
;;;1023       /* Disable the USB clk by resetting the USB_CLK_EN bit in the USB_CLOCK register */
;;;1024       temp &= ~(1<< RST_CLK_USB_CLOCK_USB_CLK_EN_Pos);
;;;1025     }
;;;1026     /* Configure USB_CLOCK register with new value */
;;;1027     MDR_RST_CLK->USB_CLOCK = temp;
;;;1028   #endif
;;;1029   }
000004  4770              BX       lr
;;;1030   
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42400220

                          AREA ||i.RST_CLK_USBclkPrescaler||, CODE, READONLY, ALIGN=2

                  RST_CLK_USBclkPrescaler PROC
;;;962      */
;;;963    void RST_CLK_USBclkPrescaler(FunctionalState NewState)
000000  4901              LDR      r1,|L33.8|
;;;964    {
;;;965    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;966      uint32_t temp = 0;
;;;967    #endif
;;;968      /* Check the parameters */
;;;969      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;970    
;;;971    #if defined  (USE_MDR1986VE9x) || defined (USE_MDR1901VC1T)
;;;972       *(__IO uint32_t *) USB_C3_SEL_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;973    #endif
;;;974    
;;;975    #if defined ( USE_MDR1986VE3 ) || defined (USE_MDR1986VE1T)
;;;976    
;;;977      temp = MDR_RST_CLK->USB_CLOCK;
;;;978    
;;;979      /* Form new value */
;;;980      if (NewState != DISABLE){
;;;981        /* Enable the USB prescaler by setting the USB_C3_SEL bit in the USB_CLOCK register */
;;;982        temp |= (1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;983      }
;;;984      else{
;;;985        /* Disable the USB prescaler by resetting the USB_C3_SEL bit in the USB_CLOCK register */
;;;986        temp &= ~(1<< RST_CLK_USB_CLOCK_USB_C3_SEL_Pos);
;;;987      }
;;;988      /* Configure USB_CLOCK register with new value */
;;;989      MDR_RST_CLK->USB_CLOCK = temp;
;;;990    #endif
;;;991    
;;;992    }
000004  4770              BX       lr
;;;993    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      0x42400210

                          AREA ||i.RST_CLK_WarmDeInit||, CODE, READONLY, ALIGN=2

                  RST_CLK_WarmDeInit PROC
;;;181      */
;;;182    void RST_CLK_WarmDeInit(void)
000000  b500              PUSH     {lr}
;;;183    {
;;;184      /* Prepare HSI clk */
;;;185      RST_CLK_HSIcmd(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       RST_CLK_HSIcmd
;;;186      RST_CLK_HSIstatus();
000008  f7fffffe          BL       RST_CLK_HSIstatus
;;;187      RST_CLK_CPUclkSelection(RST_CLK_CPUclkHSI);
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       RST_CLK_CPUclkSelection
;;;188    
;;;189      /* Reset CPU_CLOCK bits */
;;;190      MDR_RST_CLK->CPU_CLOCK   &= (uint32_t)0x00000000;
000012  480e              LDR      r0,|L34.76|
000014  68c0              LDR      r0,[r0,#0xc]
000016  2000              MOVS     r0,#0
000018  490c              LDR      r1,|L34.76|
00001a  60c8              STR      r0,[r1,#0xc]
;;;191    
;;;192      /* Reset PLL_CONTROL bits */
;;;193      MDR_RST_CLK->PLL_CONTROL &= (uint32_t)0x00000000;
00001c  4608              MOV      r0,r1
00001e  6840              LDR      r0,[r0,#4]
000020  2000              MOVS     r0,#0
000022  6048              STR      r0,[r1,#4]
;;;194    
;;;195      /* Reset HSEON and HSEBYP bits */
;;;196      MDR_RST_CLK->HS_CONTROL  &= (uint32_t)0x00000000;
000024  4608              MOV      r0,r1
000026  6880              LDR      r0,[r0,#8]
000028  2000              MOVS     r0,#0
00002a  6088              STR      r0,[r1,#8]
;;;197    
;;;198      /* Reset USB_CLOCK bits */
;;;199      MDR_RST_CLK->USB_CLOCK   &= (uint32_t)0x00000000;
00002c  4608              MOV      r0,r1
00002e  6900              LDR      r0,[r0,#0x10]
000030  2000              MOVS     r0,#0
000032  6108              STR      r0,[r1,#0x10]
;;;200    
;;;201      /* Reset ADC_MCO_CLOCK bits */
;;;202      MDR_RST_CLK->ADC_MCO_CLOCK   &= (uint32_t)0x00000000;
000034  4608              MOV      r0,r1
000036  6940              LDR      r0,[r0,#0x14]
000038  2000              MOVS     r0,#0
00003a  6148              STR      r0,[r1,#0x14]
;;;203    
;;;204      /* Reset RTC_CLOCK bits */
;;;205      MDR_RST_CLK->RTC_CLOCK   &= (uint32_t)0x00000000;
00003c  4608              MOV      r0,r1
00003e  6980              LDR      r0,[r0,#0x18]
000040  2000              MOVS     r0,#0
000042  6188              STR      r0,[r1,#0x18]
;;;206    
;;;207      /* Reset all clock but RTC_CLK bit */
;;;208      MDR_RST_CLK->PER_CLOCK   = (uint32_t)PCLK_BIT(MDR_RST_CLK_BASE) | (uint32_t)PCLK_BIT(MDR_BKP_BASE);
000044  4802              LDR      r0,|L34.80|
000046  61c8              STR      r0,[r1,#0x1c]
;;;209    }
000048  bd00              POP      {pc}
;;;210    
                          ENDP

00004a  0000              DCW      0x0000
                  |L34.76|
                          DCD      0x40020000
                  |L34.80|
                          DCD      0x08000010

;*** Start embedded assembler ***

#line 1 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\Keil\\MDR1986BExx\\1.51\\Libraries\\MDR32F9Qx_StdPeriph_Driver\\src\\MDR32F9Qx_rst_clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16|
#line 467 "C:\\Users\\AN-Mi\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.5.1\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REV16| PROC
#line 468

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH|
#line 482
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____REVSH| PROC
#line 483

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____RRX|
#line 669
|__asm___19_MDR32F9Qx_rst_clk_c_19fd4a9d____RRX| PROC
#line 670

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
